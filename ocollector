#!/usr/bin/env perl

# This chunk of stuff was generated by App::FatPacker. To find the original
# file's code, look for the end of this BEGIN block or the string 'FATPACK'
BEGIN {
my %fatpacked;

$fatpacked{"Class/Accessor.pm"} = <<'CLASS_ACCESSOR';
  package Class::Accessor;
  require 5.00502;
  use strict;
  $Class::Accessor::VERSION = '0.34';
  
  sub new {
      my($proto, $fields) = @_;
      my($class) = ref $proto || $proto;
  
      $fields = {} unless defined $fields;
  
      # make a copy of $fields.
      bless {%$fields}, $class;
  }
  
  sub mk_accessors {
      my($self, @fields) = @_;
  
      $self->_mk_accessors('rw', @fields);
  }
  
  if (eval { require Sub::Name }) {
      Sub::Name->import;
  }
  
  {
      no strict 'refs';
  
      sub import {
          my ($class, @what) = @_;
          my $caller = caller;
          for (@what) {
              if (/^(?:antlers|moose-?like)$/i) {
                  *{"${caller}::has"} = sub {
                      my ($f, %args) = @_;
                      $caller->_mk_accessors(($args{is}||"rw"), $f);
                  };
                  *{"${caller}::extends"} = sub {
                      @{"${caller}::ISA"} = @_;
                      unless (grep $_->can("_mk_accessors"), @_) {
                          push @{"${caller}::ISA"}, $class;
                      }
                  };
                  # we'll use their @ISA as a default, in case it happens to be
                  # set already
                  &{"${caller}::extends"}(@{"${caller}::ISA"});
              }
          }
      }
  
      sub follow_best_practice {
          my($self) = @_;
          my $class = ref $self || $self;
          *{"${class}::accessor_name_for"}  = \&best_practice_accessor_name_for;
          *{"${class}::mutator_name_for"}  = \&best_practice_mutator_name_for;
      }
  
      sub _mk_accessors {
          my($self, $access, @fields) = @_;
          my $class = ref $self || $self;
          my $ra = $access eq 'rw' || $access eq 'ro';
          my $wa = $access eq 'rw' || $access eq 'wo';
  
          foreach my $field (@fields) {
              my $accessor_name = $self->accessor_name_for($field);
              my $mutator_name = $self->mutator_name_for($field);
              if( $accessor_name eq 'DESTROY' or $mutator_name eq 'DESTROY' ) {
                  $self->_carp("Having a data accessor named DESTROY  in '$class' is unwise.");
              }
              if ($accessor_name eq $mutator_name) {
                  my $accessor;
                  if ($ra && $wa) {
                      $accessor = $self->make_accessor($field);
                  } elsif ($ra) {
                      $accessor = $self->make_ro_accessor($field);
                  } else {
                      $accessor = $self->make_wo_accessor($field);
                  }
                  my $fullname = "${class}::$accessor_name";
                  my $subnamed = 0;
                  unless (defined &{$fullname}) {
                      subname($fullname, $accessor) if defined &subname;
                      $subnamed = 1;
                      *{$fullname} = $accessor;
                  }
                  if ($accessor_name eq $field) {
                      # the old behaviour
                      my $alias = "${class}::_${field}_accessor";
                      subname($alias, $accessor) if defined &subname and not $subnamed;
                      *{$alias} = $accessor unless defined &{$alias};
                  }
              } else {
                  my $fullaccname = "${class}::$accessor_name";
                  my $fullmutname = "${class}::$mutator_name";
                  if ($ra and not defined &{$fullaccname}) {
                      my $accessor = $self->make_ro_accessor($field);
                      subname($fullaccname, $accessor) if defined &subname;
                      *{$fullaccname} = $accessor;
                  }
                  if ($wa and not defined &{$fullmutname}) {
                      my $mutator = $self->make_wo_accessor($field);
                      subname($fullmutname, $mutator) if defined &subname;
                      *{$fullmutname} = $mutator;
                  }
              }
          }
      }
  
  }
  
  sub mk_ro_accessors {
      my($self, @fields) = @_;
  
      $self->_mk_accessors('ro', @fields);
  }
  
  sub mk_wo_accessors {
      my($self, @fields) = @_;
  
      $self->_mk_accessors('wo', @fields);
  }
  
  sub best_practice_accessor_name_for {
      my ($class, $field) = @_;
      return "get_$field";
  }
  
  sub best_practice_mutator_name_for {
      my ($class, $field) = @_;
      return "set_$field";
  }
  
  sub accessor_name_for {
      my ($class, $field) = @_;
      return $field;
  }
  
  sub mutator_name_for {
      my ($class, $field) = @_;
      return $field;
  }
  
  sub set {
      my($self, $key) = splice(@_, 0, 2);
  
      if(@_ == 1) {
          $self->{$key} = $_[0];
      }
      elsif(@_ > 1) {
          $self->{$key} = [@_];
      }
      else {
          $self->_croak("Wrong number of arguments received");
      }
  }
  
  sub get {
      my $self = shift;
  
      if(@_ == 1) {
          return $self->{$_[0]};
      }
      elsif( @_ > 1 ) {
          return @{$self}{@_};
      }
      else {
          $self->_croak("Wrong number of arguments received");
      }
  }
  
  sub make_accessor {
      my ($class, $field) = @_;
  
      return sub {
          my $self = shift;
  
          if(@_) {
              return $self->set($field, @_);
          } else {
              return $self->get($field);
          }
      };
  }
  
  sub make_ro_accessor {
      my($class, $field) = @_;
  
      return sub {
          my $self = shift;
  
          if (@_) {
              my $caller = caller;
              $self->_croak("'$caller' cannot alter the value of '$field' on objects of class '$class'");
          }
          else {
              return $self->get($field);
          }
      };
  }
  
  sub make_wo_accessor {
      my($class, $field) = @_;
  
      return sub {
          my $self = shift;
  
          unless (@_) {
              my $caller = caller;
              $self->_croak("'$caller' cannot access the value of '$field' on objects of class '$class'");
          }
          else {
              return $self->set($field, @_);
          }
      };
  }
  
  
  use Carp ();
  
  sub _carp {
      my ($self, $msg) = @_;
      Carp::carp($msg || $self);
      return;
  }
  
  sub _croak {
      my ($self, $msg) = @_;
      Carp::croak($msg || $self);
      return;
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
    Class::Accessor - Automated accessor generation
  
  =head1 SYNOPSIS
  
    package Foo;
    use base qw(Class::Accessor);
    Foo->follow_best_practice;
    Foo->mk_accessors(qw(name role salary));
  
    # or if you prefer a Moose-like interface...
   
    package Foo;
    use Class::Accessor "antlers";
    has name => ( is => "rw", isa => "Str" );
    has role => ( is => "rw", isa => "Str" );
    has salary => ( is => "rw", isa => "Num" );
  
    # Meanwhile, in a nearby piece of code!
    # Class::Accessor provides new().
    my $mp = Foo->new({ name => "Marty", role => "JAPH" });
  
    my $job = $mp->role;  # gets $mp->{role}
    $mp->salary(400000);  # sets $mp->{salary} = 400000 # I wish
    
    # like my @info = @{$mp}{qw(name role)}
    my @info = $mp->get(qw(name role));
    
    # $mp->{salary} = 400000
    $mp->set('salary', 400000);
  
  
  =head1 DESCRIPTION
  
  This module automagically generates accessors/mutators for your class.
  
  Most of the time, writing accessors is an exercise in cutting and
  pasting.  You usually wind up with a series of methods like this:
  
      sub name {
          my $self = shift;
          if(@_) {
              $self->{name} = $_[0];
          }
          return $self->{name};
      }
  
      sub salary {
          my $self = shift;
          if(@_) {
              $self->{salary} = $_[0];
          }
          return $self->{salary};
      }
  
    # etc...
  
  One for each piece of data in your object.  While some will be unique,
  doing value checks and special storage tricks, most will simply be
  exercises in repetition.  Not only is it Bad Style to have a bunch of
  repetitious code, but it's also simply not lazy, which is the real
  tragedy.
  
  If you make your module a subclass of Class::Accessor and declare your
  accessor fields with mk_accessors() then you'll find yourself with a
  set of automatically generated accessors which can even be
  customized!
  
  The basic set up is very simple:
  
      package Foo;
      use base qw(Class::Accessor);
      Foo->mk_accessors( qw(far bar car) );
  
  Done.  Foo now has simple far(), bar() and car() accessors
  defined.
  
  Alternatively, if you want to follow Damian's I<best practice> guidelines 
  you can use:
  
      package Foo;
      use base qw(Class::Accessor);
      Foo->follow_best_practice;
      Foo->mk_accessors( qw(far bar car) );
  
  B<Note:> you must call C<follow_best_practice> before calling C<mk_accessors>.
  
  =head2 Moose-like
  
  By popular demand we now have a simple Moose-like interface.  You can now do:
  
      package Foo;
      use Class::Accessor "antlers";
      has far => ( is => "rw" );
      has bar => ( is => "rw" );
      has car => ( is => "rw" );
  
  Currently only the C<is> attribute is supported.
  
  =head1 CONSTRUCTOR
  
  Class::Accessor provides a basic constructor, C<new>.  It generates a
  hash-based object and can be called as either a class method or an
  object method.  
  
  =head2 new
  
      my $obj = Foo->new;
      my $obj = $other_obj->new;
  
      my $obj = Foo->new(\%fields);
      my $obj = $other_obj->new(\%fields);
  
  It takes an optional %fields hash which is used to initialize the
  object (handy if you use read-only accessors).  The fields of the hash
  correspond to the names of your accessors, so...
  
      package Foo;
      use base qw(Class::Accessor);
      Foo->mk_accessors('foo');
  
      my $obj = Foo->new({ foo => 42 });
      print $obj->foo;    # 42
  
  however %fields can contain anything, new() will shove them all into
  your object.
  
  =head1 MAKING ACCESSORS
  
  =head2 follow_best_practice
  
  In Damian's Perl Best Practices book he recommends separate get and set methods
  with the prefix set_ and get_ to make it explicit what you intend to do.  If you
  want to create those accessor methods instead of the default ones, call:
  
      __PACKAGE__->follow_best_practice
  
  B<before> you call any of the accessor-making methods.
  
  =head2 accessor_name_for / mutator_name_for
  
  You may have your own crazy ideas for the names of the accessors, so you can
  make those happen by overriding C<accessor_name_for> and C<mutator_name_for> in
  your subclass.  (I copied that idea from Class::DBI.)
  
  =head2 mk_accessors
  
      __PACKAGE__->mk_accessors(@fields);
  
  This creates accessor/mutator methods for each named field given in
  @fields.  Foreach field in @fields it will generate two accessors.
  One called "field()" and the other called "_field_accessor()".  For
  example:
  
      # Generates foo(), _foo_accessor(), bar() and _bar_accessor().
      __PACKAGE__->mk_accessors(qw(foo bar));
  
  See L<CAVEATS AND TRICKS/"Overriding autogenerated accessors">
  for details.
  
  =head2 mk_ro_accessors
  
    __PACKAGE__->mk_ro_accessors(@read_only_fields);
  
  Same as mk_accessors() except it will generate read-only accessors
  (ie. true accessors).  If you attempt to set a value with these
  accessors it will throw an exception.  It only uses get() and not
  set().
  
      package Foo;
      use base qw(Class::Accessor);
      Foo->mk_ro_accessors(qw(foo bar));
  
      # Let's assume we have an object $foo of class Foo...
      print $foo->foo;  # ok, prints whatever the value of $foo->{foo} is
      $foo->foo(42);    # BOOM!  Naughty you.
  
  
  =head2 mk_wo_accessors
  
    __PACKAGE__->mk_wo_accessors(@write_only_fields);
  
  Same as mk_accessors() except it will generate write-only accessors
  (ie. mutators).  If you attempt to read a value with these accessors
  it will throw an exception.  It only uses set() and not get().
  
  B<NOTE> I'm not entirely sure why this is useful, but I'm sure someone
  will need it.  If you've found a use, let me know.  Right now it's here
  for orthoginality and because it's easy to implement.
  
      package Foo;
      use base qw(Class::Accessor);
      Foo->mk_wo_accessors(qw(foo bar));
  
      # Let's assume we have an object $foo of class Foo...
      $foo->foo(42);      # OK.  Sets $self->{foo} = 42
      print $foo->foo;    # BOOM!  Can't read from this accessor.
  
  =head1 Moose!
  
  If you prefer a Moose-like interface to create accessors, you can use C<has> by
  importing this module like this:
  
    use Class::Accessor "antlers";
  
  or
  
    use Class::Accessor "moose-like";
  
  Then you can declare accessors like this:
  
    has alpha => ( is => "rw", isa => "Str" );
    has beta  => ( is => "ro", isa => "Str" );
    has gamma => ( is => "wo", isa => "Str" );
  
  Currently only the C<is> attribute is supported.  And our C<is> also supports
  the "wo" value to make a write-only accessor.
  
  If you are using the Moose-like interface then you should use the C<extends>
  rather than tweaking your C<@ISA> directly.  Basically, replace
  
    @ISA = qw/Foo Bar/;
  
  with
  
    extends(qw/Foo Bar/);
  
  =head1 DETAILS
  
  An accessor generated by Class::Accessor looks something like
  this:
  
      # Your foo may vary.
      sub foo {
          my($self) = shift;
          if(@_) {    # set
              return $self->set('foo', @_);
          }
          else {
              return $self->get('foo');
          }
      }
  
  Very simple.  All it does is determine if you're wanting to set a
  value or get a value and calls the appropriate method.
  Class::Accessor provides default get() and set() methods which
  your class can override.  They're detailed later.
  
  =head2 Modifying the behavior of the accessor
  
  Rather than actually modifying the accessor itself, it is much more
  sensible to simply override the two key methods which the accessor
  calls.  Namely set() and get().
  
  If you -really- want to, you can override make_accessor().
  
  =head2 set
  
      $obj->set($key, $value);
      $obj->set($key, @values);
  
  set() defines how generally one stores data in the object.
  
  override this method to change how data is stored by your accessors.
  
  =head2 get
  
      $value  = $obj->get($key);
      @values = $obj->get(@keys);
  
  get() defines how data is retreived from your objects.
  
  override this method to change how it is retreived.
  
  =head2 make_accessor
  
      $accessor = __PACKAGE__->make_accessor($field);
  
  Generates a subroutine reference which acts as an accessor for the given
  $field.  It calls get() and set().
  
  If you wish to change the behavior of your accessors, try overriding
  get() and set() before you start mucking with make_accessor().
  
  =head2 make_ro_accessor
  
      $read_only_accessor = __PACKAGE__->make_ro_accessor($field);
  
  Generates a subroutine refrence which acts as a read-only accessor for
  the given $field.  It only calls get().
  
  Override get() to change the behavior of your accessors.
  
  =head2 make_wo_accessor
  
      $read_only_accessor = __PACKAGE__->make_wo_accessor($field);
  
  Generates a subroutine refrence which acts as a write-only accessor
  (mutator) for the given $field.  It only calls set().
  
  Override set() to change the behavior of your accessors.
  
  =head1 EXCEPTIONS
  
  If something goes wrong Class::Accessor will warn or die by calling Carp::carp
  or Carp::croak.  If you don't like this you can override _carp() and _croak() in
  your subclass and do whatever else you want.
  
  =head1 EFFICIENCY
  
  Class::Accessor does not employ an autoloader, thus it is much faster
  than you'd think.  Its generated methods incur no special penalty over
  ones you'd write yourself.
  
    accessors:
                Rate  Basic   Fast Faster Direct
    Basic   367589/s     --   -51%   -55%   -89%
    Fast    747964/s   103%     --    -9%   -77%
    Faster  819199/s   123%    10%     --   -75%
    Direct 3245887/s   783%   334%   296%     --
  
    mutators:
                Rate    Acc   Fast Faster Direct
    Acc     265564/s     --   -54%   -63%   -91%
    Fast    573439/s   116%     --   -21%   -80%
    Faster  724710/s   173%    26%     --   -75%
    Direct 2860979/s   977%   399%   295%     --
  
  Class::Accessor::Fast is faster than methods written by an average programmer
  (where "average" is based on Schwern's example code).
  
  Class::Accessor is slower than average, but more flexible.
  
  Class::Accessor::Faster is even faster than Class::Accessor::Fast.  It uses an
  array internally, not a hash.  This could be a good or bad feature depending on
  your point of view.
  
  Direct hash access is, of course, much faster than all of these, but it
  provides no encapsulation.
  
  Of course, it's not as simple as saying "Class::Accessor is slower than
  average".  These are benchmarks for a simple accessor.  If your accessors do
  any sort of complicated work (such as talking to a database or writing to a
  file) the time spent doing that work will quickly swamp the time spend just
  calling the accessor.  In that case, Class::Accessor and the ones you write
  will be roughly the same speed.
  
  
  =head1 EXAMPLES
  
  Here's an example of generating an accessor for every public field of
  your class.
  
      package Altoids;
      
      use base qw(Class::Accessor Class::Fields);
      use fields qw(curiously strong mints);
      Altoids->mk_accessors( Altoids->show_fields('Public') );
  
      sub new {
          my $proto = shift;
          my $class = ref $proto || $proto;
          return fields::new($class);
      }
  
      my Altoids $tin = Altoids->new;
  
      $tin->curiously('Curiouser and curiouser');
      print $tin->{curiously};    # prints 'Curiouser and curiouser'
  
      
      # Subclassing works, too.
      package Mint::Snuff;
      use base qw(Altoids);
  
      my Mint::Snuff $pouch = Mint::Snuff->new;
      $pouch->strong('Blow your head off!');
      print $pouch->{strong};     # prints 'Blow your head off!'
  
  
  Here's a simple example of altering the behavior of your accessors.
  
      package Foo;
      use base qw(Class::Accessor);
      Foo->mk_accessors(qw(this that up down));
  
      sub get {
          my $self = shift;
  
          # Note every time someone gets some data.
          print STDERR "Getting @_\n";
  
          $self->SUPER::get(@_);
      }
  
      sub set {
          my ($self, $key) = splice(@_, 0, 2);
  
          # Note every time someone sets some data.
          print STDERR "Setting $key to @_\n";
  
          $self->SUPER::set($key, @_);
      }
  
  
  =head1 CAVEATS AND TRICKS
  
  Class::Accessor has to do some internal wackiness to get its
  job done quickly and efficiently.  Because of this, there's a few
  tricks and traps one must know about.
  
  Hey, nothing's perfect.
  
  =head2 Don't make a field called DESTROY
  
  This is bad.  Since DESTROY is a magical method it would be bad for us
  to define an accessor using that name.  Class::Accessor will
  carp if you try to use it with a field named "DESTROY".
  
  =head2 Overriding autogenerated accessors
  
  You may want to override the autogenerated accessor with your own, yet
  have your custom accessor call the default one.  For instance, maybe
  you want to have an accessor which checks its input.  Normally, one
  would expect this to work:
  
      package Foo;
      use base qw(Class::Accessor);
      Foo->mk_accessors(qw(email this that whatever));
  
      # Only accept addresses which look valid.
      sub email {
          my($self) = shift;
          my($email) = @_;
  
          if( @_ ) {  # Setting
              require Email::Valid;
              unless( Email::Valid->address($email) ) {
                  carp("$email doesn't look like a valid address.");
                  return;
              }
          }
  
          return $self->SUPER::email(@_);
      }
  
  There's a subtle problem in the last example, and it's in this line:
  
      return $self->SUPER::email(@_);
  
  If we look at how Foo was defined, it called mk_accessors() which
  stuck email() right into Foo's namespace.  There *is* no
  SUPER::email() to delegate to!  Two ways around this... first is to
  make a "pure" base class for Foo.  This pure class will generate the
  accessors and provide the necessary super class for Foo to use:
  
      package Pure::Organic::Foo;
      use base qw(Class::Accessor);
      Pure::Organic::Foo->mk_accessors(qw(email this that whatever));
  
      package Foo;
      use base qw(Pure::Organic::Foo);
  
  And now Foo::email() can override the generated
  Pure::Organic::Foo::email() and use it as SUPER::email().
  
  This is probably the most obvious solution to everyone but me.
  Instead, what first made sense to me was for mk_accessors() to define
  an alias of email(), _email_accessor().  Using this solution,
  Foo::email() would be written with:
  
      return $self->_email_accessor(@_);
  
  instead of the expected SUPER::email().
  
  
  =head1 AUTHORS
  
  Copyright 2009 Marty Pauley <marty+perl@kasei.com>
  
  This program is free software; you can redistribute it and/or modify it under
  the same terms as Perl itself.  That means either (a) the GNU General Public
  License or (b) the Artistic License.
  
  =head2 ORIGINAL AUTHOR
  
  Michael G Schwern <schwern@pobox.com>
  
  =head2 THANKS
  
  Liz and RUZ for performance tweaks.
  
  Tels, for his big feature request/bug report.
  
  Various presenters at YAPC::Asia 2009 for criticising the non-Moose interface.
  
  =head1 SEE ALSO
  
  See L<Class::Accessor::Fast> and L<Class::Accessor::Faster> if speed is more
  important than flexibility.
  
  These are some modules which do similar things in different ways
  L<Class::Struct>, L<Class::Methodmaker>, L<Class::Generate>,
  L<Class::Class>, L<Class::Contract>, L<Moose>, L<Mouse>
  
  See L<Class::DBI> for an example of this module in use.
  
  =cut
CLASS_ACCESSOR

$fatpacked{"Class/Accessor/Fast.pm"} = <<'CLASS_ACCESSOR_FAST';
  package Class::Accessor::Fast;
  use base 'Class::Accessor';
  use strict;
  $Class::Accessor::Fast::VERSION = '0.34';
  
  sub make_accessor {
      my($class, $field) = @_;
  
      return sub {
          return $_[0]->{$field} if scalar(@_) == 1;
          return $_[0]->{$field}  = scalar(@_) == 2 ? $_[1] : [@_[1..$#_]];
      };
  }
  
  
  sub make_ro_accessor {
      my($class, $field) = @_;
  
      return sub {
          return $_[0]->{$field} if @_ == 1;
          my $caller = caller;
          $_[0]->_croak("'$caller' cannot alter the value of '$field' on objects of class '$class'");
      };
  }
  
  
  sub make_wo_accessor {
      my($class, $field) = @_;
  
      return sub {
          if (@_ == 1) {
              my $caller = caller;
              $_[0]->_croak("'$caller' cannot access the value of '$field' on objects of class '$class'");
          }
          else {
              return $_[0]->{$field} = $_[1] if @_ == 2;
              return (shift)->{$field} = \@_;
          }
      };
  }
  
  
  1;
  
  __END__
  
  =head1 NAME
  
  Class::Accessor::Fast - Faster, but less expandable, accessors
  
  =head1 SYNOPSIS
  
    package Foo;
    use base qw(Class::Accessor::Fast);
  
    # The rest is the same as Class::Accessor but without set() and get().
  
  =head1 DESCRIPTION
  
  This is a faster but less expandable version of Class::Accessor.
  Class::Accessor's generated accessors require two method calls to accompish
  their task (one for the accessor, another for get() or set()).
  Class::Accessor::Fast eliminates calling set()/get() and does the access itself,
  resulting in a somewhat faster accessor.
  
  The downside is that you can't easily alter the behavior of your
  accessors, nor can your subclasses.  Of course, should you need this
  later, you can always swap out Class::Accessor::Fast for
  Class::Accessor.
  
  Read the documentation for Class::Accessor for more info.
  
  =head1 EFFICIENCY
  
  L<Class::Accessor/EFFICIENCY> for an efficiency comparison.
  
  =head1 AUTHORS
  
  Copyright 2007 Marty Pauley <marty+perl@kasei.com>
  
  This program is free software; you can redistribute it and/or modify it under
  the same terms as Perl itself.  That means either (a) the GNU General Public
  License or (b) the Artistic License.
  
  =head2 ORIGINAL AUTHOR
  
  Michael G Schwern <schwern@pobox.com>
  
  =head1 SEE ALSO
  
  L<Class::Accessor>
  
  =cut
CLASS_ACCESSOR_FAST

$fatpacked{"Class/Accessor/Faster.pm"} = <<'CLASS_ACCESSOR_FASTER';
  package Class::Accessor::Faster;
  use base 'Class::Accessor';
  use strict;
  $Class::Accessor::Faster::VERSION = '0.34';
  
  my %slot;
  sub _slot {
      my($class, $field) = @_;
      my $n = $slot{$class}->{$field};
      return $n if defined $n;
      $n = keys %{$slot{$class}};
      $slot{$class}->{$field} = $n;
      return $n;
  }
  
  sub new {
      my($proto, $fields) = @_;
      my($class) = ref $proto || $proto;
      my $self = bless [], $class;
  
      $fields = {} unless defined $fields;
      for my $k (keys %$fields) {
          my $n = $class->_slot($k);
          $self->[$n] = $fields->{$k};
      }
      return $self;
  }
  
  sub make_accessor {
      my($class, $field) = @_;
      my $n = $class->_slot($field);
      return sub {
          return $_[0]->[$n] if scalar(@_) == 1;
          return $_[0]->[$n]  = scalar(@_) == 2 ? $_[1] : [@_[1..$#_]];
      };
  }
  
  sub make_ro_accessor {
      my($class, $field) = @_;
      my $n = $class->_slot($field);
      return sub {
          return $_[0]->[$n] if @_ == 1;
          my $caller = caller;
          $_[0]->_croak("'$caller' cannot alter the value of '$field' on objects of class '$class'");
      };
  }
  
  sub make_wo_accessor {
      my($class, $field) = @_;
      my $n = $class->_slot($field);
      return sub {
          if (@_ == 1) {
              my $caller = caller;
              $_[0]->_croak("'$caller' cannot access the value of '$field' on objects of class '$class'");
          } else {
              return $_[0]->[$n] = $_[1] if @_ == 2;
              return (shift)->[$n] = \@_;
          }
      };
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Class::Accessor::Faster - Even faster, but less expandable, accessors
  
  =head1 SYNOPSIS
  
    package Foo;
    use base qw(Class::Accessor::Faster);
  
  =head1 DESCRIPTION
  
  This is a faster but less expandable version of Class::Accessor::Fast.
  
  Class::Accessor's generated accessors require two method calls to accompish
  their task (one for the accessor, another for get() or set()).
  
  Class::Accessor::Fast eliminates calling set()/get() and does the access itself,
  resulting in a somewhat faster accessor.
  
  Class::Accessor::Faster uses an array reference underneath to be faster.
  
  Read the documentation for Class::Accessor for more info.
  
  =head1 AUTHORS
  
  Copyright 2007 Marty Pauley <marty+perl@kasei.com>
  
  This program is free software; you can redistribute it and/or modify it under
  the same terms as Perl itself.  That means either (a) the GNU General Public
  License or (b) the Artistic License.
  
  =head1 SEE ALSO
  
  L<Class::Accessor>
  
  =cut
CLASS_ACCESSOR_FASTER

$fatpacked{"Date/Format.pm"} = <<'DATE_FORMAT';
  # Copyright (c) 1995-2009 Graham Barr. This program is free
  # software; you can redistribute it and/or modify it under the same terms
  # as Perl itself.
  
  package Date::Format;
  
  use     strict;
  use     vars qw(@EXPORT @ISA $VERSION);
  require Exporter;
  
  $VERSION = "2.24";
  @ISA     = qw(Exporter);
  @EXPORT  = qw(time2str strftime ctime asctime);
  
  sub time2str ($;$$)
  {
   Date::Format::Generic->time2str(@_);
  }
  
  sub strftime ($\@;$)
  {
   Date::Format::Generic->strftime(@_);
  }
  
  sub ctime ($;$)
  {
   my($t,$tz) = @_;
   Date::Format::Generic->time2str("%a %b %e %T %Y\n", $t, $tz); 
  }
  
  sub asctime (\@;$)
  {
   my($t,$tz) = @_;
   Date::Format::Generic->strftime("%a %b %e %T %Y\n", $t, $tz); 
  }
  
  ##
  ##
  ##
  
  package Date::Format::Generic;
  
  use vars qw($epoch $tzname);
  use Time::Zone;
  use Time::Local;
  
  sub ctime
  {
   my($me,$t,$tz) = @_;
   $me->time2str("%a %b %e %T %Y\n", $t, $tz); 
  }
  
  sub asctime
  {
   my($me,$t,$tz) = @_;
   $me->strftime("%a %b %e %T %Y\n", $t, $tz); 
  }
  
  sub _subs
  {
   my $fn;
   $_[1] =~ s/
  		%(O?[%a-zA-Z])
  	   /
                  ($_[0]->can("format_$1") || sub { $1 })->($_[0]);
  	   /sgeox;
  
   $_[1];
  }
  
  sub strftime 
  {
   my($pkg,$fmt,$time);
  
   ($pkg,$fmt,$time,$tzname) = @_;
  
   my $me = ref($pkg) ? $pkg : bless [];
  
   if(defined $tzname)
    {
     $tzname = uc $tzname;
  
     $tzname = sprintf("%+05d",$tzname)
  	unless($tzname =~ /\D/);
  
     $epoch = timegm(@{$time}[0..5]);
  
     @$me = gmtime($epoch + tz_offset($tzname) - tz_offset());
    }
   else
    {
     @$me = @$time;
     undef $epoch;
    }
  
   _subs($me,$fmt);
  }
  
  sub time2str
  {
   my($pkg,$fmt,$time);
  
   ($pkg,$fmt,$time,$tzname) = @_;
  
   my $me = ref($pkg) ? $pkg : bless [], $pkg;
  
   $epoch = $time;
  
   if(defined $tzname)
    {
     $tzname = uc $tzname;
  
     $tzname = sprintf("%+05d",$tzname)
  	unless($tzname =~ /\D/);
  
     $time += tz_offset($tzname);
     @$me = gmtime($time);
    }
   else
    {
     @$me = localtime($time);
    }
   $me->[9] = $time;
   _subs($me,$fmt);
  }
  
  my(@DoW,@MoY,@DoWs,@MoYs,@AMPM,%format,@Dsuf);
  
  @DoW = qw(Sunday Monday Tuesday Wednesday Thursday Friday Saturday);
  
  @MoY = qw(January February March April May June
            July August September October November December);
  
  @DoWs = map { substr($_,0,3) } @DoW;
  @MoYs = map { substr($_,0,3) } @MoY;
  
  @AMPM = qw(AM PM);
  
  @Dsuf = (qw(th st nd rd th th th th th th)) x 3;
  @Dsuf[11,12,13] = qw(th th th);
  @Dsuf[30,31] = qw(th st);
  
  %format = ('x' => "%m/%d/%y",
             'C' => "%a %b %e %T %Z %Y",
             'X' => "%H:%M:%S",
            );
  
  my @locale;
  my $locale = "/usr/share/lib/locale/LC_TIME/default";
  local *LOCALE;
  
  if(open(LOCALE,"$locale"))
   {
    chop(@locale = <LOCALE>);
    close(LOCALE);
  
    @MoYs = @locale[0 .. 11];
    @MoY  = @locale[12 .. 23];
    @DoWs = @locale[24 .. 30];
    @DoW  = @locale[31 .. 37];
    @format{"X","x","C"} =  @locale[38 .. 40];
    @AMPM = @locale[41 .. 42];
   }
  
  sub wkyr {
      my($wstart, $wday, $yday) = @_;
      $wday = ($wday + 7 - $wstart) % 7;
      return int(($yday - $wday + 13) / 7 - 1);
  }
  
  ##
  ## these 6 formatting routins need to be *copied* into the language
  ## specific packages
  ##
  
  my @roman = ('',qw(I II III IV V VI VII VIII IX));
  sub roman {
    my $n = shift;
  
    $n =~ s/(\d)$//;
    my $r = $roman[ $1 ];
  
    if($n =~ s/(\d)$//) {
      (my $t = $roman[$1]) =~ tr/IVX/XLC/;
      $r = $t . $r;
    }
    if($n =~ s/(\d)$//) {
      (my $t = $roman[$1]) =~ tr/IVX/CDM/;
      $r = $t . $r;
    }
    if($n =~ s/(\d)$//) {
      (my $t = $roman[$1]) =~ tr/IVX/M../;
      $r = $t . $r;
    }
    $r;
  }
  
  sub format_a { $DoWs[$_[0]->[6]] }
  sub format_A { $DoW[$_[0]->[6]] }
  sub format_b { $MoYs[$_[0]->[4]] }
  sub format_B { $MoY[$_[0]->[4]] }
  sub format_h { $MoYs[$_[0]->[4]] }
  sub format_p { $_[0]->[2] >= 12 ?  $AMPM[1] : $AMPM[0] }
  sub format_P { lc($_[0]->[2] >= 12 ?  $AMPM[1] : $AMPM[0]) }
  
  sub format_d { sprintf("%02d",$_[0]->[3]) }
  sub format_e { sprintf("%2d",$_[0]->[3]) }
  sub format_H { sprintf("%02d",$_[0]->[2]) }
  sub format_I { sprintf("%02d",$_[0]->[2] % 12 || 12)}
  sub format_j { sprintf("%03d",$_[0]->[7] + 1) }
  sub format_k { sprintf("%2d",$_[0]->[2]) }
  sub format_l { sprintf("%2d",$_[0]->[2] % 12 || 12)}
  sub format_L { $_[0]->[4] + 1 }
  sub format_m { sprintf("%02d",$_[0]->[4] + 1) }
  sub format_M { sprintf("%02d",$_[0]->[1]) }
  sub format_q { sprintf("%01d",int($_[0]->[4] / 3) + 1) }
  sub format_s { 
     $epoch = timelocal(@{$_[0]}[0..5])
  	unless defined $epoch;
     sprintf("%d",$epoch) 
  }
  sub format_S { sprintf("%02d",$_[0]->[0]) }
  sub format_U { wkyr(0, $_[0]->[6], $_[0]->[7]) }
  sub format_w { $_[0]->[6] }
  sub format_W { wkyr(1, $_[0]->[6], $_[0]->[7]) }
  sub format_y { sprintf("%02d",$_[0]->[5] % 100) }
  sub format_Y { sprintf("%04d",$_[0]->[5] + 1900) }
  
  sub format_Z {
   my $o = tz_local_offset(timelocal(@{$_[0]}[0..5]));
   defined $tzname ? $tzname : uc tz_name($o, $_[0]->[8]);
  }
  
  sub format_z {
   my $t = timelocal(@{$_[0]}[0..5]);
   my $o = defined $tzname ? tz_offset($tzname, $t) : tz_offset(undef,$t);
   sprintf("%+03d%02d", int($o / 3600), int(abs($o) % 3600) / 60);
  }
  
  sub format_c { &format_x . " " . &format_X }
  sub format_D { &format_m . "/" . &format_d . "/" . &format_y  }      
  sub format_r { &format_I . ":" . &format_M . ":" . &format_S . " " . &format_p  }   
  sub format_R { &format_H . ":" . &format_M }
  sub format_T { &format_H . ":" . &format_M . ":" . &format_S }
  sub format_t { "\t" }
  sub format_n { "\n" }
  sub format_o { sprintf("%2d%s",$_[0]->[3],$Dsuf[$_[0]->[3]]) }
  sub format_x { my $f = $format{'x'}; _subs($_[0],$f); }
  sub format_X { my $f = $format{'X'}; _subs($_[0],$f); }
  sub format_C { my $f = $format{'C'}; _subs($_[0],$f); }
  
  sub format_Od { roman(format_d(@_)) }
  sub format_Oe { roman(format_e(@_)) }
  sub format_OH { roman(format_H(@_)) }
  sub format_OI { roman(format_I(@_)) }
  sub format_Oj { roman(format_j(@_)) }
  sub format_Ok { roman(format_k(@_)) }
  sub format_Ol { roman(format_l(@_)) }
  sub format_Om { roman(format_m(@_)) }
  sub format_OM { roman(format_M(@_)) }
  sub format_Oq { roman(format_q(@_)) }
  sub format_Oy { roman(format_y(@_)) }
  sub format_OY { roman(format_Y(@_)) }
  
  sub format_G { int(($_[0]->[9] - 315993600) / 604800) }
  
  1;
  __END__
  
  =head1 NAME
  
  Date::Format - Date formating subroutines
  
  =head1 SYNOPSIS
  
  	use Date::Format;
  	
  	@lt = localtime(time);
  	
  	print time2str($template, time);
  	print strftime($template, @lt);
  	
  	print time2str($template, time, $zone);
  	print strftime($template, @lt, $zone);
  	
  	print ctime(time);
  	print asctime(@lt);
  	
  	print ctime(time, $zone);
  	print asctime(@lt, $zone);
  
  =head1 DESCRIPTION
  
  This module provides routines to format dates into ASCII strings. They
  correspond to the C library routines C<strftime> and C<ctime>.
  
  =over 4
  
  =item time2str(TEMPLATE, TIME [, ZONE])
  
  C<time2str> converts C<TIME> into an ASCII string using the conversion
  specification given in C<TEMPLATE>. C<ZONE> if given specifies the zone
  which the output is required to be in, C<ZONE> defaults to your current zone.
  
  
  =item strftime(TEMPLATE, TIME [, ZONE])
  
  C<strftime> is similar to C<time2str> with the exception that the time is
  passed as an array, such as the array returned by C<localtime>.
  
  =item ctime(TIME [, ZONE])
  
  C<ctime> calls C<time2str> with the given arguments using the
  conversion specification C<"%a %b %e %T %Y\n">
  
  =item asctime(TIME [, ZONE])
  
  C<asctime> calls C<time2str> with the given arguments using the
  conversion specification C<"%a %b %e %T %Y\n">
  
  =back
  
  =head1 MULTI-LANGUAGE SUPPORT
  
  Date::Format is capable of formating into several languages by creating
  a language specific object and calling methods, see L<Date::Language>
  
  	my $lang = Date::Language->new('German');
  	$lang->time2str("%a %b %e %T %Y\n", time);
  
  I am open to suggestions on this.
  
  =head1 CONVERSION SPECIFICATION
  
  Each conversion specification  is  replaced  by  appropriate
  characters   as   described  in  the  following  list.   The
  appropriate  characters  are  determined  by   the   LC_TIME
  category of the program's locale.
  
  	%%	PERCENT
  	%a	day of the week abbr
  	%A	day of the week
  	%b	month abbr
  	%B 	month
  	%c	MM/DD/YY HH:MM:SS
  	%C 	ctime format: Sat Nov 19 21:05:57 1994
  	%d 	numeric day of the month, with leading zeros (eg 01..31)
  	%e 	like %d, but a leading zero is replaced by a space (eg  1..32)
  	%D 	MM/DD/YY
  	%G	GPS week number (weeks since January 6, 1980)
  	%h 	month abbr
  	%H 	hour, 24 hour clock, leading 0's)
  	%I 	hour, 12 hour clock, leading 0's)
  	%j 	day of the year
  	%k 	hour
  	%l 	hour, 12 hour clock
  	%L 	month number, starting with 1
  	%m 	month number, starting with 01
  	%M 	minute, leading 0's
  	%n 	NEWLINE
  	%o	ornate day of month -- "1st", "2nd", "25th", etc.
  	%p 	AM or PM 
  	%P 	am or pm (Yes %p and %P are backwards :)
  	%q	Quarter number, starting with 1
  	%r 	time format: 09:05:57 PM
  	%R 	time format: 21:05
  	%s	seconds since the Epoch, UCT
  	%S 	seconds, leading 0's
  	%t 	TAB
  	%T 	time format: 21:05:57
  	%U 	week number, Sunday as first day of week
  	%w 	day of the week, numerically, Sunday == 0
  	%W 	week number, Monday as first day of week
  	%x 	date format: 11/19/94
  	%X 	time format: 21:05:57
  	%y	year (2 digits)
  	%Y	year (4 digits)
  	%Z 	timezone in ascii. eg: PST
  	%z	timezone in format -/+0000
  
  C<%d>, C<%e>, C<%H>, C<%I>, C<%j>, C<%k>, C<%l>, C<%m>, C<%M>, C<%q>,
  C<%y> and C<%Y> can be output in Roman numerals by prefixing the letter
  with C<O>, e.g. C<%OY> will output the year as roman numerals.
  
  =head1 LIMITATION
  
  The functions in this module are limited to the time range that can be
  represented by the time_t data type, i.e. 1901-12-13 20:45:53 GMT to
  2038-01-19 03:14:07 GMT.
  
  =head1 AUTHOR
  
  Graham Barr <gbarr@pobox.com>
  
  =head1 COPYRIGHT
  
  Copyright (c) 1995-2009 Graham Barr. This program is free
  software; you can redistribute it and/or modify it under the same terms
  as Perl itself.
  
  =cut
  
  
DATE_FORMAT

$fatpacked{"Date/Language.pm"} = <<'DATE_LANGUAGE';
  
  package Date::Language;
  
  use     strict;
  use     Time::Local;
  use     Carp;
  use     vars qw($VERSION @ISA);
  require Date::Format;
  
  $VERSION = "1.10";
  @ISA     = qw(Date::Format::Generic);
  
  sub new
  {
   my $self = shift;
   my $type = shift || $self;
  
   $type =~ s/^(\w+)$/Date::Language::$1/;
  
   croak "Bad language"
  	unless $type =~ /^[\w:]+$/;
  
   eval "require $type"
  	or croak $@;
  
   bless [], $type;
  }
  
  # Stop AUTOLOAD being called ;-)
  sub DESTROY {}
  
  sub AUTOLOAD
  {
   use vars qw($AUTOLOAD);
  
   if($AUTOLOAD =~ /::strptime\Z/o)
    {
     my $self = $_[0];
     my $type = ref($self) || $self;
     require Date::Parse;
  
     no strict 'refs';
     *{"${type}::strptime"} = Date::Parse::gen_parser(
  	\%{"${type}::DoW"},
  	\%{"${type}::MoY"},
  	\@{"${type}::Dsuf"},
  	1);
  
     goto &{"${type}::strptime"};
    }
  
   croak "Undefined method &$AUTOLOAD called";
  }
  
  sub str2time
  {
   my $me = shift;
   my @t = $me->strptime(@_);
  
   return undef
  	unless @t;
  
   my($ss,$mm,$hh,$day,$month,$year,$zone) = @t;
   my @lt  = localtime(time);
  
   $hh    ||= 0;
   $mm    ||= 0;
   $ss    ||= 0;
  
   $month = $lt[4]
  	unless(defined $month);
  
   $day  = $lt[3]
  	unless(defined $day);
  
   $year = ($month > $lt[4]) ? ($lt[5] - 1) : $lt[5]
  	unless(defined $year);
  
   return defined $zone ? timegm($ss,$mm,$hh,$day,$month,$year) - $zone
      	    	      : timelocal($ss,$mm,$hh,$day,$month,$year);
  }
  
  1;
  
  __END__
  
  
  =head1 NAME
  
  Date::Language - Language specific date formating and parsing
  
  =head1 SYNOPSIS
  
    use Date::Language;
  
    my $lang = Date::Language->new('German');
    $lang->time2str("%a %b %e %T %Y\n", time);
  
  =head1 DESCRIPTION
  
  L<Date::Language> provides objects to parse and format dates for specific languages. Available languages are
  
    Afar                    French                  Russian_cp1251
    Amharic                 Gedeo                   Russian_koi8r
    Austrian                German                  Sidama
    Brazilian               Greek                   Somali
    Chinese                 Hungarian               Spanish
    Chinese_GB              Icelandic               Swedish
    Czech                   Italian                 Tigrinya
    Danish                  Norwegian               TigrinyaEritrean
    Dutch                   Oromo                   TigrinyaEthiopian
    English                 Romanian                Turkish
    Finnish                 Russian
  
  =head1 METHODS
  
  =over
  
  =item time2str
  
  See L<Date::Format/time2str>
  
  =item strftime
  
  See L<Date::Format/strftime>
  
  =item ctime
  
  See L<Date::Format/ctime>
  
  =item asctime
  
  See L<Date::Format/asctime>
  
  =item str2time
  
  See L<Date::Parse/str2time>
  
  =item strptime
  
  See L<Date::Parse/strptime>
  
  =back
  
DATE_LANGUAGE

$fatpacked{"Date/Language/Afar.pm"} = <<'DATE_LANGUAGE_AFAR';
  ##
  ## Afar tables
  ##
  
  package Date::Language::Afar;
  
  use Date::Language ();
  use vars qw(@ISA @DoW @DoWs @MoY @MoYs @AMPM @Dsuf %MoY %DoW $VERSION);
  @ISA = qw(Date::Language);
  $VERSION = "0.99";
  
  @DoW = qw(Acaada Etleeni Talaata Arbaqa Kamiisi Gumqata Sabti);
  @MoY = (
  "Qunxa Garablu",
  "Kudo",
  "Ciggilta Kudo",
  "Agda Baxis",
  "Caxah Alsa",
  "Qasa Dirri",
  "Qado Dirri",
  "Liiqen",
  "Waysu",
  "Diteli",
  "Ximoli",
  "Kaxxa Garablu"
  );
  @DoWs = map { substr($_,0,3) } @DoW;
  @MoYs = map { substr($_,0,3) } @MoY;
  @AMPM = qw(saaku carra);
  
  @Dsuf = (qw(th st nd rd th th th th th th)) x 3;
  @Dsuf[11,12,13] = qw(th th th);
  @Dsuf[30,31] = qw(th st);
  
  @MoY{@MoY}  = (0 .. scalar(@MoY));
  @MoY{@MoYs} = (0 .. scalar(@MoYs));
  @DoW{@DoW}  = (0 .. scalar(@DoW));
  @DoW{@DoWs} = (0 .. scalar(@DoWs));
  
  # Formatting routines
  
  sub format_a { $DoWs[$_[0]->[6]] }
  sub format_A { $DoW[$_[0]->[6]] }
  sub format_b { $MoYs[$_[0]->[4]] }
  sub format_B { $MoY[$_[0]->[4]] }
  sub format_h { $MoYs[$_[0]->[4]] }
  sub format_p { $_[0]->[2] >= 12 ?  $AMPM[1] : $AMPM[0] }
  
  1;
DATE_LANGUAGE_AFAR

$fatpacked{"Date/Language/Amharic.pm"} = <<'DATE_LANGUAGE_AMHARIC';
  ##
  ## Amharic tables
  ##
  
  package Date::Language::Amharic;
  
  use Date::Language ();
  use vars qw(@ISA @DoW @DoWs @MoY @MoYs @AMPM @Dsuf %MoY %DoW $VERSION);
  @ISA = qw(Date::Language);
  $VERSION = "1.00";
  
  if ( $] >= 5.006 ) {
  @DoW = (
  "\x{12a5}\x{1211}\x{12f5}",
  "\x{1230}\x{129e}",
  "\x{121b}\x{12ad}\x{1230}\x{129e}",
  "\x{1228}\x{1261}\x{12d5}",
  "\x{1210}\x{1219}\x{1235}",
  "\x{12d3}\x{122d}\x{1265}",
  "\x{1245}\x{12f3}\x{121c}"
  );
  @MoY = (
  "\x{1303}\x{1295}\x{12e9}\x{12c8}\x{122a}",
  "\x{134c}\x{1265}\x{1229}\x{12c8}\x{122a}",
  "\x{121b}\x{122d}\x{127d}",
  "\x{12a4}\x{1355}\x{1228}\x{120d}",
  "\x{121c}\x{12ed}",
  "\x{1301}\x{1295}",
  "\x{1301}\x{120b}\x{12ed}",
  "\x{12a6}\x{1308}\x{1235}\x{1275}",
  "\x{1234}\x{1355}\x{1274}\x{121d}\x{1260}\x{122d}",
  "\x{12a6}\x{12ad}\x{1270}\x{12cd}\x{1260}\x{122d}",
  "\x{1296}\x{126c}\x{121d}\x{1260}\x{122d}",
  "\x{12f2}\x{1234}\x{121d}\x{1260}\x{122d}"
  );
  @DoWs = map { substr($_,0,3) } @DoW;
  @MoYs = map { substr($_,0,3) } @MoY;
  @AMPM = ( "\x{1320}\x{12cb}\x{1275}", "\x{12a8}\x{1230}\x{12d3}\x{1275}" );
  
  @Dsuf = ("\x{129b}" x 31);
  }
  else {
  @DoW = (
  "áŠ¥áˆ‘á‹µ",
  "áˆ°áŠž",
  "áˆ›áŠ­áˆ°áŠž",
  "áˆ¨á‰¡á‹•",
  "áˆáˆ™áˆµ",
  "á‹“áˆ­á‰¥",
  "á‰…á‹³áˆœ"
  );
  @MoY = (
  "áŒƒáŠ•á‹©á‹ˆáˆª",
  "áŒá‰¥áˆ©á‹ˆáˆª",
  "áˆ›áˆ­á‰½",
  "áŠ¤á•áˆ¨áˆ",
  "áˆœá‹­",
  "áŒáŠ•",
  "áŒáˆ‹á‹­",
  "áŠ¦áŒˆáˆµá‰µ",
  "áˆ´á•á‰´áˆá‰ áˆ­",
  "áŠ¦áŠ­á‰°á‹á‰ áˆ­",
  "áŠ–á‰¬áˆá‰ áˆ­",
  "á‹²áˆ´áˆá‰ áˆ­"
  );
  @DoWs = map { substr($_,0,9) } @DoW;
  @MoYs = map { substr($_,0,9) } @MoY;
  @AMPM = ( "áŒ á‹‹á‰µ", "áŠ¨áˆ°á‹“á‰µ" );
  
  @Dsuf = ("áŠ›" x 31);
  }
  
  @MoY{@MoY}  = (0 .. scalar(@MoY));
  @MoY{@MoYs} = (0 .. scalar(@MoYs));
  @DoW{@DoW}  = (0 .. scalar(@DoW));
  @DoW{@DoWs} = (0 .. scalar(@DoWs));
  
  # Formatting routines
  
  sub format_a { $DoWs[$_[0]->[6]] }
  sub format_A { $DoW[$_[0]->[6]] }
  sub format_b { $MoYs[$_[0]->[4]] }
  sub format_B { $MoY[$_[0]->[4]] }
  sub format_h { $MoYs[$_[0]->[4]] }
  sub format_p { $_[0]->[2] >= 12 ?  $AMPM[1] : $AMPM[0] }
  
  1;
DATE_LANGUAGE_AMHARIC

$fatpacked{"Date/Language/Austrian.pm"} = <<'DATE_LANGUAGE_AUSTRIAN';
  ##
  ## Austrian tables
  ##
  
  package Date::Language::Austrian;
  
  use Date::Language ();
  use vars qw(@ISA @DoW @DoWs @MoY @MoYs @AMPM @Dsuf %MoY %DoW $VERSION);
  @ISA = qw(Date::Language);
  $VERSION = "1.01";
  
  @MoY  = qw(Jänner Feber März April Mai Juni
  	   Juli August September Oktober November Dezember);
  @MoYs = qw(Jän Feb Mär Apr Mai Jun Jul Aug Sep Oct Nov Dez);
  @DoW  = qw(Sonntag Montag Dienstag Mittwoch Donnerstag Freitag Samstag);
  @DoWs = qw(Son Mon Die Mit Don Fre Sam);
  
  use Date::Language::English ();
  @AMPM = @{Date::Language::English::AMPM};
  @Dsuf = @{Date::Language::English::Dsuf};
  
  @MoY{@MoY}  = (0 .. scalar(@MoY));
  @MoY{@MoYs} = (0 .. scalar(@MoYs));
  @DoW{@DoW}  = (0 .. scalar(@DoW));
  @DoW{@DoWs} = (0 .. scalar(@DoWs));
  
  # Formatting routines
  
  sub format_a { $DoWs[$_[0]->[6]] }
  sub format_A { $DoW[$_[0]->[6]] }
  sub format_b { $MoYs[$_[0]->[4]] }
  sub format_B { $MoY[$_[0]->[4]] }
  sub format_h { $MoYs[$_[0]->[4]] }
  sub format_p { $_[0]->[2] >= 12 ?  $AMPM[1] : $AMPM[0] }
  
  1;
DATE_LANGUAGE_AUSTRIAN

$fatpacked{"Date/Language/Brazilian.pm"} = <<'DATE_LANGUAGE_BRAZILIAN';
  ##
  ## Brazilian tables, contributed by Christian Tosta (tosta@cce.ufmg.br)
  ##
  
  package Date::Language::Brazilian;
  
  use Date::Language ();
  use vars qw(@ISA @DoW @DoWs @MoY @MoYs @AMPM @Dsuf %MoY %DoW $VERSION);
  @ISA = qw(Date::Language);
  $VERSION = "1.01";
  
  @DoW = qw(Domingo Segunda Terça Quarta Quinta Sexta Sábado);
  @MoY = qw(Janeiro Fevereiro Março Abril Maio Junho
  	  Julho Agosto Setembro Outubro Novembro Dezembro);
  @DoWs = map { substr($_,0,3) } @DoW;
  @MoYs = map { substr($_,0,3) } @MoY;
  @AMPM = qw(AM PM);
  
  @Dsuf = (qw(mo ro do ro to to to mo vo no)) x 3;
  
  @MoY{@MoY}  = (0 .. scalar(@MoY));
  @MoY{@MoYs} = (0 .. scalar(@MoYs));
  @DoW{@DoW}  = (0 .. scalar(@DoW));
  @DoW{@DoWs} = (0 .. scalar(@DoWs));
  
  # Formatting routines
  
  sub format_a { $DoWs[$_[0]->[6]] }
  sub format_A { $DoW[$_[0]->[6]] }
  sub format_b { $MoYs[$_[0]->[4]] }
  sub format_B { $MoY[$_[0]->[4]] }
  sub format_h { $MoYs[$_[0]->[4]] }
  sub format_p { $_[0]->[2] >= 12 ?  $AMPM[1] : $AMPM[0] }
  
  1;
DATE_LANGUAGE_BRAZILIAN

$fatpacked{"Date/Language/Chinese.pm"} = <<'DATE_LANGUAGE_CHINESE';
  ##
  ## English tables
  ##
  
  package Date::Language::Chinese;
  
  use Date::Language ();
  use vars qw(@ISA @DoW @DoWs @MoY @MoYs @AMPM @Dsuf %MoY %DoW $VERSION);
  @ISA = qw(Date::Language);
  $VERSION = "1.00";
  
  @DoW = qw(æ˜ŸæœŸæ—¥ æ˜ŸæœŸä¸€ æ˜ŸæœŸäºŒ æ˜ŸæœŸä¸‰ æ˜ŸæœŸå›› æ˜ŸæœŸäº” æ˜ŸæœŸå…­);
  @MoY = qw(ä¸€æœˆ äºŒæœˆ ä¸‰æœˆ å››æœˆ äº”æœˆ å…­æœˆ
  	  ä¸ƒæœˆ å…«æœˆ ä¹æœˆ åæœˆ åä¸€æœˆ åäºŒæœˆ);
  @DoWs = map { $_ } @DoW;
  @MoYs = map { $_ } @MoY;
  @AMPM = qw(ä¸Šåˆ ä¸‹åˆ);
  
  @Dsuf = (qw(æ—¥ æ—¥ æ—¥ æ—¥ æ—¥ æ—¥ æ—¥ æ—¥ æ—¥ æ—¥)) x 3;
  
  @MoY{@MoY}  = (0 .. scalar(@MoY));
  @MoY{@MoYs} = (0 .. scalar(@MoYs));
  @DoW{@DoW}  = (0 .. scalar(@DoW));
  @DoW{@DoWs} = (0 .. scalar(@DoWs));
  
  # Formatting routines
  
  sub format_a { $DoWs[$_[0]->[6]] }
  sub format_A { $DoW[$_[0]->[6]] }
  sub format_b { $MoYs[$_[0]->[4]] }
  sub format_B { $MoY[$_[0]->[4]] }
  sub format_h { $MoYs[$_[0]->[4]] }
  sub format_p { $_[0]->[2] >= 12 ?  $AMPM[1] : $AMPM[0] }
  
  sub format_o { sprintf("%2d%s",$_[0]->[3],"æ—¥") }
  1;
DATE_LANGUAGE_CHINESE

$fatpacked{"Date/Language/Chinese_GB.pm"} = <<'DATE_LANGUAGE_CHINESE_GB';
  ##
  ## English tables
  ##
  
  package Date::Language::Chinese_GB;
  
  use Date::Language ();
  use vars qw(@ISA @DoW @DoWs @MoY @MoYs @AMPM @Dsuf %MoY %DoW $VERSION);
  @ISA = qw(Date::Language);
  $VERSION = "1.01";
  
  @DoW = qw(ÐÇÆÚÈÕ ÐÇÆÚÒ» ÐÇÆÚ¶þ ÐÇÆÚÈý ÐÇÆÚËÄ ÐÇÆÚÎå ÐÇÆÚÁù);
  @MoY = qw(Ò»ÔÂ ¶þÔÂ ÈýÔÂ ËÄÔÂ ÎåÔÂ ÁùÔÂ
  	  ÆßÔÂ °ËÔÂ ¾ÅÔÂ Ê®ÔÂ Ê®Ò»ÔÂ Ê®¶þÔÂ);
  @DoWs = map { $_ } @DoW;
  @MoYs = map { $_ } @MoY;
  @AMPM = qw(ÉÏÎç ÏÂÎç);
  
  @Dsuf = (qw(ÈÕ ÈÕ ÈÕ ÈÕ ÈÕ ÈÕ ÈÕ ÈÕ ÈÕ ÈÕ)) x 3;
  
  @MoY{@MoY}  = (0 .. scalar(@MoY));
  @MoY{@MoYs} = (0 .. scalar(@MoYs));
  @DoW{@DoW}  = (0 .. scalar(@DoW));
  @DoW{@DoWs} = (0 .. scalar(@DoWs));
  
  # Formatting routines
  
  sub format_a { $DoWs[$_[0]->[6]] }
  sub format_A { $DoW[$_[0]->[6]] }
  sub format_b { $MoYs[$_[0]->[4]] }
  sub format_B { $MoY[$_[0]->[4]] }
  sub format_h { $MoYs[$_[0]->[4]] }
  sub format_p { $_[0]->[2] >= 12 ?  $AMPM[1] : $AMPM[0] }
  
  sub format_o { sprintf("%2d%s",$_[0]->[3],"ÈÕ") }
  1;
DATE_LANGUAGE_CHINESE_GB

$fatpacked{"Date/Language/Czech.pm"} = <<'DATE_LANGUAGE_CZECH';
  ##
  ## Czech tables
  ##
  ## Contributed by Honza Pazdziora 
  
  package Date::Language::Czech;
  
  use vars qw(@ISA @DoW @DoWs @MoY @MoYs @MoY2 @AMPM %MoY %DoW $VERSION);
  @ISA = qw(Date::Language Date::Format::Generic);
  $VERSION = "1.01";
  
  @MoY = qw(leden únor bøezen duben kvìten èerven èervenec srpen záøí
  	      øíjen listopad prosinec);
  @MoYs = qw(led únor bøe dub kvì èvn èec srp záøí øíj lis pro);
  @MoY2 = @MoY;
  for (@MoY2)
        { s!en$!na! or s!ec$!ce! or s!ad$!adu! or s!or$!ora!; }
  
  @DoW = qw(nedìle pondìlí úterý støeda ètvrtek pátek sobota);
  @DoWs = qw(Ne Po Út St Èt Pá So);
  
  @AMPM = qw(dop. odp.);
  
  @MoY{@MoY}  = (0 .. scalar(@MoY));
  @MoY{@MoYs} = (0 .. scalar(@MoYs));
  @DoW{@DoW}  = (0 .. scalar(@DoW));
  @DoW{@DoWs} = (0 .. scalar(@DoWs));
  
  # Formatting routines
  
  sub format_a { $DoWs[$_[0]->[6]] }
  sub format_A { $DoW[$_[0]->[6]] }
  sub format_b { $MoYs[$_[0]->[4]] }
  sub format_B { $MoY[$_[0]->[4]] }
  sub format_h { $MoYs[$_[0]->[4]] }
  sub format_p { $_[0]->[2] >= 12 ?  $AMPM[1] : $AMPM[0] }
  
  sub format_d { $_[0]->[3] }
  sub format_m { $_[0]->[4] + 1 }
  sub format_o { $_[0]->[3] . '.' }
  
  sub format_Q { $MoY2[$_[0]->[4]] }
  
  sub time2str {
        my $ref = shift;
        my @a = @_;
        $a[0] =~ s/(%[do]\.?\s?)%B/$1%Q/;
        $ref->SUPER::time2str(@a);
        }
  
  sub strftime {
        my $ref = shift;
        my @a = @_;
        $a[0] =~ s/(%[do]\.?\s?)%B/$1%Q/;
        $ref->SUPER::time2str(@a);
        }
  
  1;
DATE_LANGUAGE_CZECH

$fatpacked{"Date/Language/Danish.pm"} = <<'DATE_LANGUAGE_DANISH';
  ##
  ## Danish tables
  ##
  
  package Date::Language::Danish;
  
  use Date::Language ();
  use vars qw(@ISA @DoW @DoWs @MoY @MoYs @AMPM @Dsuf %MoY %DoW $VERSION);
  @ISA = qw(Date::Language);
  $VERSION = "1.01";
  
  @MoY  = qw(Januar Februar Marts April Maj Juni
  	   Juli August September Oktober November December);
  @MoYs = qw(Jan Feb Mar Apr Maj Jun Jul Aug Sep Okt Nov Dec);
  @DoW  = qw(Søndag Mandag Tirsdag Onsdag Torsdag Fredag Lørdag Søndag);
  @DoWs = qw(Søn Man Tir Ons Tor Fre Lør Søn);
  
  use Date::Language::English ();
  @AMPM =   @{Date::Language::English::AMPM};
  @Dsuf =   @{Date::Language::English::Dsuf};
  
  @MoY{@MoY}  = (0 .. scalar(@MoY));
  @MoY{@MoYs} = (0 .. scalar(@MoYs));
  @DoW{@DoW}  = (0 .. scalar(@DoW));
  @DoW{@DoWs} = (0 .. scalar(@DoWs));
  
  # Formatting routines
  
  sub format_a { $DoWs[$_[0]->[6]] }
  sub format_A { $DoW[$_[0]->[6]] }
  sub format_b { $MoYs[$_[0]->[4]] }
  sub format_B { $MoY[$_[0]->[4]] }
  sub format_h { $MoYs[$_[0]->[4]] }
  sub format_p { $_[0]->[2] >= 12 ?  $AMPM[1] : $AMPM[0] }
  
  1;
DATE_LANGUAGE_DANISH

$fatpacked{"Date/Language/Dutch.pm"} = <<'DATE_LANGUAGE_DUTCH';
  ##
  ## Dutch tables
  ## Contributed by Johannes la Poutre <jlpoutre@corp.nl.home.com>
  ##
  
  package Date::Language::Dutch;
  
  use Date::Language ();
  use vars qw(@ISA @DoW @DoWs @MoY @MoYs @AMPM @Dsuf %MoY %DoW $VERSION);
  @ISA = qw(Date::Language);
  $VERSION = "1.02";
  
  @MoY  = qw(januari februari maart april mei juni juli
             augustus september oktober november december);
  @MoYs = map(substr($_, 0, 3), @MoY);
  $MoYs[2] = 'mrt'; # mrt is more common (Frank Maas)
  @DoW  = map($_ . "dag", qw(zon maan dins woens donder vrij zater));
  @DoWs = map(substr($_, 0, 2), @DoW);
  
  # these aren't normally used...
  @AMPM = qw(VM NM);
  @Dsuf = ('e') x 31;
  
  
  @MoY{@MoY}  = (0 .. scalar(@MoY));
  @MoY{@MoYs} = (0 .. scalar(@MoYs));
  @DoW{@DoW}  = (0 .. scalar(@DoW));
  @DoW{@DoWs} = (0 .. scalar(@DoWs));
  
  # Formatting routines
  
  sub format_a { $DoWs[$_[0]->[6]] }
  sub format_A { $DoW[$_[0]->[6]] }
  sub format_b { $MoYs[$_[0]->[4]] }
  sub format_B { $MoY[$_[0]->[4]] }
  sub format_h { $MoYs[$_[0]->[4]] }
  sub format_p { $_[0]->[2] >= 12 ?  $AMPM[1] : $AMPM[0] }
  sub format_o { sprintf("%2de",$_[0]->[3]) }
  
  1;
DATE_LANGUAGE_DUTCH

$fatpacked{"Date/Language/English.pm"} = <<'DATE_LANGUAGE_ENGLISH';
  ##
  ## English tables
  ##
  
  package Date::Language::English;
  
  use Date::Language ();
  use vars qw(@ISA @DoW @DoWs @MoY @MoYs @AMPM @Dsuf %MoY %DoW $VERSION);
  @ISA = qw(Date::Language);
  $VERSION = "1.01";
  
  @DoW = qw(Sunday Monday Tuesday Wednesday Thursday Friday Saturday);
  @MoY = qw(January February March April May June
  	  July August September October November December);
  @DoWs = map { substr($_,0,3) } @DoW;
  @MoYs = map { substr($_,0,3) } @MoY;
  @AMPM = qw(AM PM);
  
  @Dsuf = (qw(th st nd rd th th th th th th)) x 3;
  @Dsuf[11,12,13] = qw(th th th);
  @Dsuf[30,31] = qw(th st);
  
  @MoY{@MoY}  = (0 .. scalar(@MoY));
  @MoY{@MoYs} = (0 .. scalar(@MoYs));
  @DoW{@DoW}  = (0 .. scalar(@DoW));
  @DoW{@DoWs} = (0 .. scalar(@DoWs));
  
  # Formatting routines
  
  sub format_a { $DoWs[$_[0]->[6]] }
  sub format_A { $DoW[$_[0]->[6]] }
  sub format_b { $MoYs[$_[0]->[4]] }
  sub format_B { $MoY[$_[0]->[4]] }
  sub format_h { $MoYs[$_[0]->[4]] }
  sub format_p { $_[0]->[2] >= 12 ?  $AMPM[1] : $AMPM[0] }
  
  1;
DATE_LANGUAGE_ENGLISH

$fatpacked{"Date/Language/Finnish.pm"} = <<'DATE_LANGUAGE_FINNISH';
  ##
  ## Finnish tables
  ## Contributed by Matthew Musgrove <muskrat@mindless.com>
  ## Corrected by roke
  ##
  
  package Date::Language::Finnish;
  
  use Date::Language ();
  use vars qw(@ISA @DoW @DoWs @MoY @MoYs @AMPM @Dsuf %MoY %DoW $VERSION);
  @ISA = qw(Date::Language);
  $VERSION = "1.01";
  
  # In Finnish, the names of the months and days are only capitalized at the beginning of sentences.
  @MoY  = map($_ . "kuu", qw(tammi helmi maalis huhti touko kesä heinä elo syys loka marras joulu));
  @DoW  = qw(sunnuntai maanantai tiistai keskiviikko torstai perjantai lauantai);
  
  # it is not customary to use abbreviated names of months or days
  # per Graham's suggestion:
  @MoYs = @MoY;
  @DoWs = @DoW;
  
  # the short form of ordinals
  @Dsuf = ('.') x 31;
  
  # doesn't look like this is normally used...
  @AMPM = qw(ap ip);
  
  
  @MoY{@MoY}  = (0 .. scalar(@MoY));
  @MoY{@MoYs} = (0 .. scalar(@MoYs));
  @DoW{@DoW}  = (0 .. scalar(@DoW));
  @DoW{@DoWs} = (0 .. scalar(@DoWs));
  
  # Formatting routines
  
  sub format_a { $DoWs[$_[0]->[6]] }
  sub format_A { $DoW[$_[0]->[6]] }
  sub format_b { $MoYs[$_[0]->[4]] }
  sub format_B { $MoY[$_[0]->[4]] }
  sub format_h { $MoYs[$_[0]->[4]] }
  sub format_p { $_[0]->[2] >= 12 ?  $AMPM[1] : $AMPM[0] }
  sub format_o { sprintf("%2de",$_[0]->[3]) }
  
  1;
DATE_LANGUAGE_FINNISH

$fatpacked{"Date/Language/French.pm"} = <<'DATE_LANGUAGE_FRENCH';
  ##
  ## French tables, contributed by Emmanuel Bataille (bem@residents.frmug.org)
  ##
  
  package Date::Language::French;
  
  use Date::Language ();
  use vars qw(@ISA @DoW @DoWs @MoY @MoYs @AMPM @Dsuf %MoY %DoW $VERSION);
  @ISA = qw(Date::Language);
  $VERSION = "1.04";
  
  @DoW = qw(dimanche lundi mardi mercredi jeudi vendredi samedi);
  @MoY = qw(janvier février mars avril mai juin 
            juillet août septembre octobre novembre décembre);
  @DoWs = map { substr($_,0,3) } @DoW;
  @MoYs = map { substr($_,0,3) } @MoY;
  $MoYs[6] = 'jul';
  @AMPM = qw(AM PM);
  
  @Dsuf = ((qw(er e e e e e e e e e)) x 3, 'er');
  
  @MoY{@MoY}  = (0 .. scalar(@MoY));
  @MoY{@MoYs} = (0 .. scalar(@MoYs));
  @DoW{@DoW}  = (0 .. scalar(@DoW));
  @DoW{@DoWs} = (0 .. scalar(@DoWs));
  
  # Formatting routines
  
  sub format_a { $DoWs[$_[0]->[6]] }
  sub format_A { $DoW[$_[0]->[6]] }
  sub format_b { $MoYs[$_[0]->[4]] }
  sub format_B { $MoY[$_[0]->[4]] }
  sub format_h { $MoYs[$_[0]->[4]] }
  sub format_p { $_[0]->[2] >= 12 ?  $AMPM[1] : $AMPM[0] }
  
  1;
DATE_LANGUAGE_FRENCH

$fatpacked{"Date/Language/Gedeo.pm"} = <<'DATE_LANGUAGE_GEDEO';
  ##
  ## Gedeo tables
  ##
  
  package Date::Language::Gedeo;
  
  use Date::Language ();
  use vars qw(@ISA @DoW @DoWs @MoY @MoYs @AMPM @Dsuf %MoY %DoW $VERSION);
  @ISA = qw(Date::Language);
  $VERSION = "0.99";
  
  @DoW = qw( Sanbbattaa Sanno Masano Roobe Hamusse Arbe Qiddamme);
  @MoY = (
  "Oritto",
  "Birre'a",
  "Onkkollessa",
  "Saddasa",
  "Arrasa",
  "Qammo",
  "Ella",
  "Waacibajje",
  "Canissa",
  "Addolessa",
  "Bittitotessa",
  "Hegeya"
  );
  @DoWs = map { substr($_,0,3) } @DoW;
  $DoWs[0] = "Snb";
  $DoWs[1] = "Sno";
  @MoYs = map { substr($_,0,3) } @MoY;
  @AMPM = qw(gorsa warreti-udumma);
  
  @Dsuf = (qw(th st nd rd th th th th th th)) x 3;
  @Dsuf[11,12,13] = qw(th th th);
  @Dsuf[30,31] = qw(th st);
  
  @MoY{@MoY}  = (0 .. scalar(@MoY));
  @MoY{@MoYs} = (0 .. scalar(@MoYs));
  @DoW{@DoW}  = (0 .. scalar(@DoW));
  @DoW{@DoWs} = (0 .. scalar(@DoWs));
  
  # Formatting routines
  
  sub format_a { $DoWs[$_[0]->[6]] }
  sub format_A { $DoW[$_[0]->[6]] }
  sub format_b { $MoYs[$_[0]->[4]] }
  sub format_B { $MoY[$_[0]->[4]] }
  sub format_h { $MoYs[$_[0]->[4]] }
  sub format_p { $_[0]->[2] >= 12 ?  $AMPM[1] : $AMPM[0] }
  
  1;
DATE_LANGUAGE_GEDEO

$fatpacked{"Date/Language/German.pm"} = <<'DATE_LANGUAGE_GERMAN';
  ##
  ## German tables
  ##
  
  package Date::Language::German;
  
  use Date::Language ();
  use vars qw(@ISA @DoW @DoWs @MoY @MoYs @AMPM @Dsuf %MoY %DoW $VERSION);
  @ISA = qw(Date::Language);
  $VERSION = "1.02";
  
  @MoY  = qw(Januar Februar März April Mai Juni
  	   Juli August September Oktober November Dezember);
  @MoYs = qw(Jan Feb Mär Apr Mai Jun Jul Aug Sep Okt Nov Dez);
  @DoW  = qw(Sonntag Montag Dienstag Mittwoch Donnerstag Freitag Samstag);
  @DoWs = qw(Son Mon Die Mit Don Fre Sam);
  
  use Date::Language::English ();
  @AMPM =   @{Date::Language::English::AMPM};
  @Dsuf =   @{Date::Language::English::Dsuf};
  
  @MoY{@MoY}  = (0 .. scalar(@MoY));
  @MoY{@MoYs} = (0 .. scalar(@MoYs));
  @DoW{@DoW}  = (0 .. scalar(@DoW));
  @DoW{@DoWs} = (0 .. scalar(@DoWs));
  
  # Formatting routines
  
  sub format_a { $DoWs[$_[0]->[6]] }
  sub format_A { $DoW[$_[0]->[6]] }
  sub format_b { $MoYs[$_[0]->[4]] }
  sub format_B { $MoY[$_[0]->[4]] }
  sub format_h { $MoYs[$_[0]->[4]] }
  sub format_p { $_[0]->[2] >= 12 ?  $AMPM[1] : $AMPM[0] }
  sub format_o { sprintf("%2d.",$_[0]->[3]) }
  
  1;
DATE_LANGUAGE_GERMAN

$fatpacked{"Date/Language/Greek.pm"} = <<'DATE_LANGUAGE_GREEK';
  ##
  ## Greek tables
  ##
  ## Traditional date format is: DoW DD{eta} MoY Year (%A %o %B %Y)
  ##
  ## Matthew Musgrove <muskrat@mindless.com>
  ## Translations gratiously provided by Menelaos Stamatelos <men@kwsn.net>
  ## This module returns unicode (utf8) encoded characters.  You will need to
  ## take the necessary steps for this to display correctly.
  ##
  
  package Date::Language::Greek;
  
  use utf8;
  use Date::Language ();
  use vars qw(@ISA @DoW @DoWs @MoY @MoYs @AMPM @Dsuf %MoY %DoW $VERSION);
  @ISA = qw(Date::Language);
  $VERSION = "1.00";
  
  @DoW = (
  "\x{039a}\x{03c5}\x{03c1}\x{03b9}\x{03b1}\x{03ba}\x{03ae}",
  "\x{0394}\x{03b5}\x{03c5}\x{03c4}\x{03ad}\x{03c1}\x{03b1}",
  "\x{03a4}\x{03c1}\x{03af}\x{03c4}\x{03b7}",
  "\x{03a4}\x{03b5}\x{03c4}\x{03ac}\x{03c1}\x{03c4}\x{03b7}",
  "\x{03a0}\x{03ad}\x{03bc}\x{03c0}\x{03c4}\x{03b7}",
  "\x{03a0}\x{03b1}\x{03c1}\x{03b1}\x{03c3}\x{03ba}\x{03b5}\x{03c5}\x{03ae}",
  "\x{03a3}\x{03ac}\x{03b2}\x{03b2}\x{03b1}\x{03c4}\x{03bf}",
  );
  
  @MoY = (
  "\x{0399}\x{03b1}\x{03bd}\x{03bf}\x{03c5}\x{03b1}\x{03c1}\x{03af}\x{03bf}\x{03c5}",
  "\x{03a6}\x{03b5}\x{03b2}\x{03c1}\x{03bf}\x{03c5}\x{03b1}\x{03c1}\x{03af}\x{03bf}\x{03c5}",
  "\x{039c}\x{03b1}\x{03c1}\x{03c4}\x{03af}\x{03bf}\x{03c5}",
  "\x{0391}\x{03c0}\x{03c1}\x{03b9}\x{03bb}\x{03af}\x{03c5}",
  "\x{039c}\x{03b1}\x{0390}\x{03bf}\x{03c5}",
  "\x{0399}\x{03bf}\x{03c5}\x{03bd}\x{03af}\x{03bf}\x{03c5}",
  "\x{0399}\x{03bf}\x{03c5}\x{03bb}\x{03af}\x{03bf}\x{03c5}",
  "\x{0391}\x{03c5}\x{03b3}\x{03bf}\x{03cd}\x{03c3}\x{03c4}\x{03bf}\x{03c5}",
  "\x{03a3}\x{03b5}\x{03c0}\x{03c4}\x{03b5}\x{03bc}\x{03c4}\x{03bf}\x{03c5}",
  "\x{039f}\x{03ba}\x{03c4}\x{03c9}\x{03b2}\x{03c1}\x{03af}\x{03bf}\x{03c5}",
  "\x{039d}\x{03bf}\x{03b5}\x{03bc}\x{03b2}\x{03c1}\x{03af}\x{03bf}\x{03c5}",
  "\x{0394}\x{03b5}\x{03ba}\x{03b5}\x{03bc}\x{03b2}\x{03c1}\x{03bf}\x{03c5}",
  );
  
  @DoWs = (
  "\x{039a}\x{03c5}",
  "\x{0394}\x{03b5}",
  "\x{03a4}\x{03c1}",
  "\x{03a4}\x{03b5}",
  "\x{03a0}\x{03b5}",
  "\x{03a0}\x{03b1}",
  "\x{03a3}\x{03b1}",
  );
  @MoYs = (
  "\x{0399}\x{03b1}\x{03bd}",
  "\x{03a6}\x{03b5}",
  "\x{039c}\x{03b1}\x{03c1}",
  "\x{0391}\x{03c0}\x{03c1}",
  "\x{039c}\x{03b1}",
  "\x{0399}\x{03bf}\x{03c5}\x{03bd}",
  "\x{0399}\x{03bf}\x{03c5}\x{03bb}",
  "\x{0391}\x{03c5}\x{03b3}",
  "\x{03a3}\x{03b5}\x{03c0}",
  "\x{039f}\x{03ba}",
  "\x{039d}\x{03bf}",
  "\x{0394}\x{03b5}",
  );
  
  @AMPM = ("\x{03c0}\x{03bc}", "\x{03bc}\x{03bc}");
  
  @Dsuf = ("\x{03b7}" x 31);
  
  @MoY{@MoY}  = (0 .. scalar(@MoY));
  @MoY{@MoYs} = (0 .. scalar(@MoYs));
  @DoW{@DoW}  = (0 .. scalar(@DoW));
  @DoW{@DoWs} = (0 .. scalar(@DoWs));
  
  # Formatting routines
  
  sub format_a { $DoWs[$_[0]->[6]] }
  sub format_A { $DoW[$_[0]->[6]] }
  sub format_b { $MoYs[$_[0]->[4]] }
  sub format_B { $MoY[$_[0]->[4]] }
  sub format_h { $MoYs[$_[0]->[4]] }
  sub format_o { sprintf("%2d%s",$_[0]->[3],"\x{03b7}") }
  sub format_p { $_[0]->[2] >= 12 ?  $AMPM[1] : $AMPM[0] }
  
  1;
  
  
  
DATE_LANGUAGE_GREEK

$fatpacked{"Date/Language/Hungarian.pm"} = <<'DATE_LANGUAGE_HUNGARIAN';
  ##
  ## Hungarian tables based on English
  ##
  #
  # This is a just-because-I-stumbled-across-it
  # -and-my-wife-is-Hungarian release: if Graham or
  # someone adds to docs to Date::Format, I'd be
  # glad to correct bugs and extend as neeed.
  #
  
  package Date::Language::Hungarian;
  
  =head1 NAME
  
  Date::Language::Hungarian - Magyar format for Date::Format
  
  =head1 SYNOPSIS
  
  	my $lang = Date::Language->new('Hungarian');
  	print $lang->time2str("%a %b %e %T %Y", time);
  
  	@lt = localtime(time);
  	print $lang->time2str($template, time);
  	print $lang->strftime($template, @lt);
  
  	print $lang->time2str($template, time, $zone);
  	print $lang->strftime($template, @lt, $zone);
  
  	print $lang->ctime(time);
  	print $lang->asctime(@lt);
  
  	print $lang->ctime(time, $zone);
  	print $lang->asctime(@lt, $zone);
  
  See L<Date::Format>.
  
  =head1 AUTHOR
  
  Paula Goddard (paula -at- paulacska -dot- com)
  
  =head1 LICENCE
  
  Made available under the same terms as Perl itself.
  
  =cut
  
  use strict;
  use warnings;
  use base "Date::Language";
  use vars qw( @DoW @DoWs @MoY @MoYs @AMPM @Dsuf %MoY %DoW $VERSION);
  $VERSION = "1.01";
  
  @DoW = qw(Vasárnap Hétfõ Kedd Szerda Csütörtök Péntek Szombat);
  @MoY = qw(Január Február Március Április Május Június
  	  Július Augusztus Szeptember Október November December);
  @DoWs = map { substr($_,0,3) } @DoW;
  @MoYs = map { substr($_,0,3) } @MoY;
  @AMPM = qw(DE. DU.);
  
  # There is no 'th or 'nd in Hungarian, just a dot
  @Dsuf = (".") x 31;
  
  @MoY{@MoY}  = (0 .. scalar(@MoY));
  @MoY{@MoYs} = (0 .. scalar(@MoYs));
  @DoW{@DoW}  = (0 .. scalar(@DoW));
  @DoW{@DoWs} = (0 .. scalar(@DoWs));
  
  # Formatting routines
  
  sub format_a { $DoWs[$_[0]->[6]] }
  sub format_A { $DoW[$_[0]->[6]] }
  sub format_b { $MoYs[$_[0]->[4]] }
  sub format_B { $MoY[$_[0]->[4]] }
  sub format_h { $MoYs[$_[0]->[4]] }
  sub format_p { $_[0]->[2] >= 12 ?  $AMPM[1] : $AMPM[0] }
  sub format_P { lc($_[0]->[2] >= 12 ?  $AMPM[1] : $AMPM[0]) }
  sub format_o { $_[0]->[3].'.' }
  
  
  
  sub format_D { &format_y . "." . &format_m . "." . &format_d  }
  
  sub format_y { sprintf("%02d",$_[0]->[5] % 100) }
  sub format_d { sprintf("%02d",$_[0]->[3]) }
  sub format_m { sprintf("%02d",$_[0]->[4] + 1) }
  
  
  1;
DATE_LANGUAGE_HUNGARIAN

$fatpacked{"Date/Language/Icelandic.pm"} = <<'DATE_LANGUAGE_ICELANDIC';
  ##
  ## Icelandic tables
  ##
  
  package Date::Language::Icelandic;
  
  use Date::Language ();
  use vars qw(@ISA @DoW @DoWs @MoY @MoYs @AMPM @Dsuf %MoY %DoW $VERSION);
  @ISA = qw(Date::Language);
  $VERSION = "1.01";
  
  @MoY  = qw(Janúar Febrúar Mars Apríl Maí Júni
  	   Júli Ágúst September Október Nóvember Desember);
  @MoYs = qw(Jan Feb Mar Apr Maí Jún Júl Ágú Sep Okt Nóv Des);
  @DoW  = qw(Sunnudagur Mánudagur Þriðjudagur Miðvikudagur Fimmtudagur Föstudagur Laugardagur Sunnudagur);
  @DoWs = qw(Sun Mán Þri Mið Fim Fös Lau Sun);
  
  use Date::Language::English ();
  @AMPM =   @{Date::Language::English::AMPM};
  @Dsuf =   @{Date::Language::English::Dsuf};
  
  @MoY{@MoY}  = (0 .. scalar(@MoY));
  @MoY{@MoYs} = (0 .. scalar(@MoYs));
  @DoW{@DoW}  = (0 .. scalar(@DoW));
  @DoW{@DoWs} = (0 .. scalar(@DoWs));
  
  # Formatting routines
  
  sub format_a { $DoWs[$_[0]->[6]] }
  sub format_A { $DoW[$_[0]->[6]] }
  sub format_b { $MoYs[$_[0]->[4]] }
  sub format_B { $MoY[$_[0]->[4]] }
  sub format_h { $MoYs[$_[0]->[4]] }
  sub format_p { $_[0]->[2] >= 12 ?  $AMPM[1] : $AMPM[0] }
  
  1;
DATE_LANGUAGE_ICELANDIC

$fatpacked{"Date/Language/Italian.pm"} = <<'DATE_LANGUAGE_ITALIAN';
  ##
  ## Italian tables
  ##
  
  package Date::Language::Italian;
  
  use Date::Language ();
  use vars qw(@ISA @DoW @DoWs @MoY @MoYs @AMPM @Dsuf %MoY %DoW $VERSION);
  @ISA = qw(Date::Language);
  $VERSION = "1.01";
  
  @MoY  = qw(Gennaio Febbraio Marzo Aprile Maggio Giugno
  	   Luglio Agosto Settembre Ottobre Novembre Dicembre);
  @MoYs = qw(Gen Feb Mar Apr Mag Giu Lug Ago Set Ott Nov Dic);
  @DoW  = qw(Domenica Lunedi Martedi Mercoledi Giovedi Venerdi Sabato);
  @DoWs = qw(Dom Lun Mar Mer Gio Ven Sab);
  
  use Date::Language::English ();
  @AMPM =   @{Date::Language::English::AMPM};
  @Dsuf =   @{Date::Language::English::Dsuf};
  
  @MoY{@MoY}  = (0 .. scalar(@MoY));
  @MoY{@MoYs} = (0 .. scalar(@MoYs));
  @DoW{@DoW}  = (0 .. scalar(@DoW));
  @DoW{@DoWs} = (0 .. scalar(@DoWs));
  
  # Formatting routines
  
  sub format_a { $DoWs[$_[0]->[6]] }
  sub format_A { $DoW[$_[0]->[6]] }
  sub format_b { $MoYs[$_[0]->[4]] }
  sub format_B { $MoY[$_[0]->[4]] }
  sub format_h { $MoYs[$_[0]->[4]] }
  sub format_p { $_[0]->[2] >= 12 ?  $AMPM[1] : $AMPM[0] }
  
  1;
DATE_LANGUAGE_ITALIAN

$fatpacked{"Date/Language/Norwegian.pm"} = <<'DATE_LANGUAGE_NORWEGIAN';
  ##
  ## Norwegian tables
  ##
  
  package Date::Language::Norwegian;
  
  use Date::Language ();
  use vars qw(@ISA @DoW @DoWs @MoY @MoYs @AMPM @Dsuf %MoY %DoW $VERSION);
  @ISA = qw(Date::Language);
  $VERSION = "1.01";
  
  @MoY  = qw(Januar Februar Mars April Mai Juni
  	   Juli August September Oktober November Desember);
  @MoYs = qw(Jan Feb Mar Apr Mai Jun Jul Aug Sep Okt Nov Des);
  @DoW  = qw(Søndag Mandag Tirsdag Onsdag Torsdag Fredag Lørdag Søndag);
  @DoWs = qw(Søn Man Tir Ons Tor Fre Lør Søn);
  
  use Date::Language::English ();
  @AMPM =   @{Date::Language::English::AMPM};
  @Dsuf =   @{Date::Language::English::Dsuf};
  
  @MoY{@MoY}  = (0 .. scalar(@MoY));
  @MoY{@MoYs} = (0 .. scalar(@MoYs));
  @DoW{@DoW}  = (0 .. scalar(@DoW));
  @DoW{@DoWs} = (0 .. scalar(@DoWs));
  
  # Formatting routines
  
  sub format_a { $DoWs[$_[0]->[6]] }
  sub format_A { $DoW[$_[0]->[6]] }
  sub format_b { $MoYs[$_[0]->[4]] }
  sub format_B { $MoY[$_[0]->[4]] }
  sub format_h { $MoYs[$_[0]->[4]] }
  sub format_p { $_[0]->[2] >= 12 ?  $AMPM[1] : $AMPM[0] }
  
  1;
DATE_LANGUAGE_NORWEGIAN

$fatpacked{"Date/Language/Oromo.pm"} = <<'DATE_LANGUAGE_OROMO';
  ##
  ## Oromo tables
  ##
  
  package Date::Language::Oromo;
  
  use Date::Language ();
  use vars qw(@ISA @DoW @DoWs @MoY @MoYs @AMPM @Dsuf %MoY %DoW $VERSION);
  @ISA = qw(Date::Language);
  $VERSION = "0.99";
  
  @DoW = qw(Dilbata Wiixata Qibxata Roobii Kamiisa Jimaata Sanbata);
  @MoY = qw(Amajjii Guraandhala Bitooteessa Elba Caamsa Waxabajjii
            Adooleessa Hagayya Fuulbana Onkololeessa Sadaasa Muddee);
  @DoWs = map { substr($_,0,3) } @DoW;
  @MoYs = map { substr($_,0,3) } @MoY;
  @AMPM = qw(WD WB);
  
  @Dsuf = (qw(th st nd rd th th th th th th)) x 3;
  @Dsuf[11,12,13] = qw(th th th);
  @Dsuf[30,31] = qw(th st);
  
  @MoY{@MoY}  = (0 .. scalar(@MoY));
  @MoY{@MoYs} = (0 .. scalar(@MoYs));
  @DoW{@DoW}  = (0 .. scalar(@DoW));
  @DoW{@DoWs} = (0 .. scalar(@DoWs));
  
  # Formatting routines
  
  sub format_a { $DoWs[$_[0]->[6]] }
  sub format_A { $DoW[$_[0]->[6]] }
  sub format_b { $MoYs[$_[0]->[4]] }
  sub format_B { $MoY[$_[0]->[4]] }
  sub format_h { $MoYs[$_[0]->[4]] }
  sub format_p { $_[0]->[2] >= 12 ?  $AMPM[1] : $AMPM[0] }
  
  1;
DATE_LANGUAGE_OROMO

$fatpacked{"Date/Language/Romanian.pm"} = <<'DATE_LANGUAGE_ROMANIAN';
  ##
  ## Italian tables
  ##
  
  package Date::Language::Romanian;
  
  use Date::Language ();
  use vars qw(@ISA @DoW @DoWs @MoY @MoYs @AMPM @Dsuf %MoY %DoW $VERSION);
  @ISA = qw(Date::Language);
  $VERSION = "1.01";
  
  @MoY  = qw(ianuarie februarie martie aprilie mai iunie 
  		iulie august septembrie octombrie noembrie decembrie);
  @DoW  = qw(duminica luni marti miercuri joi vineri sambata);
  @DoWs = map { substr($_,0,3) } @DoW;
  @MoYs = map { substr($_,0,3) } @MoY;
  
  @AMPM = qw(AM PM);
  
  @Dsuf = ('') x 31;
  
  
  @MoY{@MoY}  = (0 .. scalar(@MoY));
  @MoY{@MoYs} = (0 .. scalar(@MoYs));
  @DoW{@DoW}  = (0 .. scalar(@DoW));
  @DoW{@DoWs} = (0 .. scalar(@DoWs));
  
  # Formatting routines
  
  sub format_a { $DoWs[$_[0]->[6]] }
  sub format_A { $DoW[$_[0]->[6]] }
  sub format_b { $MoYs[$_[0]->[4]] }
  sub format_B { $MoY[$_[0]->[4]] }
  sub format_h { $MoYs[$_[0]->[4]] }
  sub format_p { $_[0]->[2] >= 12 ?  $AMPM[1] : $AMPM[0] }
  
  1;
DATE_LANGUAGE_ROMANIAN

$fatpacked{"Date/Language/Russian.pm"} = <<'DATE_LANGUAGE_RUSSIAN';
  ##
  ## Russian tables
  ##
  ## Contributed by Danil Pismenny <dapi@mail.ru>
  
  package Date::Language::Russian;
  
  use vars qw(@ISA @DoW @DoWs @MoY @MoYs @MoY2 @AMPM %MoY %DoW $VERSION);
  @ISA = qw(Date::Language Date::Format::Generic);
  $VERSION = "1.01";
  
  @MoY = qw(ñÎ×ÁÒÑ æÅ×ÒÁÌÑ íÁÒÔÁ áÐÒÅÌÑ íÁÑ éÀÎÑ éÀÌÑ á×ÇÕÓÔÁ óÅÎÔÑÂÒÑ ïËÔÑÂÒÑ îÏÑÂÒÑ äÅËÁÂÒÑ);
  @MoY2 = qw(ñÎ×ÁÒØ æÅ×ÒÁÌØ íÁÒÔ áÐÒÅÌØ íÁÊ éÀÎØ éÀÌØ á×ÇÕÓÔ óÅÎÔÑÂÒØ ïËÔÑÂÒØ îÏÑÂÒØ äÅËÁÂÒØ);
  @MoYs = qw(ñÎ× æÅ× íÒÔ áÐÒ íÁÊ éÀÎ éÀÌ á×Ç óÅÎ ïËÔ îÏÑ äÅË);
  
  @DoW = qw(ðÏÎÅÄÅÌØÎÉË ÷ÔÏÒÎÉË óÒÅÄÁ þÅÔ×ÅÒÇ ðÑÔÎÉÃÁ óÕÂÂÏÔÁ ÷ÏÓËÒÅÓÅÎØÅ);
  @DoWs = qw(ðÎ ÷Ô óÒ þÔ ðÔ óÂ ÷Ó);
  @DoWs2 = qw(ðÎÄ ÷ÔÒ óÒÄ þÔ× ðÔÎ óÂÔ ÷ÓË);
  
  @AMPM = qw(ÄÐ ÐÐ);
  
  @MoY{@MoY}  = (0 .. scalar(@MoY));
  @MoY{@MoYs} = (0 .. scalar(@MoYs));
  @DoW{@DoW}  = (0 .. scalar(@DoW));
  @DoW{@DoWs} = (0 .. scalar(@DoWs));
  
  # Formatting routines
  
  sub format_a { $DoWs[$_[0]->[6]] }
  sub format_A { $DoW[$_[0]->[6]] }
  sub format_b { $MoYs[$_[0]->[4]] }
  sub format_B { $MoY[$_[0]->[4]] }
  sub format_h { $MoYs[$_[0]->[4]] }
  sub format_p { $_[0]->[2] >= 12 ?  $AMPM[1] : $AMPM[0] }
  
  sub format_d { $_[0]->[3] }
  sub format_m { $_[0]->[4] + 1 }
  sub format_o { $_[0]->[3] . '.' }
  
  sub format_Q { $MoY2[$_[0]->[4]] }
  
  sub str2time {
    my ($self,$value) = @_;
    map {$value=~s/(\s|^)$DoWs2[$_](\s)/$DoWs[$_]$2/ig} (0..6);
    $value=~s/(\s+|^)íÁÒ(\s+)/$1íÒÔ$2/;
    return $self->SUPER::str2time($value);
  }
  
  1;
DATE_LANGUAGE_RUSSIAN

$fatpacked{"Date/Language/Russian_cp1251.pm"} = <<'DATE_LANGUAGE_RUSSIAN_CP1251';
  ##
  ## Russian cp1251
  ##
  
  package Date::Language::Russian_cp1251;
  
  use Date::Language ();
  use vars qw(@ISA @DoW @DoWs @MoY @MoYs @AMPM @Dsuf %MoY %DoW $VERSION);
  @ISA = qw(Date::Language);
  $VERSION = "1.01";
  
  @DoW = qw(Âîñêðåñåíüå Ïîíåäåëüíèê Âòîðíèê Ñðåäà ×åòâåðã Ïÿòíèöà Ñóááîòà);
  @MoY = qw(ßíâàðü Ôåâðàëü Ìàðò Àïðåëü Ìàé Èþíü
        Èþëü Àâãóñò Ñåíòÿáðü Îêòÿáðü Íîÿáðü Äåêàáðü);
  @DoWs = qw(Âñê Ïíä Âòð Ñðä ×òâ Ïòí Ñáò);
  #@DoWs = map { substr($_,0,3) } @DoW;
  @MoYs = map { substr($_,0,3) } @MoY;
  @AMPM = qw(AM PM);
  
  @Dsuf = ('e') x 31;
  #@Dsuf[11,12,13] = qw(å å å);
  #@Dsuf[30,31] = qw(å å);
  
  @MoY{@MoY}  = (0 .. scalar(@MoY));
  @MoY{@MoYs} = (0 .. scalar(@MoYs));
  @DoW{@DoW}  = (0 .. scalar(@DoW));
  @DoW{@DoWs} = (0 .. scalar(@DoWs));
  
  # Formatting routines
  
  sub format_a { $DoWs[$_[0]->[6]] }
  sub format_A { $DoW[$_[0]->[6]] }
  sub format_b { $MoYs[$_[0]->[4]] }
  sub format_B { $MoY[$_[0]->[4]] }
  sub format_h { $MoYs[$_[0]->[4]] }
  sub format_p { $_[0]->[2] >= 12 ?  $AMPM[1] : $AMPM[0] }
  sub format_o { sprintf("%2de",$_[0]->[3]) }
  
  1;
DATE_LANGUAGE_RUSSIAN_CP1251

$fatpacked{"Date/Language/Russian_koi8r.pm"} = <<'DATE_LANGUAGE_RUSSIAN_KOI8R';
  ##
  ## Russian koi8r
  ##
  
  package Date::Language::Russian_koi8r;
  
  use Date::Language ();
  use vars qw(@ISA @DoW @DoWs @MoY @MoYs @AMPM @Dsuf %MoY %DoW $VERSION);
  @ISA = qw(Date::Language);
  $VERSION = "1.01";
  
  @DoW = qw(÷ÏÓËÒÅÓÅÎØÅ ðÏÎÅÄÅÌØÎÉË ÷ÔÏÒÎÉË óÒÅÄÁ þÅÔ×ÅÒÇ ðÑÔÎÉÃÁ óÕÂÂÏÔÁ);
  @MoY = qw(ñÎ×ÁÒØ æÅ×ÒÁÌØ íÁÒÔ áÐÒÅÌØ íÁÊ éÀÎØ
        éÀÌØ á×ÇÕÓÔ óÅÎÔÑÂÒØ ïËÔÑÂÒØ îÏÑÂÒØ äÅËÁÂÒØ);
  @DoWs = qw(÷ÓË ðÎÄ ÷ÔÒ óÒÄ þÔ× ðÔÎ óÂÔ);
  #@DoWs = map { substr($_,0,3) } @DoW;
  @MoYs = map { substr($_,0,3) } @MoY;
  @AMPM = qw(AM PM);
  
  @Dsuf = ('e') x 31;
  #@Dsuf[11,12,13] = qw(Å Å Å);
  #@Dsuf[30,31] = qw(Å Å);
  
  @MoY{@MoY}  = (0 .. scalar(@MoY));
  @MoY{@MoYs} = (0 .. scalar(@MoYs));
  @DoW{@DoW}  = (0 .. scalar(@DoW));
  @DoW{@DoWs} = (0 .. scalar(@DoWs));
  
  # Formatting routines
  
  sub format_a { $DoWs[$_[0]->[6]] }
  sub format_A { $DoW[$_[0]->[6]] }
  sub format_b { $MoYs[$_[0]->[4]] }
  sub format_B { $MoY[$_[0]->[4]] }
  sub format_h { $MoYs[$_[0]->[4]] }
  sub format_p { $_[0]->[2] >= 12 ?  $AMPM[1] : $AMPM[0] }
  sub format_o { sprintf("%2de",$_[0]->[3]) }
  
  1;
DATE_LANGUAGE_RUSSIAN_KOI8R

$fatpacked{"Date/Language/Sidama.pm"} = <<'DATE_LANGUAGE_SIDAMA';
  ##
  ## Sidama tables
  ##
  
  package Date::Language::Sidama;
  
  use Date::Language ();
  use vars qw(@ISA @DoW @DoWs @MoY @MoYs @AMPM @Dsuf %MoY %DoW $VERSION);
  @ISA = qw(Date::Language);
  $VERSION = "0.99";
  
  @DoW = qw(Sambata Sanyo Maakisanyo Roowe Hamuse Arbe Qidaame);
  @MoY = qw(January February March April May June
            July August September October November December);
  @DoWs = map { substr($_,0,3) } @DoW;
  @MoYs = map { substr($_,0,3) } @MoY;
  @AMPM = qw(soodo hawwaro);
  
  @Dsuf = (qw(th st nd rd th th th th th th)) x 3;
  @Dsuf[11,12,13] = qw(th th th);
  @Dsuf[30,31] = qw(th st);
  
  @MoY{@MoY}  = (0 .. scalar(@MoY));
  @MoY{@MoYs} = (0 .. scalar(@MoYs));
  @DoW{@DoW}  = (0 .. scalar(@DoW));
  @DoW{@DoWs} = (0 .. scalar(@DoWs));
  
  # Formatting routines
  
  sub format_a { $DoWs[$_[0]->[6]] }
  sub format_A { $DoW[$_[0]->[6]] }
  sub format_b { $MoYs[$_[0]->[4]] }
  sub format_B { $MoY[$_[0]->[4]] }
  sub format_h { $MoYs[$_[0]->[4]] }
  sub format_p { $_[0]->[2] >= 12 ?  $AMPM[1] : $AMPM[0] }
  
  1;
DATE_LANGUAGE_SIDAMA

$fatpacked{"Date/Language/Somali.pm"} = <<'DATE_LANGUAGE_SOMALI';
  ##
  ## Somali tables
  ##
  
  package Date::Language::Somali;
  
  use Date::Language ();
  use vars qw(@ISA @DoW @DoWs @MoY @MoYs @AMPM @Dsuf %MoY %DoW $VERSION);
  @ISA = qw(Date::Language);
  $VERSION = "0.99";
  
  @DoW = qw(Axad Isniin Salaaso Arbaco Khamiis Jimco Sabti);
  @MoY = (
  "Bisha Koobaad",
  "Bisha Labaad",
  "Bisha Saddexaad",
  "Bisha Afraad",
  "Bisha Shanaad",
  "Bisha Lixaad",
  "Bisha Todobaad",
  "Bisha Sideedaad",
  "Bisha Sagaalaad",
  "Bisha Tobnaad",
  "Bisha Kow iyo Tobnaad",
  "Bisha Laba iyo Tobnaad"
  );
  @DoWs = map { substr($_,0,3) } @DoW;
  @MoYs = (
  "Kob",
  "Lab",
  "Sad",
  "Afr",
  "Sha",
  "Lix",
  "Tod",
  "Sid",
  "Sag",
  "Tob",
  "KIT",
  "LIT"
  );
  @AMPM = qw(SN GN);
  
  @Dsuf = (qw(th st nd rd th th th th th th)) x 3;
  @Dsuf[11,12,13] = qw(th th th);
  @Dsuf[30,31] = qw(th st);
  
  @MoY{@MoY}  = (0 .. scalar(@MoY));
  @MoY{@MoYs} = (0 .. scalar(@MoYs));
  @DoW{@DoW}  = (0 .. scalar(@DoW));
  @DoW{@DoWs} = (0 .. scalar(@DoWs));
  
  # Formatting routines
  
  sub format_a { $DoWs[$_[0]->[6]] }
  sub format_A { $DoW[$_[0]->[6]] }
  sub format_b { $MoYs[$_[0]->[4]] }
  sub format_B { $MoY[$_[0]->[4]] }
  sub format_h { $MoYs[$_[0]->[4]] }
  sub format_p { $_[0]->[2] >= 12 ?  $AMPM[1] : $AMPM[0] }
  
  1;
DATE_LANGUAGE_SOMALI

$fatpacked{"Date/Language/Spanish.pm"} = <<'DATE_LANGUAGE_SPANISH';
  ##
  ## Spanish tables
  ##
  
  package Date::Language::Spanish;
  
  use Date::Language ();
  use vars qw(@ISA @DoW @DoWs @MoY @MoYs @AMPM @Dsuf %MoY %DoW $VERSION);
  @ISA = qw(Date::Language);
  $VERSION = "1.00";
  
  @DoW = qw(domingo lunes martes miércoles jueves viernes sábado);
  @MoY = qw(enero febrero marzo abril mayo junio
  	  julio agosto septiembre octubre noviembre diciembre);
  @DoWs = map { substr($_,0,3) } @DoW;
  @MoYs = map { substr($_,0,3) } @MoY;
  @AMPM = qw(AM PM);
  
  @Dsuf = ((qw(ro do ro to to to mo vo no mo)) x 3, 'ro');
  
  @MoY{@MoY}  = (0 .. scalar(@MoY));
  @MoY{@MoYs} = (0 .. scalar(@MoYs));
  @DoW{@DoW}  = (0 .. scalar(@DoW));
  @DoW{@DoWs} = (0 .. scalar(@DoWs));
  
  # Formatting routines
  
  sub format_a { $DoWs[$_[0]->[6]] }
  sub format_A { $DoW[$_[0]->[6]] }
  sub format_b { $MoYs[$_[0]->[4]] }
  sub format_B { $MoY[$_[0]->[4]] }
  sub format_h { $MoYs[$_[0]->[4]] }
  sub format_p { $_[0]->[2] >= 12 ?  $AMPM[1] : $AMPM[0] }
  
  1;
DATE_LANGUAGE_SPANISH

$fatpacked{"Date/Language/Swedish.pm"} = <<'DATE_LANGUAGE_SWEDISH';
  ##
  ## Swedish tables
  ## Contributed by Matthew Musgrove <muskrat@mindless.com>
  ## Corrected by dempa
  ##
  
  package Date::Language::Swedish;
  
  use Date::Language ();
  use vars qw(@ISA @DoW @DoWs @MoY @MoYs @AMPM @Dsuf %MoY %DoW $VERSION);
  @ISA = qw(Date::Language);
  $VERSION = "1.01";
  
  @MoY  = qw(januari februari mars april maj juni juli augusti september oktober november december);
  @MoYs = map { substr($_,0,3) } @MoY;
  @DoW  = map($_ . "dagen", qw(sön mån tis ons tors fre lör));
  @DoWs = map { substr($_,0,2) } @DoW;
  
  # the ordinals are not typically used in modern times
  @Dsuf = ('a' x 2, 'e' x 29);
  
  use Date::Language::English ();
  @AMPM =   @{Date::Language::English::AMPM};
  
  
  @MoY{@MoY}  = (0 .. scalar(@MoY));
  @MoY{@MoYs} = (0 .. scalar(@MoYs));
  @DoW{@DoW}  = (0 .. scalar(@DoW));
  @DoW{@DoWs} = (0 .. scalar(@DoWs));
  
  # Formatting routines
  
  sub format_a { $DoWs[$_[0]->[6]] }
  sub format_A { $DoW[$_[0]->[6]] }
  sub format_b { $MoYs[$_[0]->[4]] }
  sub format_B { $MoY[$_[0]->[4]] }
  sub format_h { $MoYs[$_[0]->[4]] }
  sub format_p { $_[0]->[2] >= 12 ?  $AMPM[1] : $AMPM[0] }
  sub format_o { sprintf("%2de",$_[0]->[3]) }
  
  1;
DATE_LANGUAGE_SWEDISH

$fatpacked{"Date/Language/Tigrinya.pm"} = <<'DATE_LANGUAGE_TIGRINYA';
  ##
  ## Tigrinya tables
  ##
  
  package Date::Language::Tigrinya;
  
  use Date::Language ();
  use vars qw(@ISA @DoW @DoWs @MoY @MoYs @AMPM @Dsuf %MoY %DoW $VERSION);
  @ISA = qw(Date::Language);
  $VERSION = "1.00";
  
  @DoW = (
  "\x{1230}\x{1295}\x{1260}\x{1275}",
  "\x{1230}\x{1291}\x{12ed}",
  "\x{1230}\x{1209}\x{1235}",
  "\x{1228}\x{1261}\x{12d5}",
  "\x{1213}\x{1219}\x{1235}",
  "\x{12d3}\x{122d}\x{1262}",
  "\x{1240}\x{12f3}\x{121d}"
  );
  @MoY = (
  "\x{1303}\x{1295}\x{12e9}\x{12c8}\x{122a}",
  "\x{134c}\x{1265}\x{1229}\x{12c8}\x{122a}",
  "\x{121b}\x{122d}\x{127d}",
  "\x{12a4}\x{1355}\x{1228}\x{120d}",
  "\x{121c}\x{12ed}",
  "\x{1301}\x{1295}",
  "\x{1301}\x{120b}\x{12ed}",
  "\x{12a6}\x{1308}\x{1235}\x{1275}",
  "\x{1234}\x{1355}\x{1274}\x{121d}\x{1260}\x{122d}",
  "\x{12a6}\x{12ad}\x{1270}\x{12cd}\x{1260}\x{122d}",
  "\x{1296}\x{126c}\x{121d}\x{1260}\x{122d}",
  "\x{12f2}\x{1234}\x{121d}\x{1260}\x{122d}"
  );
  @DoWs = map { substr($_,0,3) } @DoW;
  @MoYs = map { substr($_,0,3) } @MoY;
  @AMPM = (
  "\x{1295}/\x{1230}",
  "\x{12F5}/\x{1230}"
  );
  
  @Dsuf = ("\x{12ed}" x 31);
  
  @MoY{@MoY}  = (0 .. scalar(@MoY));
  @MoY{@MoYs} = (0 .. scalar(@MoYs));
  @DoW{@DoW}  = (0 .. scalar(@DoW));
  @DoW{@DoWs} = (0 .. scalar(@DoWs));
  
  # Formatting routines
  
  sub format_a { $DoWs[$_[0]->[6]] }
  sub format_A { $DoW[$_[0]->[6]] }
  sub format_b { $MoYs[$_[0]->[4]] }
  sub format_B { $MoY[$_[0]->[4]] }
  sub format_h { $MoYs[$_[0]->[4]] }
  sub format_p { $_[0]->[2] >= 12 ?  $AMPM[1] : $AMPM[0] }
  
  1;
DATE_LANGUAGE_TIGRINYA

$fatpacked{"Date/Language/TigrinyaEritrean.pm"} = <<'DATE_LANGUAGE_TIGRINYAERITREAN';
  ##
  ## Tigrinya-Eritrean tables
  ##
  
  package Date::Language::TigrinyaEritrean;
  
  use Date::Language ();
  use vars qw(@ISA @DoW @DoWs @MoY @MoYs @AMPM @Dsuf %MoY %DoW $VERSION);
  @ISA = qw(Date::Language);
  $VERSION = "1.00";
  
  if ( $] >= 5.006 ) {
  @DoW = (
  "\x{1230}\x{1295}\x{1260}\x{1275}",
  "\x{1230}\x{1291}\x{12ed}",
  "\x{1230}\x{1209}\x{1235}",
  "\x{1228}\x{1261}\x{12d5}",
  "\x{1213}\x{1219}\x{1235}",
  "\x{12d3}\x{122d}\x{1262}",
  "\x{1240}\x{12f3}\x{121d}"
  );
  @MoY = (
  "\x{1303}\x{1295}\x{12e9}\x{12c8}\x{122a}",
  "\x{134c}\x{1265}\x{1229}\x{12c8}\x{122a}",
  "\x{121b}\x{122d}\x{127d}",
  "\x{12a4}\x{1355}\x{1228}\x{120d}",
  "\x{121c}\x{12ed}",
  "\x{1301}\x{1295}",
  "\x{1301}\x{120b}\x{12ed}",
  "\x{12a6}\x{1308}\x{1235}\x{1275}",
  "\x{1234}\x{1355}\x{1274}\x{121d}\x{1260}\x{122d}",
  "\x{12a6}\x{12ad}\x{1270}\x{12cd}\x{1260}\x{122d}",
  "\x{1296}\x{126c}\x{121d}\x{1260}\x{122d}",
  "\x{12f2}\x{1234}\x{121d}\x{1260}\x{122d}"
  );
  @DoWs = map { substr($_,0,3) } @DoW;
  @MoYs = map { substr($_,0,3) } @MoY;
  @AMPM = (
  "\x{1295}/\x{1230}",
  "\x{12F5}/\x{1230}"
  );
  
  @Dsuf = ("\x{12ed}" x 31);
  }
  else {
  @DoW = (
  "áˆ°áŠ•á‰ á‰µ",
  "áˆ°áŠ‘á‹­",
  "áˆ°áˆ‰áˆµ",
  "áˆ¨á‰¡á‹•",
  "áˆ“áˆ™áˆµ",
  "á‹“áˆ­á‰¢",
  "á‰€á‹³áˆ"
  );
  @MoY = (
  "áŒ¥áˆª",
  "áˆˆáŠ«á‰²á‰µ",
  "áˆ˜áŒ‹á‰¢á‰µ",
  "áˆšá‹«á‹á‹«",
  "áŒáŠ•á‰¦á‰µ",
  "áˆ°áŠ",
  "áˆ“áˆáˆˆ",
  "áŠáˆ“áˆ°",
  "áˆ˜áˆµáŠ¨áˆ¨áˆ",
  "áŒ¥á‰…áˆá‰²",
  "áˆ•á‹³áˆ­",
  "á‰³áˆ•áˆ³áˆµ"
  );
  @DoWs = map { substr($_,0,9) } @DoW;
  @MoYs = map { substr($_,0,9) } @MoY;
  @AMPM = (
  "áŠ•/áˆ°",
  "á‹µ/áˆ°"
  );
  
  @Dsuf = ("á‹­" x 31);
  }
  
  @MoY{@MoY}  = (0 .. scalar(@MoY));
  @MoY{@MoYs} = (0 .. scalar(@MoYs));
  @DoW{@DoW}  = (0 .. scalar(@DoW));
  @DoW{@DoWs} = (0 .. scalar(@DoWs));
  
  # Formatting routines
  
  sub format_a { $DoWs[$_[0]->[6]] }
  sub format_A { $DoW[$_[0]->[6]] }
  sub format_b { $MoYs[$_[0]->[4]] }
  sub format_B { $MoY[$_[0]->[4]] }
  sub format_h { $MoYs[$_[0]->[4]] }
  sub format_p { $_[0]->[2] >= 12 ?  $AMPM[1] : $AMPM[0] }
  
  1;
DATE_LANGUAGE_TIGRINYAERITREAN

$fatpacked{"Date/Language/TigrinyaEthiopian.pm"} = <<'DATE_LANGUAGE_TIGRINYAETHIOPIAN';
  ##
  ## Tigrinya-Ethiopian tables
  ##
  
  package Date::Language::TigrinyaEthiopian;
  
  use Date::Language ();
  use vars qw(@ISA @DoW @DoWs @MoY @MoYs @AMPM @Dsuf %MoY %DoW $VERSION);
  @ISA = qw(Date::Language);
  $VERSION = "1.00";
  
  if ( $] >= 5.006 ) {
  @DoW = (
  "\x{1230}\x{1295}\x{1260}\x{1275}",
  "\x{1230}\x{1291}\x{12ed}",
  "\x{1230}\x{1209}\x{1235}",
  "\x{1228}\x{1261}\x{12d5}",
  "\x{1213}\x{1219}\x{1235}",
  "\x{12d3}\x{122d}\x{1262}",
  "\x{1240}\x{12f3}\x{121d}"
  );
  @MoY = (
  "\x{1303}\x{1295}\x{12e9}\x{12c8}\x{122a}",
  "\x{134c}\x{1265}\x{1229}\x{12c8}\x{122a}",
  "\x{121b}\x{122d}\x{127d}",
  "\x{12a4}\x{1355}\x{1228}\x{120d}",
  "\x{121c}\x{12ed}",
  "\x{1301}\x{1295}",
  "\x{1301}\x{120b}\x{12ed}",
  "\x{12a6}\x{1308}\x{1235}\x{1275}",
  "\x{1234}\x{1355}\x{1274}\x{121d}\x{1260}\x{122d}",
  "\x{12a6}\x{12ad}\x{1270}\x{12cd}\x{1260}\x{122d}",
  "\x{1296}\x{126c}\x{121d}\x{1260}\x{122d}",
  "\x{12f2}\x{1234}\x{121d}\x{1260}\x{122d}"
  );
  @DoWs = map { substr($_,0,3) } @DoW;
  @MoYs = map { substr($_,0,3) } @MoY;
  @AMPM = (
  "\x{1295}/\x{1230}",
  "\x{12F5}/\x{1230}"
  );
  
  @Dsuf = ("\x{12ed}" x 31);
  }
  else {
  @DoW = (
  "áˆ°áŠ•á‰ á‰µ",
  "áˆ°áŠ‘á‹­",
  "áˆ°áˆ‰áˆµ",
  "áˆ¨á‰¡á‹•",
  "áˆ“áˆ™áˆµ",
  "á‹“áˆ­á‰¢",
  "á‰€á‹³áˆ"
  );
  @MoY = (
  "áŒƒáŠ•á‹©á‹ˆáˆª",
  "áŒá‰¥áˆ©á‹ˆáˆª",
  "áˆ›áˆ­á‰½",
  "áŠ¤á•áˆ¨áˆ",
  "áˆœá‹­",
  "áŒáŠ•",
  "áŒáˆ‹á‹­",
  "áŠ¦áŒˆáˆµá‰µ",
  "áˆ´á•á‰´áˆá‰ áˆ­",
  "áŠ¦áŠ­á‰°á‹á‰ áˆ­",
  "áŠ–á‰¬áˆá‰ áˆ­",
  "á‹²áˆ´áˆá‰ áˆ­"
  );
  @DoWs = map { substr($_,0,9) } @DoW;
  @MoYs = map { substr($_,0,9) } @MoY;
  @AMPM = (
  "áŠ•/áˆ°",
  "á‹µ/áˆ°"
  );
  
  @Dsuf = ("á‹­" x 31);
  }
  
  @MoY{@MoY}  = (0 .. scalar(@MoY));
  @MoY{@MoYs} = (0 .. scalar(@MoYs));
  @DoW{@DoW}  = (0 .. scalar(@DoW));
  @DoW{@DoWs} = (0 .. scalar(@DoWs));
  
  # Formatting routines
  
  sub format_a { $DoWs[$_[0]->[6]] }
  sub format_A { $DoW[$_[0]->[6]] }
  sub format_b { $MoYs[$_[0]->[4]] }
  sub format_B { $MoY[$_[0]->[4]] }
  sub format_h { $MoYs[$_[0]->[4]] }
  sub format_p { $_[0]->[2] >= 12 ?  $AMPM[1] : $AMPM[0] }
  
  1;
DATE_LANGUAGE_TIGRINYAETHIOPIAN

$fatpacked{"Date/Language/Turkish.pm"} = <<'DATE_LANGUAGE_TURKISH';
  #----------------------------------------------------#
  #
  # Turkish tables
  # Burak Gürsoy <burak@cpan.org>
  # Last modified: Sat Nov 15 20:28:32 2003
  #
  # use Date::Language;
  # my $turkish = Date::Language->new('Turkish');
  # print $turkish->time2str("%e %b %Y, %a %T\n", time);
  # print $turkish->str2time("25 Haz 1996 21:09:55 +0100");
  #----------------------------------------------------#
  
  package Date::Language::Turkish;
  use Date::Language ();
  use vars qw(@ISA @DoW @DoWs @MoY @MoYs @AMPM @Dsuf %MoY %DoW $VERSION %DsufMAP);
  @ISA     = qw(Date::Language);
  $VERSION = "1.0";
  
  @DoW = qw(Pazar Pazartesi Salý Çarþamba Perþembe Cuma Cumartesi);
  @MoY = qw(Ocak Þubat Mart  Nisan Mayýs Haziran Temmuz Aðustos Eylül Ekim Kasým Aralýk);
  @DoWs     = map { substr($_,0,3) } @DoW;
  $DoWs[1]  = 'Pzt'; # Since we'll get two 'Paz' s
  $DoWs[-1] = 'Cmt'; # Since we'll get two 'Cum' s
  @MoYs     = map { substr($_,0,3) } @MoY;
  @AMPM     = ('',''); # no am-pm thingy
  
  # not easy as in english... maybe we can just use a dot "." ? :)
  %DsufMAP = (
  (map {$_ => 'inci', $_+10 => 'inci', $_+20 => 'inci' } 1,2,5,8 ),
  (map {$_ =>  'nci', $_+10 =>  'nci', $_+20 =>  'nci' } 7       ),
  (map {$_ =>  'nci', $_+10 =>  'nci', $_+20 =>  'nci' } 2       ),
  (map {$_ => 'üncü', $_+10 => 'üncü', $_+20 => 'üncü' } 3,4     ),
  (map {$_ => 'uncu', $_+10 => 'uncu', $_+20 => 'uncu' } 9       ),
  (map {$_ =>  'ncý', $_+10 =>  'ncý', $_+20 =>  'ncý' } 6       ),
  (map {$_ => 'uncu',                                  } 10,30   ),
        20 =>  'nci',
        31 => 'inci',
  );
  
  @Dsuf       = map{ $DsufMAP{$_} } sort {$a <=> $b} keys %DsufMAP;
  @MoY{@MoY}  = (0 .. scalar(@MoY));
  @MoY{@MoYs} = (0 .. scalar(@MoYs));
  @DoW{@DoW}  = (0 .. scalar(@DoW));
  @DoW{@DoWs} = (0 .. scalar(@DoWs));
  
  # Formatting routines
  
  sub format_a { $DoWs[$_[0]->[6]] }
  sub format_A { $DoW[ $_[0]->[6]] }
  sub format_b { $MoYs[$_[0]->[4]] }
  sub format_B { $MoY[ $_[0]->[4]] }
  sub format_h { $MoYs[$_[0]->[4]] }
  sub format_p { '' } # disable
  sub format_P { '' } # disable
  sub format_o { sprintf("%2d%s",$_[0]->[3],$Dsuf[$_[0]->[3]-1]) }
  
  1;
  
  __END__
DATE_LANGUAGE_TURKISH

$fatpacked{"Date/Parse.pm"} = <<'DATE_PARSE';
  # Copyright (c) 1995-2009 Graham Barr. This program is free
  # software; you can redistribute it and/or modify it under the same terms
  # as Perl itself.
  
  package Date::Parse;
  
  require 5.000;
  use strict;
  use vars qw($VERSION @ISA @EXPORT);
  use Time::Local;
  use Carp;
  use Time::Zone;
  use Exporter;
  
  @ISA = qw(Exporter);
  @EXPORT = qw(&strtotime &str2time &strptime);
  
  $VERSION = "2.30";
  
  my %month = (
  	january		=> 0,
  	february	=> 1,
  	march		=> 2,
  	april		=> 3,
  	may		=> 4,
  	june		=> 5,
  	july		=> 6,
  	august		=> 7,
  	september	=> 8,
  	sept		=> 8,
  	october		=> 9,
  	november	=> 10,
  	december	=> 11,
  	);
  
  my %day = (
  	sunday		=> 0,
  	monday		=> 1,
  	tuesday		=> 2,
  	tues		=> 2,
  	wednesday	=> 3,
  	wednes		=> 3,
  	thursday	=> 4,
  	thur		=> 4,
  	thurs		=> 4,
  	friday		=> 5,
  	saturday	=> 6,
  	);
  
  my @suf = (qw(th st nd rd th th th th th th)) x 3;
  @suf[11,12,13] = qw(th th th);
  
  #Abbreviations
  
  map { $month{substr($_,0,3)} = $month{$_} } keys %month;
  map { $day{substr($_,0,3)}   = $day{$_} }   keys %day;
  
  my $strptime = <<'ESQ';
   my %month = map { lc $_ } %$mon_ref;
   my $daypat = join("|", map { lc $_ } reverse sort keys %$day_ref);
   my $monpat = join("|", reverse sort keys %month);
   my $sufpat = join("|", reverse sort map { lc $_ } @$suf_ref);
  
   my %ampm = (
  	'a' => 0,  # AM
  	'p' => 12, # PM
  	);
  
   my($AM, $PM) = (0,12);
  
  sub {
  
    my $dtstr = lc shift;
    my $merid = 24;
  
    my($year,$month,$day,$hh,$mm,$ss,$zone,$dst,$frac);
  
    $zone = tz_offset(shift) if @_;
  
    1 while $dtstr =~ s#\([^\(\)]*\)# #o;
  
    $dtstr =~ s#(\A|\n|\Z)# #sog;
  
    # ignore day names
    $dtstr =~ s#([\d\w\s])[\.\,]\s#$1 #sog;
    $dtstr =~ s/,/ /g;
    $dtstr =~ s#($daypat)\s*(den\s)?\b# #o;
    # Time: 12:00 or 12:00:00 with optional am/pm
  
    return unless $dtstr =~ /\S/;
    
    if ($dtstr =~ s/\s(\d{4})([-:]?)(\d\d?)\2(\d\d?)(?:[-Tt ](\d\d?)(?:([-:]?)(\d\d?)(?:\6(\d\d?)(?:[.,](\d+))?)?)?)?(?=\D)/ /) {
      ($year,$month,$day,$hh,$mm,$ss,$frac) = ($1,$3-1,$4,$5,$7,$8,$9);
    }
  
    unless (defined $hh) {
      if ($dtstr =~ s#[:\s](\d\d?):(\d\d?)(:(\d\d?)(?:\.\d+)?)?(z)?\s*(?:([ap])\.?m?\.?)?\s# #o) {
        ($hh,$mm,$ss) = ($1,$2,$4);
        $zone = 0 if $5;
        $merid = $ampm{$6} if $6;
      }
  
      # Time: 12 am
      
      elsif ($dtstr =~ s#\s(\d\d?)\s*([ap])\.?m?\.?\s# #o) {
        ($hh,$mm,$ss) = ($1,0,0);
        $merid = $ampm{$2};
      }
    }
      
    if (defined $hh and $hh <= 12 and $dtstr =~ s# ([ap])\.?m?\.?\s# #o) {
      $merid = $ampm{$1};
    }
  
  
    unless (defined $year) {
      # Date: 12-June-96 (using - . or /)
      
      if ($dtstr =~ s#\s(\d\d?)([\-\./])($monpat)(\2(\d\d+))?\s# #o) {
        ($month,$day) = ($month{$3},$1);
        $year = $5 if $5;
      }
      
      # Date: 12-12-96 (using '-', '.' or '/' )
      
      elsif ($dtstr =~ s#\s(\d+)([\-\./])(\d\d?)(\2(\d+))?\s# #o) {
        ($month,$day) = ($1 - 1,$3);
  
        if ($5) {
  	$year = $5;
  	# Possible match for 1995-01-24 (short mainframe date format);
  	($year,$month,$day) = ($1, $3 - 1, $5) if $month > 12;
  	return if length($year) > 2 and $year < 1901;
        }
      }
      elsif ($dtstr =~ s#\s(\d+)\s*($sufpat)?\s*($monpat)# #o) {
        ($month,$day) = ($month{$3},$1);
      }
      elsif ($dtstr =~ s#($monpat)\s*(\d+)\s*($sufpat)?\s# #o) {
        ($month,$day) = ($month{$1},$2);
      }
      elsif ($dtstr =~ s#($monpat)([\/-])(\d+)[\/-]# #o) {
        ($month,$day) = ($month{$1},$3);
      }
  
      # Date: 961212
  
      elsif ($dtstr =~ s#\s(\d\d)(\d\d)(\d\d)\s# #o) {
        ($year,$month,$day) = ($1,$2-1,$3);
      }
  
      $year = $1 if !defined($year) and $dtstr =~ s#\s(\d{2}(\d{2})?)[\s\.,]# #o;
  
    }
  
    # Zone
  
    $dst = 1 if $dtstr =~ s#\bdst\b##o;
  
    if ($dtstr =~ s#\s"?([a-z]{3,4})(dst|\d+[a-z]*|_[a-z]+)?"?\s# #o) {
      $dst = 1 if $2 and $2 eq 'dst';
      $zone = tz_offset($1);
      return unless defined $zone;
    }
    elsif ($dtstr =~ s#\s([a-z]{3,4})?([\-\+]?)-?(\d\d?):?(\d\d)?(00)?\s# #o) {
      my $m = defined($4) ? "$2$4" : 0;
      my $h = "$2$3";
      $zone = defined($1) ? tz_offset($1) : 0;
      return unless defined $zone;
      $zone += 60 * ($m + (60 * $h));
    }
  
    if ($dtstr =~ /\S/) {
      # now for some dumb dates
      if ($dtstr =~ s/^\s*(ut?|z)\s*$//) {
        $zone = 0;
      }
      elsif ($dtstr =~ s#\s([a-z]{3,4})?([\-\+]?)-?(\d\d?)(\d\d)?(00)?\s# #o) {
        my $m = defined($4) ? "$2$4" : 0;
        my $h = "$2$3";
        $zone = defined($1) ? tz_offset($1) : 0;
        return unless defined $zone;
        $zone += 60 * ($m + (60 * $h));
      }
  
      return if $dtstr =~ /\S/o;
    }
  
    if (defined $hh) {
      if ($hh == 12) {
        $hh = 0 if $merid == $AM;
      }
      elsif ($merid == $PM) {
        $hh += 12;
      }
    }
  
    $year -= 1900 if defined $year && $year > 1900;
  
    $zone += 3600 if defined $zone && $dst;
    $ss += "0.$frac" if $frac;
  
    return ($ss,$mm,$hh,$day,$month,$year,$zone);
  }
  ESQ
  
  use vars qw($day_ref $mon_ref $suf_ref $obj);
  
  sub gen_parser
  {
   local($day_ref,$mon_ref,$suf_ref,$obj) = @_;
  
   if($obj)
    {
     my $obj_strptime = $strptime;
     substr($obj_strptime,index($strptime,"sub")+6,0) = <<'ESQ';
   shift; # package
  ESQ
     my $sub = eval "$obj_strptime" or die $@;
     return $sub;
    }
  
   eval "$strptime" or die $@;
  
  }
  
  *strptime = gen_parser(\%day,\%month,\@suf);
  
  sub str2time
  {
   my @t = strptime(@_);
  
   return undef
  	unless @t;
  
   my($ss,$mm,$hh,$day,$month,$year,$zone) = @t;
   my @lt  = localtime(time);
  
   $hh    ||= 0;
   $mm    ||= 0;
   $ss    ||= 0;
  
   my $frac = $ss - int($ss);
   $ss = int $ss;
  
   $month = $lt[4]
  	unless(defined $month);
  
   $day  = $lt[3]
  	unless(defined $day);
  
   $year = ($month > $lt[4]) ? ($lt[5] - 1) : $lt[5]
  	unless(defined $year);
  
   return undef
  	unless($month <= 11 && $day >= 1 && $day <= 31
  		&& $hh <= 23 && $mm <= 59 && $ss <= 59);
  
   my $result;
  
   if (defined $zone) {
     $result = eval {
       local $SIG{__DIE__} = sub {}; # Ick!
       timegm($ss,$mm,$hh,$day,$month,$year);
     };
     return undef
       if !defined $result
          or $result == -1
             && join("",$ss,$mm,$hh,$day,$month,$year)
       	        ne "595923311169";
     $result -= $zone;
   }
   else {
     $result = eval {
       local $SIG{__DIE__} = sub {}; # Ick!
       timelocal($ss,$mm,$hh,$day,$month,$year);
     };
     return undef
       if !defined $result
          or $result == -1
             && join("",$ss,$mm,$hh,$day,$month,$year)
       	        ne join("",(localtime(-1))[0..5]);
   }
  
   return $result + $frac;
  }
  
  1;
  
  __END__
  
  
  =head1 NAME
  
  Date::Parse - Parse date strings into time values
  
  =head1 SYNOPSIS
  
  	use Date::Parse;
  	
  	$time = str2time($date);
  	
  	($ss,$mm,$hh,$day,$month,$year,$zone) = strptime($date);
  
  =head1 DESCRIPTION
  
  C<Date::Parse> provides two routines for parsing date strings into time values.
  
  =over 4
  
  =item str2time(DATE [, ZONE])
  
  C<str2time> parses C<DATE> and returns a unix time value, or undef upon failure.
  C<ZONE>, if given, specifies the timezone to assume when parsing if the
  date string does not specify a timezone.
  
  =item strptime(DATE [, ZONE])
  
  C<strptime> takes the same arguments as str2time but returns an array of
  values C<($ss,$mm,$hh,$day,$month,$year,$zone)>. Elements are only defined
  if they could be extracted from the date string. The C<$zone> element is
  the timezone offset in seconds from GMT. An empty array is returned upon
  failure.
  
  =head1 MULTI-LANGUAGE SUPPORT
  
  Date::Parse is capable of parsing dates in several languages, these include
  English, French, German and Italian.
  
  	$lang = Date::Language->new('German');
  	$lang->str2time("25 Jun 1996 21:09:55 +0100");
  
  =head1 EXAMPLE DATES
  
  Below is a sample list of dates that are known to be parsable with Date::Parse
  
   1995:01:24T09:08:17.1823213           ISO-8601
   1995-01-24T09:08:17.1823213
   Wed, 16 Jun 94 07:29:35 CST           Comma and day name are optional 
   Thu, 13 Oct 94 10:13:13 -0700
   Wed, 9 Nov 1994 09:50:32 -0500 (EST)  Text in ()'s will be ignored.
   21 dec 17:05                          Will be parsed in the current time zone
   21-dec 17:05
   21/dec 17:05
   21/dec/93 17:05
   1999 10:02:18 "GMT"
   16 Nov 94 22:28:20 PST 
  
  =head1 LIMITATION
  
  Date::Parse uses L<Time::Local> internally, so is limited to only parsing dates
  which result in valid values for Time::Local::timelocal. This generally means dates
  between 1901-12-17 00:00:00 GMT and 2038-01-16 23:59:59 GMT
  
  =head1 BUGS
  
  When both the month and the date are specified in the date as numbers
  they are always parsed assuming that the month number comes before the
  date. This is the usual format used in American dates.
  
  The reason why it is like this and not dynamic is that it must be
  deterministic. Several people have suggested using the current locale,
  but this will not work as the date being parsed may not be in the format
  of the current locale.
  
  My plans to address this, which will be in a future release, is to allow
  the programmer to state what order they want these values parsed in.
  
  =head1 AUTHOR
  
  Graham Barr <gbarr@pobox.com>
  
  =head1 COPYRIGHT
  
  Copyright (c) 1995-2009 Graham Barr. This program is free
  software; you can redistribute it and/or modify it under the same terms
  as Perl itself.
  
  =cut
  
DATE_PARSE

$fatpacked{"Date/Tiny.pm"} = <<'DATE_TINY';
  package Date::Tiny;
  
  =pod
  
  =head1 NAME
  
  Date::Tiny - A date object with as little code as possible
  
  =head1 SYNOPSIS
  
    # Create a date manually
    $christmas = Date::Tiny->new(
        year  => 2006,
        month => 12,
        day   => 25,
        );
    
    # Show the current date
    $today = Date::Tiny->now;
    print "Year : " . $today->year  . "\n";
    print "Month: " . $today->month . "\n";
    print "Day  : " . $today->day   . "\n"; 
  
  =head1 DESCRIPTION
  
  B<Date::Tiny> is a member of the L<DateTime::Tiny> suite of time modules.
  
  It implements an extremely lightweight object that represents a date,
  without any time data.
  
  =head2 The Tiny Mandate
  
  Many CPAN modules which provide the best implementation of a concept
  can be very large. For some reason, this generally seems to be about
  3 megabyte of ram usage to load the module.
  
  For a lot of the situations in which these large and comprehensive
  implementations exist, some people will only need a small fraction of the
  functionality, or only need this functionality in an ancillary role.
  
  The aim of the Tiny modules is to implement an alternative to the large
  module that implements a subset of the functionality, using as little
  code as possible.
  
  Typically, this means a module that implements between 50% and 80% of
  the features of the larger module, but using only 100 kilobytes of code,
  which is about 1/30th of the larger module.
  
  =head2 The Concept of Tiny Date and Time
  
  Due to the inherent complexity, Date and Time is intrinsically very
  difficult to implement properly.
  
  The arguably B<only> module to implement it completely correct is
  L<DateTime>. However, to implement it properly L<DateTime> is quite slow
  and requires 3-4 megabytes of memory to load.
  
  The challenge in implementing a Tiny equivalent to DateTime is to do so
  without making the functionality critically flawed, and to carefully
  select the subset of functionality to implement.
  
  If you look at where the main complexity and cost exists, you will find
  that it is relatively cheap to represent a date or time as an object,
  but much much more expensive to modify or convert the object.
  
  As a result, B<Date::Tiny> provides the functionality required to
  represent a date as an object, to stringify the date and to parse it
  back in, but does B<not> allow you to modify the dates.
  
  The purpose of this is to allow for date object representations in
  situations like log parsing and fast real-time work.
  
  The problem with this is that having no ability to modify date limits
  the usefulness greatly.
  
  To make up for this, B<if> you have L<DateTime> installed, any
  B<Date::Tiny> module can be inflated into the equivalent L<DateTime>
  as needing, loading L<DateTime> on the fly if necesary.
  
  For the purposes of date/time logic, all B<Date::Tiny> objects exist
  in the "C" locale, and the "floating" time zone (although obviously in a
  pure date context, the time zone largely doesn't matter).
  
  When converting up to full L<DateTime> objects, these local and time
  zone settings will be applied (although an ability is provided to
  override this).
  
  In addition, the implementation is strictly correct and is intended to
  be very easily to sub-class for specific purposes of your own.
  
  =head1 METHODS
  
  In general, the intent is that the API be as close as possible to the
  API for L<DateTime>. Except, of course, that this module implements
  less of it.
  
  =cut
  
  use strict;
  BEGIN {
  	require 5.004;
  	$Date::Tiny::VERSION = '1.04';
  }
  use overload 'bool' => sub () { 1 };
  use overload '""'   => 'as_string';
  use overload 'eq'   => sub { "$_[0]" eq "$_[1]" };
  use overload 'ne'   => sub { "$_[0]" ne "$_[1]" };
  
  
  
  
  
  #####################################################################
  # Constructor and Accessors
  
  =pod
  
  =head2 new
  
    my $date = Date::Tiny->new(
        year  => 2006,
        month => 12,
        day   => 31,
        );
  
  The C<new> constructor creates a new B<Date::Tiny> object.
  
  It takes three named params. C<day> should be the day of the month (1-31),
  C<month> should be the month of the year (1-12), C<year> as a 4 digit year.
  
  These are the only params accepted.
  
  Returns a new B<Date::Tiny> object.
  
  =cut
  
  sub new {
  	my $class = shift;
  	bless { @_ }, $class;
  }
  
  =pod
  
  =head2 now
  
    my $current_date = Date::Tiny->now;
  
  The C<now> method creates a new date object for the current date.
  
  The date created will be based on localtime, despite the fact that
  the date is created in the floating time zone.
  
  Returns a new B<Date::Tiny> object.
  
  =cut
  
  sub now {
  	my @t = localtime time;
  	shift->new(
  		year  => $t[5] + 1900,
  		month => $t[4] + 1,
  		day   => $t[3],
  	);
  }
  
  =pod
  
  =head2 year
  
  The C<year> accessor returns the 4-digit year for the date.
  
  =cut
  
  sub year {
  	$_[0]->{year};
  }
  
  =pod
  
  =head2 month
  
  The C<month> accessor returns the 1-12 month of the year for the date.
  
  =cut
  
  sub month {
  	$_[0]->{month};
  }
  
  =pod
  
  =head2 day
  
  The C<day> accessor returns the 1-31 day of the month for the date.
  
  =cut
  
  sub day {
  	$_[0]->{day};
  }
  
  =pod
  
  =head2 ymd
  
  The C<ymd> method returns the most common and accurate stringified date
  format, which returns in the form "2006-04-12".
  
  =cut
  
  sub ymd {
  	sprintf( "%04u-%02u-%02u",
  		$_[0]->year,
  		$_[0]->month,
  		$_[0]->day,
  	);
  }
  
  
  
  
  
  #####################################################################
  # Type Conversion
  
  =pod
  
  =head2 as_string
  
  The C<as_string> method converts the date to the default string, which
  at present is the same as that returned by the C<ymd> method above.
  
  This string matches the ISO 8601 standard for the encoding of a date as
  a string.
  
  =cut
  
  sub as_string {
  	$_[0]->ymd;
  }
  
  =pod
  
  =head2 from_string
  
  The C<from_string> method creates a new B<Date::Tiny> object from a string.
  
  The string is expected to be a "yyyy-mm-dd" ISO 8601 time string.
  
    my $almost_christmas = Date::Tiny->from_string( '2006-12-23' );
  
  Returns a new B<Date::Tiny> object, or throws an exception on error.
  
  =cut
  
  sub from_string {
  	my $string = $_[1];
  	unless ( defined $string and ! ref $string ) {
  		Carp::croak("Did not provide a string to from_string");
  	}
  	unless ( $string =~ /^(\d\d\d\d)-(\d\d)-(\d\d)$/ ) {
  		Carp::croak("Invalid time format (does not match ISO 8601 yyyy-mm-dd)");
  	}
  	$_[0]->new(
  		year  => $1 + 0,
  		month => $2 + 0,
  		day   => $3 + 0,
  	);
  }
  
  =pod
  
  =head2 DateTime
  
  The C<DateTime> method is used to create a L<DateTime> object
  that is equivalent to the B<Date::Tiny> object, for use in
  comversions and caluculations.
  
  As mentioned earlier, the object will be set to the 'C' locate,
  and the 'floating' time zone.
  
  If installed, the L<DateTime> module will be loaded automatically.
  
  Returns a L<DateTime> object, or throws an exception if L<DateTime>
  is not installed on the current host.
  
  =cut
  
  sub DateTime {
  	require DateTime;
  	my $self = shift;
  	DateTime->new(
  		day       => $self->day,
  		month     => $self->month,
  		year      => $self->year,
  		locale    => 'C',
  		time_zone => 'floating',
  		@_,
  	);
  }
  
  1;
  
  =pod
  
  =head1 SUPPORT
  
  Bugs should be reported via the CPAN bug tracker at
  
  L<http://rt.cpan.org/NoAuth/ReportBug.html?Queue=Date-Tiny>
  
  For other issues, or commercial enhancement or support, contact the author.
  
  =head1 AUTHOR
  
  Adam Kennedy E<lt>adamk@cpan.orgE<gt>
  
  =head1 SEE ALSO
  
  L<DateTime>, L<DateTime::Tiny>, L<Time::Tiny>, L<Config::Tiny>, L<ali.as>
  
  =head1 COPYRIGHT
  
  Copyright 2006 - 2009 Adam Kennedy.
  
  This program is free software; you can redistribute
  it and/or modify it under the same terms as Perl itself.
  
  The full text of the license can be found in the
  LICENSE file included with this module.
  
  =cut
DATE_TINY

$fatpacked{"Error.pm"} = <<'ERROR';
  # Error.pm
  #
  # Copyright (c) 1997-8 Graham Barr <gbarr@ti.com>. All rights reserved.
  # This program is free software; you can redistribute it and/or
  # modify it under the same terms as Perl itself.
  #
  # Based on my original Error.pm, and Exceptions.pm by Peter Seibel
  # <peter@weblogic.com> and adapted by Jesse Glick <jglick@sig.bsh.com>.
  #
  # but modified ***significantly***
  
  package Error;
  
  use strict;
  use vars qw($VERSION);
  use 5.004;
  
  $VERSION = "0.17016"; 
  
  use overload (
  	'""'	   =>	'stringify',
  	'0+'	   =>	'value',
  	'bool'     =>	sub { return 1; },
  	'fallback' =>	1
  );
  
  $Error::Depth = 0;	# Depth to pass to caller()
  $Error::Debug = 0;	# Generate verbose stack traces
  @Error::STACK = ();	# Clause stack for try
  $Error::THROWN = undef;	# last error thrown, a workaround until die $ref works
  
  my $LAST;		# Last error created
  my %ERROR;		# Last error associated with package
  
  sub _throw_Error_Simple
  {
      my $args = shift;
      return Error::Simple->new($args->{'text'});
  }
  
  $Error::ObjectifyCallback = \&_throw_Error_Simple;
  
  
  # Exported subs are defined in Error::subs
  
  use Scalar::Util ();
  
  sub import {
      shift;
      my @tags = @_;
      local $Exporter::ExportLevel = $Exporter::ExportLevel + 1;
      
      @tags = grep { 
         if( $_ eq ':warndie' ) {
            Error::WarnDie->import();
            0;
         }
         else {
            1;
         }
      } @tags;
  
      Error::subs->import(@tags);
  }
  
  # I really want to use last for the name of this method, but it is a keyword
  # which prevent the syntax  last Error
  
  sub prior {
      shift; # ignore
  
      return $LAST unless @_;
  
      my $pkg = shift;
      return exists $ERROR{$pkg} ? $ERROR{$pkg} : undef
  	unless ref($pkg);
  
      my $obj = $pkg;
      my $err = undef;
      if($obj->isa('HASH')) {
  	$err = $obj->{'__Error__'}
  	    if exists $obj->{'__Error__'};
      }
      elsif($obj->isa('GLOB')) {
  	$err = ${*$obj}{'__Error__'}
  	    if exists ${*$obj}{'__Error__'};
      }
  
      $err;
  }
  
  sub flush {
      shift; #ignore
      
      unless (@_) {
         $LAST = undef;
         return;
      }
      
      my $pkg = shift;
      return unless ref($pkg);
     
      undef $ERROR{$pkg} if defined $ERROR{$pkg}; 
  } 
  
  # Return as much information as possible about where the error
  # happened. The -stacktrace element only exists if $Error::DEBUG
  # was set when the error was created
  
  sub stacktrace {
      my $self = shift;
  
      return $self->{'-stacktrace'}
  	if exists $self->{'-stacktrace'};
  
      my $text = exists $self->{'-text'} ? $self->{'-text'} : "Died";
  
      $text .= sprintf(" at %s line %d.\n", $self->file, $self->line)
  	unless($text =~ /\n$/s);
  
      $text;
  }
  
  
  sub associate {
      my $err = shift;
      my $obj = shift;
  
      return unless ref($obj);
  
      if($obj->isa('HASH')) {
  	$obj->{'__Error__'} = $err;
      }
      elsif($obj->isa('GLOB')) {
  	${*$obj}{'__Error__'} = $err;
      }
      $obj = ref($obj);
      $ERROR{ ref($obj) } = $err;
  
      return;
  }
  
  
  sub new {
      my $self = shift;
      my($pkg,$file,$line) = caller($Error::Depth);
  
      my $err = bless {
  	'-package' => $pkg,
  	'-file'    => $file,
  	'-line'    => $line,
  	@_
      }, $self;
  
      $err->associate($err->{'-object'})
  	if(exists $err->{'-object'});
  
      # To always create a stacktrace would be very inefficient, so
      # we only do it if $Error::Debug is set
  
      if($Error::Debug) {
  	require Carp;
  	local $Carp::CarpLevel = $Error::Depth;
  	my $text = defined($err->{'-text'}) ? $err->{'-text'} : "Error";
  	my $trace = Carp::longmess($text);
  	# Remove try calls from the trace
  	$trace =~ s/(\n\s+\S+__ANON__[^\n]+)?\n\s+eval[^\n]+\n\s+Error::subs::try[^\n]+(?=\n)//sog;
  	$trace =~ s/(\n\s+\S+__ANON__[^\n]+)?\n\s+eval[^\n]+\n\s+Error::subs::run_clauses[^\n]+\n\s+Error::subs::try[^\n]+(?=\n)//sog;
  	$err->{'-stacktrace'} = $trace
      }
  
      $@ = $LAST = $ERROR{$pkg} = $err;
  }
  
  # Throw an error. this contains some very gory code.
  
  sub throw {
      my $self = shift;
      local $Error::Depth = $Error::Depth + 1;
  
      # if we are not rethrow-ing then create the object to throw
      $self = $self->new(@_) unless ref($self);
      
      die $Error::THROWN = $self;
  }
  
  # syntactic sugar for
  #
  #    die with Error( ... );
  
  sub with {
      my $self = shift;
      local $Error::Depth = $Error::Depth + 1;
  
      $self->new(@_);
  }
  
  # syntactic sugar for
  #
  #    record Error( ... ) and return;
  
  sub record {
      my $self = shift;
      local $Error::Depth = $Error::Depth + 1;
  
      $self->new(@_);
  }
  
  # catch clause for
  #
  # try { ... } catch CLASS with { ... }
  
  sub catch {
      my $pkg = shift;
      my $code = shift;
      my $clauses = shift || {};
      my $catch = $clauses->{'catch'} ||= [];
  
      unshift @$catch,  $pkg, $code;
  
      $clauses;
  }
  
  # Object query methods
  
  sub object {
      my $self = shift;
      exists $self->{'-object'} ? $self->{'-object'} : undef;
  }
  
  sub file {
      my $self = shift;
      exists $self->{'-file'} ? $self->{'-file'} : undef;
  }
  
  sub line {
      my $self = shift;
      exists $self->{'-line'} ? $self->{'-line'} : undef;
  }
  
  sub text {
      my $self = shift;
      exists $self->{'-text'} ? $self->{'-text'} : undef;
  }
  
  # overload methods
  
  sub stringify {
      my $self = shift;
      defined $self->{'-text'} ? $self->{'-text'} : "Died";
  }
  
  sub value {
      my $self = shift;
      exists $self->{'-value'} ? $self->{'-value'} : undef;
  }
  
  package Error::Simple;
  
  @Error::Simple::ISA = qw(Error);
  
  sub new {
      my $self  = shift;
      my $text  = "" . shift;
      my $value = shift;
      my(@args) = ();
  
      local $Error::Depth = $Error::Depth + 1;
  
      @args = ( -file => $1, -line => $2)
  	if($text =~ s/\s+at\s+(\S+)\s+line\s+(\d+)(?:,\s*<[^>]*>\s+line\s+\d+)?\.?\n?$//s);
      push(@args, '-value', 0 + $value)
  	if defined($value);
  
      $self->SUPER::new(-text => $text, @args);
  }
  
  sub stringify {
      my $self = shift;
      my $text = $self->SUPER::stringify;
      $text .= sprintf(" at %s line %d.\n", $self->file, $self->line)
  	unless($text =~ /\n$/s);
      $text;
  }
  
  ##########################################################################
  ##########################################################################
  
  # Inspired by code from Jesse Glick <jglick@sig.bsh.com> and
  # Peter Seibel <peter@weblogic.com>
  
  package Error::subs;
  
  use Exporter ();
  use vars qw(@EXPORT_OK @ISA %EXPORT_TAGS);
  
  @EXPORT_OK   = qw(try with finally except otherwise);
  %EXPORT_TAGS = (try => \@EXPORT_OK);
  
  @ISA = qw(Exporter);
  
  sub run_clauses ($$$\@) {
      my($clauses,$err,$wantarray,$result) = @_;
      my $code = undef;
  
      $err = $Error::ObjectifyCallback->({'text' =>$err}) unless ref($err);
  
      CATCH: {
  
  	# catch
  	my $catch;
  	if(defined($catch = $clauses->{'catch'})) {
  	    my $i = 0;
  
  	    CATCHLOOP:
  	    for( ; $i < @$catch ; $i += 2) {
  		my $pkg = $catch->[$i];
  		unless(defined $pkg) {
  		    #except
  		    splice(@$catch,$i,2,$catch->[$i+1]->($err));
  		    $i -= 2;
  		    next CATCHLOOP;
  		}
  		elsif(Scalar::Util::blessed($err) && $err->isa($pkg)) {
  		    $code = $catch->[$i+1];
  		    while(1) {
  			my $more = 0;
  			local($Error::THROWN, $@);
  			my $ok = eval {
  			    $@ = $err;
  			    if($wantarray) {
  				@{$result} = $code->($err,\$more);
  			    }
  			    elsif(defined($wantarray)) {
  			        @{$result} = ();
  				$result->[0] = $code->($err,\$more);
  			    }
  			    else {
  				$code->($err,\$more);
  			    }
  			    1;
  			};
  			if( $ok ) {
  			    next CATCHLOOP if $more;
  			    undef $err;
  			}
  			else {
  			    $err = $@ || $Error::THROWN;
  				$err = $Error::ObjectifyCallback->({'text' =>$err})
  					unless ref($err);
  			}
  			last CATCH;
  		    };
  		}
  	    }
  	}
  
  	# otherwise
  	my $owise;
  	if(defined($owise = $clauses->{'otherwise'})) {
  	    my $code = $clauses->{'otherwise'};
  	    my $more = 0;
          local($Error::THROWN, $@);
  	    my $ok = eval {
  		$@ = $err;
  		if($wantarray) {
  		    @{$result} = $code->($err,\$more);
  		}
  		elsif(defined($wantarray)) {
  		    @{$result} = ();
  		    $result->[0] = $code->($err,\$more);
  		}
  		else {
  		    $code->($err,\$more);
  		}
  		1;
  	    };
  	    if( $ok ) {
  		undef $err;
  	    }
  	    else {
  		$err = $@ || $Error::THROWN;
  
  		$err = $Error::ObjectifyCallback->({'text' =>$err}) 
  			unless ref($err);
  	    }
  	}
      }
      $err;
  }
  
  sub try (&;$) {
      my $try = shift;
      my $clauses = @_ ? shift : {};
      my $ok = 0;
      my $err = undef;
      my @result = ();
  
      unshift @Error::STACK, $clauses;
  
      my $wantarray = wantarray();
  
      do {
  	local $Error::THROWN = undef;
  	local $@ = undef;
  
  	$ok = eval {
  	    if($wantarray) {
  		@result = $try->();
  	    }
  	    elsif(defined $wantarray) {
  		$result[0] = $try->();
  	    }
  	    else {
  		$try->();
  	    }
  	    1;
  	};
  
  	$err = $@ || $Error::THROWN
  	    unless $ok;
      };
  
      shift @Error::STACK;
  
      $err = run_clauses($clauses,$err,wantarray,@result)
      unless($ok);
  
      $clauses->{'finally'}->()
  	if(defined($clauses->{'finally'}));
  
      if (defined($err))
      {
          if (Scalar::Util::blessed($err) && $err->can('throw'))
          {
              throw $err;
          }
          else
          {
              die $err;
          }
      }
  
      wantarray ? @result : $result[0];
  }
  
  # Each clause adds a sub to the list of clauses. The finally clause is
  # always the last, and the otherwise clause is always added just before
  # the finally clause.
  #
  # All clauses, except the finally clause, add a sub which takes one argument
  # this argument will be the error being thrown. The sub will return a code ref
  # if that clause can handle that error, otherwise undef is returned.
  #
  # The otherwise clause adds a sub which unconditionally returns the users
  # code reference, this is why it is forced to be last.
  #
  # The catch clause is defined in Error.pm, as the syntax causes it to
  # be called as a method
  
  sub with (&;$) {
      @_
  }
  
  sub finally (&) {
      my $code = shift;
      my $clauses = { 'finally' => $code };
      $clauses;
  }
  
  # The except clause is a block which returns a hashref or a list of
  # key-value pairs, where the keys are the classes and the values are subs.
  
  sub except (&;$) {
      my $code = shift;
      my $clauses = shift || {};
      my $catch = $clauses->{'catch'} ||= [];
      
      my $sub = sub {
  	my $ref;
  	my(@array) = $code->($_[0]);
  	if(@array == 1 && ref($array[0])) {
  	    $ref = $array[0];
  	    $ref = [ %$ref ]
  		if(UNIVERSAL::isa($ref,'HASH'));
  	}
  	else {
  	    $ref = \@array;
  	}
  	@$ref
      };
  
      unshift @{$catch}, undef, $sub;
  
      $clauses;
  }
  
  sub otherwise (&;$) {
      my $code = shift;
      my $clauses = shift || {};
  
      if(exists $clauses->{'otherwise'}) {
  	require Carp;
  	Carp::croak("Multiple otherwise clauses");
      }
  
      $clauses->{'otherwise'} = $code;
  
      $clauses;
  }
  
  1;
  
  package Error::WarnDie;
  
  sub gen_callstack($)
  {
      my ( $start ) = @_;
  
      require Carp;
      local $Carp::CarpLevel = $start;
      my $trace = Carp::longmess("");
      # Remove try calls from the trace
      $trace =~ s/(\n\s+\S+__ANON__[^\n]+)?\n\s+eval[^\n]+\n\s+Error::subs::try[^\n]+(?=\n)//sog;
      $trace =~ s/(\n\s+\S+__ANON__[^\n]+)?\n\s+eval[^\n]+\n\s+Error::subs::run_clauses[^\n]+\n\s+Error::subs::try[^\n]+(?=\n)//sog;
      my @callstack = split( m/\n/, $trace );
      return @callstack;
  }
  
  my $old_DIE;
  my $old_WARN;
  
  sub DEATH
  {
      my ( $e ) = @_;
  
      local $SIG{__DIE__} = $old_DIE if( defined $old_DIE );
  
      die @_ if $^S;
  
      my ( $etype, $message, $location, @callstack );
      if ( ref($e) && $e->isa( "Error" ) ) {
          $etype = "exception of type " . ref( $e );
          $message = $e->text;
          $location = $e->file . ":" . $e->line;
          @callstack = split( m/\n/, $e->stacktrace );
      }
      else {
          # Don't apply subsequent layer of message formatting
          die $e if( $e =~ m/^\nUnhandled perl error caught at toplevel:\n\n/ );
          $etype = "perl error";
          my $stackdepth = 0;
          while( caller( $stackdepth ) =~ m/^Error(?:$|::)/ ) {
              $stackdepth++
          }
  
          @callstack = gen_callstack( $stackdepth + 1 );
  
          $message = "$e";
          chomp $message;
  
          if ( $message =~ s/ at (.*?) line (\d+)\.$// ) {
              $location = $1 . ":" . $2;
          }
          else {
              my @caller = caller( $stackdepth );
              $location = $caller[1] . ":" . $caller[2];
          }
      }
  
      shift @callstack;
      # Do it this way in case there are no elements; we don't print a spurious \n
      my $callstack = join( "", map { "$_\n"} @callstack );
  
      die "\nUnhandled $etype caught at toplevel:\n\n  $message\n\nThrown from: $location\n\nFull stack trace:\n\n$callstack\n";
  }
  
  sub TAXES
  {
      my ( $message ) = @_;
  
      local $SIG{__WARN__} = $old_WARN if( defined $old_WARN );
  
      $message =~ s/ at .*? line \d+\.$//;
      chomp $message;
  
      my @callstack = gen_callstack( 1 );
      my $location = shift @callstack;
  
      # $location already starts in a leading space
      $message .= $location;
  
      # Do it this way in case there are no elements; we don't print a spurious \n
      my $callstack = join( "", map { "$_\n"} @callstack );
  
      warn "$message:\n$callstack";
  }
  
  sub import
  {
      $old_DIE  = $SIG{__DIE__};
      $old_WARN = $SIG{__WARN__};
  
      $SIG{__DIE__}  = \&DEATH;
      $SIG{__WARN__} = \&TAXES;
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Error - Error/exception handling in an OO-ish way
  
  =head1 WARNING
  
  Using the "Error" module is B<no longer recommended> due to the black-magical
  nature of its syntactic sugar, which often tends to break. Its maintainers 
  have stopped actively writing code that uses it, and discourage people
  from doing so. See the "SEE ALSO" section below for better recommendations.
  
  =head1 SYNOPSIS
  
      use Error qw(:try);
  
      throw Error::Simple( "A simple error");
  
      sub xyz {
          ...
  	record Error::Simple("A simple error")
  	    and return;
      }
   
      unlink($file) or throw Error::Simple("$file: $!",$!);
  
      try {
  	do_some_stuff();
  	die "error!" if $condition;
  	throw Error::Simple "Oops!" if $other_condition;
      }
      catch Error::IO with {
  	my $E = shift;
  	print STDERR "File ", $E->{'-file'}, " had a problem\n";
      }
      except {
  	my $E = shift;
  	my $general_handler=sub {send_message $E->{-description}};
  	return {
  	    UserException1 => $general_handler,
  	    UserException2 => $general_handler
  	};
      }
      otherwise {
  	print STDERR "Well I don't know what to say\n";
      }
      finally {
  	close_the_garage_door_already(); # Should be reliable
      }; # Don't forget the trailing ; or you might be surprised
  
  =head1 DESCRIPTION
  
  The C<Error> package provides two interfaces. Firstly C<Error> provides
  a procedural interface to exception handling. Secondly C<Error> is a
  base class for errors/exceptions that can either be thrown, for
  subsequent catch, or can simply be recorded.
  
  Errors in the class C<Error> should not be thrown directly, but the
  user should throw errors from a sub-class of C<Error>.
  
  =head1 PROCEDURAL INTERFACE
  
  C<Error> exports subroutines to perform exception handling. These will
  be exported if the C<:try> tag is used in the C<use> line.
  
  =over 4
  
  =item try BLOCK CLAUSES
  
  C<try> is the main subroutine called by the user. All other subroutines
  exported are clauses to the try subroutine.
  
  The BLOCK will be evaluated and, if no error is throw, try will return
  the result of the block.
  
  C<CLAUSES> are the subroutines below, which describe what to do in the
  event of an error being thrown within BLOCK.
  
  =item catch CLASS with BLOCK
  
  This clauses will cause all errors that satisfy C<$err-E<gt>isa(CLASS)>
  to be caught and handled by evaluating C<BLOCK>.
  
  C<BLOCK> will be passed two arguments. The first will be the error
  being thrown. The second is a reference to a scalar variable. If this
  variable is set by the catch block then, on return from the catch
  block, try will continue processing as if the catch block was never
  found. The error will also be available in C<$@>.
  
  To propagate the error the catch block may call C<$err-E<gt>throw>
  
  If the scalar reference by the second argument is not set, and the
  error is not thrown. Then the current try block will return with the
  result from the catch block.
  
  =item except BLOCK
  
  When C<try> is looking for a handler, if an except clause is found
  C<BLOCK> is evaluated. The return value from this block should be a
  HASHREF or a list of key-value pairs, where the keys are class names
  and the values are CODE references for the handler of errors of that
  type.
  
  =item otherwise BLOCK
  
  Catch any error by executing the code in C<BLOCK>
  
  When evaluated C<BLOCK> will be passed one argument, which will be the
  error being processed. The error will also be available in C<$@>.
  
  Only one otherwise block may be specified per try block
  
  =item finally BLOCK
  
  Execute the code in C<BLOCK> either after the code in the try block has
  successfully completed, or if the try block throws an error then
  C<BLOCK> will be executed after the handler has completed.
  
  If the handler throws an error then the error will be caught, the
  finally block will be executed and the error will be re-thrown.
  
  Only one finally block may be specified per try block
  
  =back
  
  =head1 COMPATIBILITY
  
  L<Moose> exports a keyword called C<with> which clashes with Error's. This
  example returns a prototype mismatch error:
  
      package MyTest;
  
      use warnings;
      use Moose;
      use Error qw(:try);
  
  (Thanks to C<maik.hentsche@amd.com> for the report.).
  
  =head1 CLASS INTERFACE
  
  =head2 CONSTRUCTORS
  
  The C<Error> object is implemented as a HASH. This HASH is initialized
  with the arguments that are passed to it's constructor. The elements
  that are used by, or are retrievable by the C<Error> class are listed
  below, other classes may add to these.
  
  	-file
  	-line
  	-text
  	-value
  	-object
  
  If C<-file> or C<-line> are not specified in the constructor arguments
  then these will be initialized with the file name and line number where
  the constructor was called from.
  
  If the error is associated with an object then the object should be
  passed as the C<-object> argument. This will allow the C<Error> package
  to associate the error with the object.
  
  The C<Error> package remembers the last error created, and also the
  last error associated with a package. This could either be the last
  error created by a sub in that package, or the last error which passed
  an object blessed into that package as the C<-object> argument.
  
  =over 4
  
  =item Error->new()
  
  See the Error::Simple documentation.
  
  =item throw ( [ ARGS ] )
  
  Create a new C<Error> object and throw an error, which will be caught
  by a surrounding C<try> block, if there is one. Otherwise it will cause
  the program to exit.
  
  C<throw> may also be called on an existing error to re-throw it.
  
  =item with ( [ ARGS ] )
  
  Create a new C<Error> object and returns it. This is defined for
  syntactic sugar, eg
  
      die with Some::Error ( ... );
  
  =item record ( [ ARGS ] )
  
  Create a new C<Error> object and returns it. This is defined for
  syntactic sugar, eg
  
      record Some::Error ( ... )
  	and return;
  
  =back
  
  =head2 STATIC METHODS
  
  =over 4
  
  =item prior ( [ PACKAGE ] )
  
  Return the last error created, or the last error associated with
  C<PACKAGE>
  
  =item flush ( [ PACKAGE ] )
  
  Flush the last error created, or the last error associated with
  C<PACKAGE>.It is necessary to clear the error stack before exiting the
  package or uncaught errors generated using C<record> will be reported.
  
       $Error->flush;
  
  =cut
  
  =back
  
  =head2 OBJECT METHODS
  
  =over 4
  
  =item stacktrace
  
  If the variable C<$Error::Debug> was non-zero when the error was
  created, then C<stacktrace> returns a string created by calling
  C<Carp::longmess>. If the variable was zero the C<stacktrace> returns
  the text of the error appended with the filename and line number of
  where the error was created, providing the text does not end with a
  newline.
  
  =item object
  
  The object this error was associated with
  
  =item file
  
  The file where the constructor of this error was called from
  
  =item line
  
  The line where the constructor of this error was called from
  
  =item text
  
  The text of the error
  
  =item $err->associate($obj)
  
  Associates an error with an object to allow error propagation. I.e:
  
      $ber->encode(...) or
          return Error->prior($ber)->associate($ldap);
  
  =back
  
  =head2 OVERLOAD METHODS
  
  =over 4
  
  =item stringify
  
  A method that converts the object into a string. This method may simply
  return the same as the C<text> method, or it may append more
  information. For example the file name and line number.
  
  By default this method returns the C<-text> argument that was passed to
  the constructor, or the string C<"Died"> if none was given.
  
  =item value
  
  A method that will return a value that can be associated with the
  error. For example if an error was created due to the failure of a
  system call, then this may return the numeric value of C<$!> at the
  time.
  
  By default this method returns the C<-value> argument that was passed
  to the constructor.
  
  =back
  
  =head1 PRE-DEFINED ERROR CLASSES
  
  =head2 Error::Simple
  
  This class can be used to hold simple error strings and values. It's
  constructor takes two arguments. The first is a text value, the second
  is a numeric value. These values are what will be returned by the
  overload methods.
  
  If the text value ends with C<at file line 1> as $@ strings do, then
  this infomation will be used to set the C<-file> and C<-line> arguments
  of the error object.
  
  This class is used internally if an eval'd block die's with an error
  that is a plain string. (Unless C<$Error::ObjectifyCallback> is modified)
  
  
  =head1 $Error::ObjectifyCallback
  
  This variable holds a reference to a subroutine that converts errors that
  are plain strings to objects. It is used by Error.pm to convert textual
  errors to objects, and can be overrided by the user.
  
  It accepts a single argument which is a hash reference to named parameters. 
  Currently the only named parameter passed is C<'text'> which is the text
  of the error, but others may be available in the future.
  
  For example the following code will cause Error.pm to throw objects of the
  class MyError::Bar by default:
  
      sub throw_MyError_Bar
      {
          my $args = shift;
          my $err = MyError::Bar->new();
          $err->{'MyBarText'} = $args->{'text'};
          return $err;
      }
  
      {
          local $Error::ObjectifyCallback = \&throw_MyError_Bar;
  
          # Error handling here.
      }
  
  =cut
  
  =head1 MESSAGE HANDLERS
  
  C<Error> also provides handlers to extend the output of the C<warn()> perl
  function, and to handle the printing of a thrown C<Error> that is not caught
  or otherwise handled. These are not installed by default, but are requested
  using the C<:warndie> tag in the C<use> line.
  
   use Error qw( :warndie );
  
  These new error handlers are installed in C<$SIG{__WARN__}> and
  C<$SIG{__DIE__}>. If these handlers are already defined when the tag is
  imported, the old values are stored, and used during the new code. Thus, to
  arrange for custom handling of warnings and errors, you will need to perform
  something like the following:
  
   BEGIN {
     $SIG{__WARN__} = sub {
       print STDERR "My special warning handler: $_[0]"
     };
   }
  
   use Error qw( :warndie );
  
  Note that setting C<$SIG{__WARN__}> after the C<:warndie> tag has been
  imported will overwrite the handler that C<Error> provides. If this cannot be
  avoided, then the tag can be explicitly C<import>ed later
  
   use Error;
  
   $SIG{__WARN__} = ...;
  
   import Error qw( :warndie );
  
  =head2 EXAMPLE
  
  The C<__DIE__> handler turns messages such as
  
   Can't call method "foo" on an undefined value at examples/warndie.pl line 16.
  
  into
  
   Unhandled perl error caught at toplevel:
  
     Can't call method "foo" on an undefined value
  
   Thrown from: examples/warndie.pl:16
  
   Full stack trace:
  
           main::inner('undef') called at examples/warndie.pl line 20
           main::outer('undef') called at examples/warndie.pl line 23
  
  =cut
  
  =head1 SEE ALSO
  
  See L<Exception::Class> for a different module providing Object-Oriented
  exception handling, along with a convenient syntax for declaring hierarchies
  for them. It doesn't provide Error's syntactic sugar of C<try { ... }>,
  C<catch { ... }>, etc. which may be a good thing or a bad thing based
  on what you want. (Because Error's syntactic sugar tends to break.)
  
  L<Error::Exception> aims to combine L<Error> and L<Exception::Class>
  "with correct stringification".
  
  L<TryCatch> and L<Try::Tiny> are similar in concept to Error.pm only providing 
  a syntax that hopefully breaks less.
  
  =head1 KNOWN BUGS
  
  None, but that does not mean there are not any.
  
  =head1 AUTHORS
  
  Graham Barr <gbarr@pobox.com>
  
  The code that inspired me to write this was originally written by
  Peter Seibel <peter@weblogic.com> and adapted by Jesse Glick
  <jglick@sig.bsh.com>.
  
  C<:warndie> handlers added by Paul Evans <leonerd@leonerd.org.uk>
  
  =head1 MAINTAINER
  
  Shlomi Fish <shlomif@iglu.org.il>
  
  =head1 PAST MAINTAINERS
  
  Arun Kumar U <u_arunkumar@yahoo.com>
  
  =head1 COPYRIGHT
  
  Copyright (c) 1997-8  Graham Barr. All rights reserved.
  This program is free software; you can redistribute it and/or modify it
  under the same terms as Perl itself.
  
  =cut
  
ERROR

$fatpacked{"Error/Simple.pm"} = <<'ERROR_SIMPLE';
  # Error.pm
  #
  # Copyright (c) 2006 Shlomi Fish <shlomif@iglu.org.il>. All rights reserved.
  # This program is free software; you can redistribute it and/or
  # modify it under the terms of the MIT/X11 license.
  
  use strict;
  use warnings;
  
  use Error;
  
  1;
  __END__
  
  =head1 NAME
  
  Error::Simple - the simple error sub-class of Error
  
  =head1 SYNOPSIS
  
      use base 'Error::Simple';
  
  =head1 DESCRIPTION
  
  The only purpose of this module is to allow one to say:
  
      use base 'Error::Simple';
  
  and the only thing it does is "use" Error.pm. Refer to the documentation
  of L<Error> for more information about Error::Simple.
  
  =head1 METHODS
  
  =head2 Error::Simple->new($text [, $value])
  
  Constructs an Error::Simple with the text C<$text> and the optional value
  C<$value>.
  
  =head2 $err->stringify()
  
  Error::Simple overloads this method.
  
  =head1 KNOWN BUGS
  
  None.
  
  =head1 AUTHORS
  
  Shlomi Fish ( C<< shlomif@iglu.org.il >> )
  
  =head1 SEE ALSO
  
  L<Error>
  
ERROR_SIMPLE

$fatpacked{"Exporter.pm"} = <<'EXPORTER';
  package Exporter;
  
  require 5.006;
  
  # Be lean.
  #use strict;
  #no strict 'refs';
  
  our $Debug = 0;
  our $ExportLevel = 0;
  our $Verbose ||= 0;
  our $VERSION = '5.63';
  our (%Cache);
  
  # Carp 1.05+ does this now for us, but we may be running with an old Carp
  $Carp::Internal{Exporter}++;
  
  sub as_heavy {
    require Exporter::Heavy;
    # Unfortunately, this does not work if the caller is aliased as *name = \&foo
    # Thus the need to create a lot of identical subroutines
    my $c = (caller(1))[3];
    $c =~ s/.*:://;
    \&{"Exporter::Heavy::heavy_$c"};
  }
  
  sub export {
    goto &{as_heavy()};
  }
  
  sub import {
    my $pkg = shift;
    my $callpkg = caller($ExportLevel);
  
    if ($pkg eq "Exporter" and @_ and $_[0] eq "import") {
      *{$callpkg."::import"} = \&import;
      return;
    }
  
    # We *need* to treat @{"$pkg\::EXPORT_FAIL"} since Carp uses it :-(
    my($exports, $fail) = (\@{"$pkg\::EXPORT"}, \@{"$pkg\::EXPORT_FAIL"});
    return export $pkg, $callpkg, @_
      if $Verbose or $Debug or @$fail > 1;
    my $export_cache = ($Cache{$pkg} ||= {});
    my $args = @_ or @_ = @$exports;
  
    local $_;
    if ($args and not %$export_cache) {
      s/^&//, $export_cache->{$_} = 1
        foreach (@$exports, @{"$pkg\::EXPORT_OK"});
    }
    my $heavy;
    # Try very hard not to use {} and hence have to  enter scope on the foreach
    # We bomb out of the loop with last as soon as heavy is set.
    if ($args or $fail) {
      ($heavy = (/\W/ or $args and not exists $export_cache->{$_}
                 or @$fail and $_ eq $fail->[0])) and last
                   foreach (@_);
    } else {
      ($heavy = /\W/) and last
        foreach (@_);
    }
    return export $pkg, $callpkg, ($args ? @_ : ()) if $heavy;
    local $SIG{__WARN__} = 
  	sub {require Carp; &Carp::carp};
    # shortcut for the common case of no type character
    *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
  }
  
  # Default methods
  
  sub export_fail {
      my $self = shift;
      @_;
  }
  
  # Unfortunately, caller(1)[3] "does not work" if the caller is aliased as
  # *name = \&foo.  Thus the need to create a lot of identical subroutines
  # Otherwise we could have aliased them to export().
  
  sub export_to_level {
    goto &{as_heavy()};
  }
  
  sub export_tags {
    goto &{as_heavy()};
  }
  
  sub export_ok_tags {
    goto &{as_heavy()};
  }
  
  sub require_version {
    goto &{as_heavy()};
  }
  
  1;
  __END__
  
  =head1 NAME
  
  Exporter - Implements default import method for modules
  
  =head1 SYNOPSIS
  
  In module F<YourModule.pm>:
  
    package YourModule;
    require Exporter;
    @ISA = qw(Exporter);
    @EXPORT_OK = qw(munge frobnicate);  # symbols to export on request
  
  or
  
    package YourModule;
    use Exporter 'import'; # gives you Exporter's import() method directly
    @EXPORT_OK = qw(munge frobnicate);  # symbols to export on request
  
  In other files which wish to use C<YourModule>:
  
    use YourModule qw(frobnicate);      # import listed symbols
    frobnicate ($left, $right)          # calls YourModule::frobnicate
  
  Take a look at L</Good Practices> for some variants
  you will like to use in modern Perl code.
  
  =head1 DESCRIPTION
  
  The Exporter module implements an C<import> method which allows a module
  to export functions and variables to its users' namespaces. Many modules
  use Exporter rather than implementing their own C<import> method because
  Exporter provides a highly flexible interface, with an implementation optimised
  for the common case.
  
  Perl automatically calls the C<import> method when processing a
  C<use> statement for a module. Modules and C<use> are documented
  in L<perlfunc> and L<perlmod>. Understanding the concept of
  modules and how the C<use> statement operates is important to
  understanding the Exporter.
  
  =head2 How to Export
  
  The arrays C<@EXPORT> and C<@EXPORT_OK> in a module hold lists of
  symbols that are going to be exported into the users name space by
  default, or which they can request to be exported, respectively.  The
  symbols can represent functions, scalars, arrays, hashes, or typeglobs.
  The symbols must be given by full name with the exception that the
  ampersand in front of a function is optional, e.g.
  
      @EXPORT    = qw(afunc $scalar @array);   # afunc is a function
      @EXPORT_OK = qw(&bfunc %hash *typeglob); # explicit prefix on &bfunc
  
  If you are only exporting function names it is recommended to omit the
  ampersand, as the implementation is faster this way.
  
  =head2 Selecting What To Export
  
  Do B<not> export method names!
  
  Do B<not> export anything else by default without a good reason!
  
  Exports pollute the namespace of the module user.  If you must export
  try to use C<@EXPORT_OK> in preference to C<@EXPORT> and avoid short or
  common symbol names to reduce the risk of name clashes.
  
  Generally anything not exported is still accessible from outside the
  module using the C<YourModule::item_name> (or C<< $blessed_ref->method >>)
  syntax.  By convention you can use a leading underscore on names to
  informally indicate that they are 'internal' and not for public use.
  
  (It is actually possible to get private functions by saying:
  
    my $subref = sub { ... };
    $subref->(@args);            # Call it as a function
    $obj->$subref(@args);        # Use it as a method
  
  However if you use them for methods it is up to you to figure out
  how to make inheritance work.)
  
  As a general rule, if the module is trying to be object oriented
  then export nothing. If it's just a collection of functions then
  C<@EXPORT_OK> anything but use C<@EXPORT> with caution. For function and
  method names use barewords in preference to names prefixed with
  ampersands for the export lists.
  
  Other module design guidelines can be found in L<perlmod>.
  
  =head2 How to Import
  
  In other files which wish to use your module there are three basic ways for
  them to load your module and import its symbols:
  
  =over 4
  
  =item C<use YourModule;>
  
  This imports all the symbols from YourModule's C<@EXPORT> into the namespace
  of the C<use> statement.
  
  =item C<use YourModule ();>
  
  This causes perl to load your module but does not import any symbols.
  
  =item C<use YourModule qw(...);>
  
  This imports only the symbols listed by the caller into their namespace.
  All listed symbols must be in your C<@EXPORT> or C<@EXPORT_OK>, else an error
  occurs. The advanced export features of Exporter are accessed like this,
  but with list entries that are syntactically distinct from symbol names.
  
  =back
  
  Unless you want to use its advanced features, this is probably all you
  need to know to use Exporter.
  
  =head1 Advanced features
  
  =head2 Specialised Import Lists
  
  If any of the entries in an import list begins with !, : or / then
  the list is treated as a series of specifications which either add to
  or delete from the list of names to import. They are processed left to
  right. Specifications are in the form:
  
      [!]name         This name only
      [!]:DEFAULT     All names in @EXPORT
      [!]:tag         All names in $EXPORT_TAGS{tag} anonymous list
      [!]/pattern/    All names in @EXPORT and @EXPORT_OK which match
  
  A leading ! indicates that matching names should be deleted from the
  list of names to import.  If the first specification is a deletion it
  is treated as though preceded by :DEFAULT. If you just want to import
  extra names in addition to the default set you will still need to
  include :DEFAULT explicitly.
  
  e.g., F<Module.pm> defines:
  
      @EXPORT      = qw(A1 A2 A3 A4 A5);
      @EXPORT_OK   = qw(B1 B2 B3 B4 B5);
      %EXPORT_TAGS = (T1 => [qw(A1 A2 B1 B2)], T2 => [qw(A1 A2 B3 B4)]);
  
      Note that you cannot use tags in @EXPORT or @EXPORT_OK.
      Names in EXPORT_TAGS must also appear in @EXPORT or @EXPORT_OK.
  
  An application using Module can say something like:
  
      use Module qw(:DEFAULT :T2 !B3 A3);
  
  Other examples include:
  
      use Socket qw(!/^[AP]F_/ !SOMAXCONN !SOL_SOCKET);
      use POSIX  qw(:errno_h :termios_h !TCSADRAIN !/^EXIT/);
  
  Remember that most patterns (using //) will need to be anchored
  with a leading ^, e.g., C</^EXIT/> rather than C</EXIT/>.
  
  You can say C<BEGIN { $Exporter::Verbose=1 }> to see how the
  specifications are being processed and what is actually being imported
  into modules.
  
  =head2 Exporting without using Exporter's import method
  
  Exporter has a special method, 'export_to_level' which is used in situations
  where you can't directly call Exporter's import method. The export_to_level
  method looks like:
  
      MyPackage->export_to_level($where_to_export, $package, @what_to_export);
  
  where C<$where_to_export> is an integer telling how far up the calling stack
  to export your symbols, and C<@what_to_export> is an array telling what
  symbols *to* export (usually this is C<@_>).  The C<$package> argument is
  currently unused.
  
  For example, suppose that you have a module, A, which already has an
  import function:
  
      package A;
  
      @ISA = qw(Exporter);
      @EXPORT_OK = qw ($b);
  
      sub import
      {
  	$A::b = 1;     # not a very useful import method
      }
  
  and you want to Export symbol C<$A::b> back to the module that called 
  package A. Since Exporter relies on the import method to work, via 
  inheritance, as it stands Exporter::import() will never get called. 
  Instead, say the following:
  
      package A;
      @ISA = qw(Exporter);
      @EXPORT_OK = qw ($b);
  
      sub import
      {
  	$A::b = 1;
  	A->export_to_level(1, @_);
      }
  
  This will export the symbols one level 'above' the current package - ie: to 
  the program or module that used package A. 
  
  Note: Be careful not to modify C<@_> at all before you call export_to_level
  - or people using your package will get very unexplained results!
  
  =head2 Exporting without inheriting from Exporter
  
  By including Exporter in your C<@ISA> you inherit an Exporter's import() method
  but you also inherit several other helper methods which you probably don't
  want. To avoid this you can do
  
    package YourModule;
    use Exporter qw( import );
  
  which will export Exporter's own import() method into YourModule.
  Everything will work as before but you won't need to include Exporter in
  C<@YourModule::ISA>.
  
  Note: This feature was introduced in version 5.57
  of Exporter, released with perl 5.8.3.
  
  =head2 Module Version Checking
  
  The Exporter module will convert an attempt to import a number from a
  module into a call to C<< $module_name->require_version($value) >>. This can
  be used to validate that the version of the module being used is
  greater than or equal to the required version.
  
  The Exporter module supplies a default C<require_version> method which
  checks the value of C<$VERSION> in the exporting module.
  
  Since the default C<require_version> method treats the C<$VERSION> number as
  a simple numeric value it will regard version 1.10 as lower than
  1.9. For this reason it is strongly recommended that you use numbers
  with at least two decimal places, e.g., 1.09.
  
  =head2 Managing Unknown Symbols
  
  In some situations you may want to prevent certain symbols from being
  exported. Typically this applies to extensions which have functions
  or constants that may not exist on some systems.
  
  The names of any symbols that cannot be exported should be listed
  in the C<@EXPORT_FAIL> array.
  
  If a module attempts to import any of these symbols the Exporter
  will give the module an opportunity to handle the situation before
  generating an error. The Exporter will call an export_fail method
  with a list of the failed symbols:
  
    @failed_symbols = $module_name->export_fail(@failed_symbols);
  
  If the C<export_fail> method returns an empty list then no error is
  recorded and all the requested symbols are exported. If the returned
  list is not empty then an error is generated for each symbol and the
  export fails. The Exporter provides a default C<export_fail> method which
  simply returns the list unchanged.
  
  Uses for the C<export_fail> method include giving better error messages
  for some symbols and performing lazy architectural checks (put more
  symbols into C<@EXPORT_FAIL> by default and then take them out if someone
  actually tries to use them and an expensive check shows that they are
  usable on that platform).
  
  =head2 Tag Handling Utility Functions
  
  Since the symbols listed within C<%EXPORT_TAGS> must also appear in either
  C<@EXPORT> or C<@EXPORT_OK>, two utility functions are provided which allow
  you to easily add tagged sets of symbols to C<@EXPORT> or C<@EXPORT_OK>:
  
    %EXPORT_TAGS = (foo => [qw(aa bb cc)], bar => [qw(aa cc dd)]);
  
    Exporter::export_tags('foo');     # add aa, bb and cc to @EXPORT
    Exporter::export_ok_tags('bar');  # add aa, cc and dd to @EXPORT_OK
  
  Any names which are not tags are added to C<@EXPORT> or C<@EXPORT_OK>
  unchanged but will trigger a warning (with C<-w>) to avoid misspelt tags
  names being silently added to C<@EXPORT> or C<@EXPORT_OK>. Future versions
  may make this a fatal error.
  
  =head2 Generating combined tags
  
  If several symbol categories exist in C<%EXPORT_TAGS>, it's usually
  useful to create the utility ":all" to simplify "use" statements.
  
  The simplest way to do this is:
  
    %EXPORT_TAGS = (foo => [qw(aa bb cc)], bar => [qw(aa cc dd)]);
  
    # add all the other ":class" tags to the ":all" class,
    # deleting duplicates
    {
      my %seen;
  
      push @{$EXPORT_TAGS{all}},
        grep {!$seen{$_}++} @{$EXPORT_TAGS{$_}} foreach keys %EXPORT_TAGS;
    }
  
  F<CGI.pm> creates an ":all" tag which contains some (but not really
  all) of its categories.  That could be done with one small
  change:
  
    # add some of the other ":class" tags to the ":all" class,
    # deleting duplicates
    {
      my %seen;
  
      push @{$EXPORT_TAGS{all}},
        grep {!$seen{$_}++} @{$EXPORT_TAGS{$_}}
          foreach qw/html2 html3 netscape form cgi internal/;
    }
  
  Note that the tag names in C<%EXPORT_TAGS> don't have the leading ':'.
  
  =head2 C<AUTOLOAD>ed Constants
  
  Many modules make use of C<AUTOLOAD>ing for constant subroutines to
  avoid having to compile and waste memory on rarely used values (see
  L<perlsub> for details on constant subroutines).  Calls to such
  constant subroutines are not optimized away at compile time because
  they can't be checked at compile time for constancy.
  
  Even if a prototype is available at compile time, the body of the
  subroutine is not (it hasn't been C<AUTOLOAD>ed yet). perl needs to
  examine both the C<()> prototype and the body of a subroutine at
  compile time to detect that it can safely replace calls to that
  subroutine with the constant value.
  
  A workaround for this is to call the constants once in a C<BEGIN> block:
  
     package My ;
  
     use Socket ;
  
     foo( SO_LINGER );     ## SO_LINGER NOT optimized away; called at runtime
     BEGIN { SO_LINGER }
     foo( SO_LINGER );     ## SO_LINGER optimized away at compile time.
  
  This forces the C<AUTOLOAD> for C<SO_LINGER> to take place before
  SO_LINGER is encountered later in C<My> package.
  
  If you are writing a package that C<AUTOLOAD>s, consider forcing
  an C<AUTOLOAD> for any constants explicitly imported by other packages
  or which are usually used when your package is C<use>d.
  
  =head1 Good Practices
  
  =head2 Declaring C<@EXPORT_OK> and Friends
  
  When using C<Exporter> with the standard C<strict> and C<warnings>
  pragmas, the C<our> keyword is needed to declare the package
  variables C<@EXPORT_OK>, C<@EXPORT>, C<@ISA>, etc.
  
    our @ISA = qw(Exporter);
    our @EXPORT_OK = qw(munge frobnicate);
  
  If backward compatibility for Perls under 5.6 is important,
  one must write instead a C<use vars> statement.
  
    use vars qw(@ISA @EXPORT_OK);
    @ISA = qw(Exporter);
    @EXPORT_OK = qw(munge frobnicate);
  
  =head2 Playing Safe
  
  There are some caveats with the use of runtime statements
  like C<require Exporter> and the assignment to package
  variables, which can very subtle for the unaware programmer.
  This may happen for instance with mutually recursive
  modules, which are affected by the time the relevant
  constructions are executed.
  
  The ideal (but a bit ugly) way to never have to think
  about that is to use C<BEGIN> blocks. So the first part
  of the L</SYNOPSIS> code could be rewritten as:
  
    package YourModule;
  
    use strict;
    use warnings;
  
    our (@ISA, @EXPORT_OK);
    BEGIN {
       require Exporter;
       @ISA = qw(Exporter);
       @EXPORT_OK = qw(munge frobnicate);  # symbols to export on request
    }
  
  The C<BEGIN> will assure that the loading of F<Exporter.pm>
  and the assignments to C<@ISA> and C<@EXPORT_OK> happen
  immediately, leaving no room for something to get awry
  or just plain wrong.
  
  With respect to loading C<Exporter> and inheriting, there
  are alternatives with the use of modules like C<base> and C<parent>.
  
    use base qw( Exporter );
    # or
    use parent qw( Exporter );
  
  Any of these statements are nice replacements for
  C<BEGIN { require Exporter; @ISA = qw(Exporter); }>
  with the same compile-time effect. The basic difference
  is that C<base> code interacts with declared C<fields>
  while C<parent> is a streamlined version of the older
  C<base> code to just establish the IS-A relationship.
  
  For more details, see the documentation and code of
  L<base> and L<parent>.
  
  Another thorough remedy to that runtime vs. 
  compile-time trap is to use L<Exporter::Easy>,
  which is a wrapper of Exporter that allows all
  boilerplate code at a single gulp in the
  use statement.
  
     use Exporter::Easy (
         OK => [ qw(munge frobnicate) ],
     );
     # @ISA setup is automatic
     # all assignments happen at compile time
  
  =head2 What not to Export
  
  You have been warned already in L</Selecting What To Export>
  to not export:
  
  =over 4
  
  =item *
  
  method names (because you don't need to
  and that's likely to not do what you want),
  
  =item *
  
  anything by default (because you don't want to surprise your users...
  badly)
  
  =item *
  
  anything you don't need to (because less is more)
  
  =back
  
  There's one more item to add to this list. Do B<not>
  export variable names. Just because C<Exporter> lets you
  do that, it does not mean you should.
  
    @EXPORT_OK = qw( $svar @avar %hvar ); # DON'T!
  
  Exporting variables is not a good idea. They can
  change under the hood, provoking horrible
  effects at-a-distance, that are too hard to track
  and to fix. Trust me: they are not worth it.
  
  To provide the capability to set/get class-wide
  settings, it is best instead to provide accessors
  as subroutines or class methods instead.
  
  =head1 SEE ALSO
  
  C<Exporter> is definitely not the only module with
  symbol exporter capabilities. At CPAN, you may find
  a bunch of them. Some are lighter. Some
  provide improved APIs and features. Peek the one
  that fits your needs. The following is
  a sample list of such modules.
  
      Exporter::Easy
      Exporter::Lite
      Exporter::Renaming
      Exporter::Tidy
      Sub::Exporter / Sub::Installer
      Perl6::Export / Perl6::Export::Attrs
  
  =head1 LICENSE
  
  This library is free software. You can redistribute it
  and/or modify it under the same terms as Perl itself.
  
  =cut
  
  
  
EXPORTER

$fatpacked{"Exporter/Heavy.pm"} = <<'EXPORTER_HEAVY';
  package Exporter::Heavy;
  
  use strict;
  no strict 'refs';
  
  # On one line so MakeMaker will see it.
  require Exporter;  our $VERSION = $Exporter::VERSION;
  
  # Carp 1.05+ does this now for us, but we may be running with an old Carp
  $Carp::Internal{'Exporter::Heavy'}++;
  
  =head1 NAME
  
  Exporter::Heavy - Exporter guts
  
  =head1 SYNOPSIS
  
  (internal use only)
  
  =head1 DESCRIPTION
  
  No user-serviceable parts inside.
  
  =cut
  
  #
  # We go to a lot of trouble not to 'require Carp' at file scope,
  #  because Carp requires Exporter, and something has to give.
  #
  
  sub _rebuild_cache {
      my ($pkg, $exports, $cache) = @_;
      s/^&// foreach @$exports;
      @{$cache}{@$exports} = (1) x @$exports;
      my $ok = \@{"${pkg}::EXPORT_OK"};
      if (@$ok) {
  	s/^&// foreach @$ok;
  	@{$cache}{@$ok} = (1) x @$ok;
      }
  }
  
  sub heavy_export {
  
      # First make import warnings look like they're coming from the "use".
      local $SIG{__WARN__} = sub {
  	my $text = shift;
  	if ($text =~ s/ at \S*Exporter\S*.pm line \d+.*\n//) {
  	    require Carp;
  	    local $Carp::CarpLevel = 1;	# ignore package calling us too.
  	    Carp::carp($text);
  	}
  	else {
  	    warn $text;
  	}
      };
      local $SIG{__DIE__} = sub {
  	require Carp;
  	local $Carp::CarpLevel = 1;	# ignore package calling us too.
  	Carp::croak("$_[0]Illegal null symbol in \@${1}::EXPORT")
  	    if $_[0] =~ /^Unable to create sub named "(.*?)::"/;
      };
  
      my($pkg, $callpkg, @imports) = @_;
      my($type, $sym, $cache_is_current, $oops);
      my($exports, $export_cache) = (\@{"${pkg}::EXPORT"},
                                     $Exporter::Cache{$pkg} ||= {});
  
      if (@imports) {
  	if (!%$export_cache) {
  	    _rebuild_cache ($pkg, $exports, $export_cache);
  	    $cache_is_current = 1;
  	}
  
  	if (grep m{^[/!:]}, @imports) {
  	    my $tagsref = \%{"${pkg}::EXPORT_TAGS"};
  	    my $tagdata;
  	    my %imports;
  	    my($remove, $spec, @names, @allexports);
  	    # negated first item implies starting with default set:
  	    unshift @imports, ':DEFAULT' if $imports[0] =~ m/^!/;
  	    foreach $spec (@imports){
  		$remove = $spec =~ s/^!//;
  
  		if ($spec =~ s/^://){
  		    if ($spec eq 'DEFAULT'){
  			@names = @$exports;
  		    }
  		    elsif ($tagdata = $tagsref->{$spec}) {
  			@names = @$tagdata;
  		    }
  		    else {
  			warn qq["$spec" is not defined in %${pkg}::EXPORT_TAGS];
  			++$oops;
  			next;
  		    }
  		}
  		elsif ($spec =~ m:^/(.*)/$:){
  		    my $patn = $1;
  		    @allexports = keys %$export_cache unless @allexports; # only do keys once
  		    @names = grep(/$patn/, @allexports); # not anchored by default
  		}
  		else {
  		    @names = ($spec); # is a normal symbol name
  		}
  
  		warn "Import ".($remove ? "del":"add").": @names "
  		    if $Exporter::Verbose;
  
  		if ($remove) {
  		   foreach $sym (@names) { delete $imports{$sym} } 
  		}
  		else {
  		    @imports{@names} = (1) x @names;
  		}
  	    }
  	    @imports = keys %imports;
  	}
  
          my @carp;
  	foreach $sym (@imports) {
  	    if (!$export_cache->{$sym}) {
  		if ($sym =~ m/^\d/) {
  		    $pkg->VERSION($sym); # inherit from UNIVERSAL
  		    # If the version number was the only thing specified
  		    # then we should act as if nothing was specified:
  		    if (@imports == 1) {
  			@imports = @$exports;
  			last;
  		    }
  		    # We need a way to emulate 'use Foo ()' but still
  		    # allow an easy version check: "use Foo 1.23, ''";
  		    if (@imports == 2 and !$imports[1]) {
  			@imports = ();
  			last;
  		    }
  		} elsif ($sym !~ s/^&// || !$export_cache->{$sym}) {
  		    # Last chance - see if they've updated EXPORT_OK since we
  		    # cached it.
  
  		    unless ($cache_is_current) {
  			%$export_cache = ();
  			_rebuild_cache ($pkg, $exports, $export_cache);
  			$cache_is_current = 1;
  		    }
  
  		    if (!$export_cache->{$sym}) {
  			# accumulate the non-exports
  			push @carp,
  			  qq["$sym" is not exported by the $pkg module\n];
  			$oops++;
  		    }
  		}
  	    }
  	}
  	if ($oops) {
  	    require Carp;
  	    Carp::croak("@{carp}Can't continue after import errors");
  	}
      }
      else {
  	@imports = @$exports;
      }
  
      my($fail, $fail_cache) = (\@{"${pkg}::EXPORT_FAIL"},
                                $Exporter::FailCache{$pkg} ||= {});
  
      if (@$fail) {
  	if (!%$fail_cache) {
  	    # Build cache of symbols. Optimise the lookup by adding
  	    # barewords twice... both with and without a leading &.
  	    # (Technique could be applied to $export_cache at cost of memory)
  	    my @expanded = map { /^\w/ ? ($_, '&'.$_) : $_ } @$fail;
  	    warn "${pkg}::EXPORT_FAIL cached: @expanded" if $Exporter::Verbose;
  	    @{$fail_cache}{@expanded} = (1) x @expanded;
  	}
  	my @failed;
  	foreach $sym (@imports) { push(@failed, $sym) if $fail_cache->{$sym} }
  	if (@failed) {
  	    @failed = $pkg->export_fail(@failed);
  	    foreach $sym (@failed) {
                  require Carp;
  		Carp::carp(qq["$sym" is not implemented by the $pkg module ],
  			"on this architecture");
  	    }
  	    if (@failed) {
  		require Carp;
  		Carp::croak("Can't continue after import errors");
  	    }
  	}
      }
  
      warn "Importing into $callpkg from $pkg: ",
  		join(", ",sort @imports) if $Exporter::Verbose;
  
      foreach $sym (@imports) {
  	# shortcut for the common case of no type character
  	(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
  	    unless $sym =~ s/^(\W)//;
  	$type = $1;
  	no warnings 'once';
  	*{"${callpkg}::$sym"} =
  	    $type eq '&' ? \&{"${pkg}::$sym"} :
  	    $type eq '$' ? \${"${pkg}::$sym"} :
  	    $type eq '@' ? \@{"${pkg}::$sym"} :
  	    $type eq '%' ? \%{"${pkg}::$sym"} :
  	    $type eq '*' ?  *{"${pkg}::$sym"} :
  	    do { require Carp; Carp::croak("Can't export symbol: $type$sym") };
      }
  }
  
  sub heavy_export_to_level
  {
        my $pkg = shift;
        my $level = shift;
        (undef) = shift;			# XXX redundant arg
        my $callpkg = caller($level);
        $pkg->export($callpkg, @_);
  }
  
  # Utility functions
  
  sub _push_tags {
      my($pkg, $var, $syms) = @_;
      my @nontag = ();
      my $export_tags = \%{"${pkg}::EXPORT_TAGS"};
      push(@{"${pkg}::$var"},
  	map { $export_tags->{$_} ? @{$export_tags->{$_}} 
                                   : scalar(push(@nontag,$_),$_) }
  		(@$syms) ? @$syms : keys %$export_tags);
      if (@nontag and $^W) {
  	# This may change to a die one day
  	require Carp;
  	Carp::carp(join(", ", @nontag)." are not tags of $pkg");
      }
  }
  
  sub heavy_require_version {
      my($self, $wanted) = @_;
      my $pkg = ref $self || $self;
      return ${pkg}->VERSION($wanted);
  }
  
  sub heavy_export_tags {
    _push_tags((caller)[0], "EXPORT",    \@_);
  }
  
  sub heavy_export_ok_tags {
    _push_tags((caller)[0], "EXPORT_OK", \@_);
  }
  
  1;
EXPORTER_HEAVY

$fatpacked{"File/ReadBackwards.pm"} = <<'FILE_READBACKWARDS';
  # File::ReadBackwards.pm
  
  # Copyright (C) 2003 by Uri Guttman. All rights reserved.
  # mail bugs, comments and feedback to uri@stemsystems.com
  
  package File::ReadBackwards ;
  
  use strict ;
  
  use vars qw( $VERSION ) ;
  
  $VERSION = '1.04' ;
  
  use Symbol ;
  use Fcntl qw( :seek O_RDONLY ) ;
  use Carp ;
  
  my $max_read_size = 1 << 13 ;
  
  my $default_rec_sep ;
  
  BEGIN {
  
  # set the default record separator according to this OS
  # this needs testing and expansion.
  
  # look for CR/LF types
  # then look for CR types
  # else it's a LF type
  
  	if ( $^O =~ /win32/i || $^O =~ /vms/i ) {
  
  		$default_rec_sep = "\015\012" ;
  	}
  	elsif ( $^O =~ /mac/i ) {
  
  		$default_rec_sep = "\015" ;
  	}
  	else {
  		$default_rec_sep = "\012" ;
  	}
  
  # the tied interface is exactly the same as the object one, so all we
  # need to do is to alias the subs with typeglobs
  
  	*TIEHANDLE = \&new ;
  	*READLINE = \&readline ;
   	*EOF = \&eof ;
   	*CLOSE = \&close ;
   	*TELL = \&tell ;
  
  # added getline alias for compatibility with IO::Handle
  
  	*getline = \&readline ;
  }
  
  
  # constructor for File::ReadBackwards
  
  sub new {
  
  	my( $class, $filename, $rec_sep, $sep_is_regex ) = @_ ;
  
  # check that we have a filename
  
  	defined( $filename ) || return ;
  
  # see if this file uses the default of a cr/lf separator
  # those files will get cr/lf converted to \n
  
  	$rec_sep ||= $default_rec_sep ;
  	my $is_crlf = $rec_sep eq "\015\012" ;
  
  # get a handle and open the file
  
  	my $handle = gensym ;
  	sysopen( $handle, $filename, O_RDONLY ) || return ;
  	binmode $handle ;
  
  # seek to the end of the file and get its size
  
  	my $seek_pos = sysseek( $handle, 0, SEEK_END ) or return ;
  
  # get the size of the first block to read,
  # either a trailing partial one (the % size) or full sized one (max read size)
  
  	my $read_size = $seek_pos % $max_read_size || $max_read_size ;
  
  # create the object
  
  	my $self = bless {
  			'file_name'	=> $filename,
  			'handle'	=> $handle,
  			'read_size'	=> $read_size,
  			'seek_pos'	=> $seek_pos,
  			'lines'		=> [],
  			'is_crlf'	=> $is_crlf,
  			'rec_sep'	=> $rec_sep,
  			'sep_is_regex'	=> $sep_is_regex,
  
  		}, $class ;
  
  	return( $self ) ;
  }
  
  # read the previous record from the file
  # 
  sub readline {
  
  	my( $self, $line_ref ) = @_ ;
  
  	my $read_buf ;
  
  # get the buffer of lines
  
  	my $lines_ref = $self->{'lines'} ;
  
  	return unless $lines_ref ;
  
  	while( 1 ) {
  
  # see if there is more than 1 line in the buffer
  
  		if ( @{$lines_ref} > 1 ) {
  
  # we have a complete line so return it
  # and convert those damned cr/lf lines to \n
  
  			$lines_ref->[-1] =~ s/\015\012/\n/
  					if $self->{'is_crlf'} ;
  
  			return( pop @{$lines_ref} ) ;
  		}
  
  # we don't have a complete, so have to read blocks until we do
  
  		my $seek_pos = $self->{'seek_pos'} ;
  
  # see if we are at the beginning of the file
  
  		if ( $seek_pos == 0 ) {
  
  # the last read never made more lines, so return the last line in the buffer
  # if no lines left then undef will be returned
  # and convert those damned cr/lf lines to \n
  
  			$lines_ref->[-1] =~ s/\015\012/\n/
  					if @{$lines_ref} && $self->{'is_crlf'} ;
  
  			return( pop @{$lines_ref} ) ;
  		}
  
  # we have to read more text so get the handle and the current read size
  
  		my $handle = $self->{'handle'} ;
  		my $read_size = $self->{'read_size'} ;
  
  # after the first read, always read the maximum size
  
  		$self->{'read_size'} = $max_read_size ;
  
  # seek to the beginning of this block and save the new seek position
  
  		$seek_pos -= $read_size ;
  		sysseek( $handle, $seek_pos, SEEK_SET ) ;
  		$self->{'seek_pos'} = $seek_pos ;
  
  # read in the next (previous) block of text
  
  		my $read_cnt = sysread( $handle, $read_buf, $read_size ) ;
  
  # prepend the read buffer to the leftover (possibly partial) line
  
  		my $text = $read_buf ;
  		$text .= shift @{$lines_ref} if @{$lines_ref} ;
  
  # split the buffer into a list of lines
  # this may want to be $/ but reading files backwards assumes plain text and
  # newline separators
  
  		@{$lines_ref} = ( $self->{'sep_is_regex'} ) ?
  	 		$text =~ /(.*?$self->{'rec_sep'}|.+)/gs :
  			$text =~ /(.*?\Q$self->{'rec_sep'}\E|.+)/gs ;
  
  #print "Lines \n=>", join( "<=\n=>", @{$lines_ref} ), "<=\n" ;
  
  	}
  }
  
  sub eof {
  
  	my ( $self ) = @_ ;
  
  	my $seek_pos = $self->{'seek_pos'} ;
  	my $lines_count = @{ $self->{'lines'} } ;
  	return( $seek_pos == 0 && $lines_count == 0 ) ;
  }
  
  sub tell {
  	my ( $self ) = @_ ;
  
  	my $seek_pos = $self->{'seek_pos'} ;
  	$seek_pos + length(join "", @{ $self->{'lines'} });
  }
  
  sub get_handle {
  	my ( $self ) = @_ ;
  
  	my $handle = $self->{handle} ;
  	seek( $handle, $self->tell, SEEK_SET ) ;
  	return $handle ;
  }
  
  sub close {
  
  	my ( $self ) = @_ ;
  
  	my $handle = delete( $self->{'handle'} ) ;
  	delete( $self->{'lines'} ) ;
  
  	CORE::close( $handle ) ;
  }
  
  __END__
  
  
  =head1 NAME
  
  File::ReadBackwards.pm -- Read a file backwards by lines.
   
  
  =head1 SYNOPSIS
  
      use File::ReadBackwards ;
  
      # Object interface
  
      $bw = File::ReadBackwards->new( 'log_file' ) or
  			die "can't read 'log_file' $!" ;
  
      while( defined( $log_line = $bw->readline ) ) {
  	    print $log_line ;
      }
  
      # ... or the alternative way of reading
  
      until ( $bw->eof ) {
  	    print $bw->readline ;
      }
  
      # Tied Handle Interface
  
      tie *BW, 'File::ReadBackwards', 'log_file' or
  			die "can't read 'log_file' $!" ;
  
      while( <BW> ) {
  	    print ;
      }
  
  =head1 DESCRIPTION
    
  
  This module reads a file backwards line by line. It is simple to use,
  memory efficient and fast. It supports both an object and a tied handle
  interface.
  
  It is intended for processing log and other similar text files which
  typically have their newest entries appended to them. By default files
  are assumed to be plain text and have a line ending appropriate to the
  OS. But you can set the input record separator string on a per file
  basis.
  
  
  =head1 OBJECT INTERFACE
   
  These are the methods in C<File::ReadBackwards>' object interface:
  
  
  =head2 new( $file, [$rec_sep], [$sep_is_regex] )
  
  C<new> takes as arguments a filename, an optional record separator and
  an optional flag that marks the record separator as a regular
  expression. It either returns the object on a successful open or undef
  upon failure. $! is set to the error code if any.
  
  =head2 readline
  
  C<readline> takes no arguments and it returns the previous line in the
  file or undef when there are no more lines in the file. If the file is
  a non-seekable file (e.g. a pipe), then undef is returned.
  
  =head2 getline
  
  C<getline> is an alias for the readline method. It is here for
  compatibilty with the IO::* classes which has a getline method.
  
  =head2 eof
  
  C<eof> takes no arguments and it returns true when readline() has
  iterated through the whole file.
  
  =head2 close
  
  C<close> takes no arguments and it closes the handle
  
  =head2 tell
  
  C<tell> takes no arguments and it returns the current filehandle position.
  This value may be used to seek() back to this position using a normal
  file handle.
  
  =head2 get_handle
  
  C<get_handle> takes no arguments and it returns the internal Perl
  filehandle used by the File::ReadBackwards object.  This handle may be
  used to read the file forward. Its seek position will be set to the
  position that is returned by the tell() method.  Note that
  interleaving forward and reverse reads may produce unpredictable
  results.  The only use supported at present is to read a file backward
  to a certain point, then use 'handle' to extract the handle, and read
  forward from that point.
  
  =head1 TIED HANDLE INTERFACE
  
  =head2 tie( *HANDLE, 'File::ReadBackwards', $file, [$rec_sep], [$sep_is_regex] )
   
  
  The TIEHANDLE, READLINE, EOF, CLOSE and TELL methods are aliased to
  the new, readline, eof, close and tell methods respectively so refer
  to them for their arguments and API.  Once you have tied a handle to
  File::ReadBackwards the only I/O operation permissible is <> which
  will read the previous line. You can call eof() and close() on the
  tied handle as well. All other tied handle operations will generate an
  unknown method error. Do not seek, write or perform any other
  unsupported operations on the tied handle.
  
  =head1 LINE AND RECORD ENDINGS
   
  
  Since this module needs to use low level I/O for efficiency, it can't
  portably seek and do block I/O without managing line ending conversions.
  This module supports the default record separators of normal line ending
  strings used by the OS. You can also set the separator on a per file
  basis.
  
  The record separator is a regular expression by default, which differs
  from the behavior of $/.
  
  Only if the record separator is B<not> specified and it defaults to
  CR/LF (e.g, VMS, redmondware) will it will be converted to a single
  newline. Unix and MacOS files systems use only a single character for
  line endings and the lines are left unchanged.  This means that for
  native text files, you should be able to process their lines backwards
  without any problems with line endings. If you specify a record
  separator, no conversions will be done and you will get the records as
  if you read them in binary mode.
  
  =head1 DESIGN
  
  It works by reading a large (8kb) block of data from the end of the
  file.  It then splits them on the record separator and stores a list of
  records in the object. Each call to readline returns the top record of
  the list and if the list is empty it refills it by reading the previous
  block from the file and splitting it.  When the beginning of the file is
  reached and there are no more lines, undef is returned.  All boundary
  conditions are handled correctly i.e. if there is a trailing partial
  line (no newline) it will be the first line returned and lines larger
  than the read buffer size are handled properly.
  
  
  =head1 NOTES
   
  
  There is no support for list context in either the object or tied
  interfaces. If you want to slurp all of the lines into an array in
  backwards order (and you don't care about memory usage) just do:
  
  	@back_lines = reverse <FH>.
  
  This module is only intended to read one line at a time from the end of
  a file to the beginning.
  
  =head1 AUTHOR
   
  
  Uri Guttman, uri@stemsystems.com
  
  =head1 COPYRIGHT
   
  
  Copyright (C) 2003 by Uri Guttman. All rights reserved.  This program is
  free software; you can redistribute it and/or modify it under the same
  terms as Perl itself.
  
  =cut
FILE_READBACKWARDS

$fatpacked{"Getopt/Long.pm"} = <<'GETOPT_LONG';
  # Getopt::Long.pm -- Universal options parsing
  
  package Getopt::Long;
  
  # RCS Status      : $Id: Long.pm,v 2.76 2009/03/30 20:54:30 jv Exp $
  # Author          : Johan Vromans
  # Created On      : Tue Sep 11 15:00:12 1990
  # Last Modified By: Johan Vromans
  # Last Modified On: Mon Mar 30 22:51:17 2009
  # Update Count    : 1601
  # Status          : Released
  
  ################ Module Preamble ################
  
  use 5.004;
  
  use strict;
  
  use vars qw($VERSION);
  $VERSION        =  2.38;
  # For testing versions only.
  #use vars qw($VERSION_STRING);
  #$VERSION_STRING = "2.38";
  
  use Exporter;
  use vars qw(@ISA @EXPORT @EXPORT_OK);
  @ISA = qw(Exporter);
  
  # Exported subroutines.
  sub GetOptions(@);		# always
  sub GetOptionsFromArray(@);	# on demand
  sub GetOptionsFromString(@);	# on demand
  sub Configure(@);		# on demand
  sub HelpMessage(@);		# on demand
  sub VersionMessage(@);		# in demand
  
  BEGIN {
      # Init immediately so their contents can be used in the 'use vars' below.
      @EXPORT    = qw(&GetOptions $REQUIRE_ORDER $PERMUTE $RETURN_IN_ORDER);
      @EXPORT_OK = qw(&HelpMessage &VersionMessage &Configure
  		    &GetOptionsFromArray &GetOptionsFromString);
  }
  
  # User visible variables.
  use vars @EXPORT, @EXPORT_OK;
  use vars qw($error $debug $major_version $minor_version);
  # Deprecated visible variables.
  use vars qw($autoabbrev $getopt_compat $ignorecase $bundling $order
  	    $passthrough);
  # Official invisible variables.
  use vars qw($genprefix $caller $gnu_compat $auto_help $auto_version $longprefix);
  
  # Public subroutines.
  sub config(@);			# deprecated name
  
  # Private subroutines.
  sub ConfigDefaults();
  sub ParseOptionSpec($$);
  sub OptCtl($);
  sub FindOption($$$$$);
  sub ValidValue ($$$$$);
  
  ################ Local Variables ################
  
  # $requested_version holds the version that was mentioned in the 'use'
  # or 'require', if any. It can be used to enable or disable specific
  # features.
  my $requested_version = 0;
  
  ################ Resident subroutines ################
  
  sub ConfigDefaults() {
      # Handle POSIX compliancy.
      if ( defined $ENV{"POSIXLY_CORRECT"} ) {
  	$genprefix = "(--|-)";
  	$autoabbrev = 0;		# no automatic abbrev of options
  	$bundling = 0;			# no bundling of single letter switches
  	$getopt_compat = 0;		# disallow '+' to start options
  	$order = $REQUIRE_ORDER;
      }
      else {
  	$genprefix = "(--|-|\\+)";
  	$autoabbrev = 1;		# automatic abbrev of options
  	$bundling = 0;			# bundling off by default
  	$getopt_compat = 1;		# allow '+' to start options
  	$order = $PERMUTE;
      }
      # Other configurable settings.
      $debug = 0;			# for debugging
      $error = 0;			# error tally
      $ignorecase = 1;		# ignore case when matching options
      $passthrough = 0;		# leave unrecognized options alone
      $gnu_compat = 0;		# require --opt=val if value is optional
      $longprefix = "(--)";       # what does a long prefix look like
  }
  
  # Override import.
  sub import {
      my $pkg = shift;		# package
      my @syms = ();		# symbols to import
      my @config = ();		# configuration
      my $dest = \@syms;		# symbols first
      for ( @_ ) {
  	if ( $_ eq ':config' ) {
  	    $dest = \@config;	# config next
  	    next;
  	}
  	push(@$dest, $_);	# push
      }
      # Hide one level and call super.
      local $Exporter::ExportLevel = 1;
      push(@syms, qw(&GetOptions)) if @syms; # always export GetOptions
      $pkg->SUPER::import(@syms);
      # And configure.
      Configure(@config) if @config;
  }
  
  ################ Initialization ################
  
  # Values for $order. See GNU getopt.c for details.
  ($REQUIRE_ORDER, $PERMUTE, $RETURN_IN_ORDER) = (0..2);
  # Version major/minor numbers.
  ($major_version, $minor_version) = $VERSION =~ /^(\d+)\.(\d+)/;
  
  ConfigDefaults();
  
  ################ OO Interface ################
  
  package Getopt::Long::Parser;
  
  # Store a copy of the default configuration. Since ConfigDefaults has
  # just been called, what we get from Configure is the default.
  my $default_config = do {
      Getopt::Long::Configure ()
  };
  
  sub new {
      my $that = shift;
      my $class = ref($that) || $that;
      my %atts = @_;
  
      # Register the callers package.
      my $self = { caller_pkg => (caller)[0] };
  
      bless ($self, $class);
  
      # Process config attributes.
      if ( defined $atts{config} ) {
  	my $save = Getopt::Long::Configure ($default_config, @{$atts{config}});
  	$self->{settings} = Getopt::Long::Configure ($save);
  	delete ($atts{config});
      }
      # Else use default config.
      else {
  	$self->{settings} = $default_config;
      }
  
      if ( %atts ) {		# Oops
  	die(__PACKAGE__.": unhandled attributes: ".
  	    join(" ", sort(keys(%atts)))."\n");
      }
  
      $self;
  }
  
  sub configure {
      my ($self) = shift;
  
      # Restore settings, merge new settings in.
      my $save = Getopt::Long::Configure ($self->{settings}, @_);
  
      # Restore orig config and save the new config.
      $self->{settings} = Getopt::Long::Configure ($save);
  }
  
  sub getoptions {
      my ($self) = shift;
  
      # Restore config settings.
      my $save = Getopt::Long::Configure ($self->{settings});
  
      # Call main routine.
      my $ret = 0;
      $Getopt::Long::caller = $self->{caller_pkg};
  
      eval {
  	# Locally set exception handler to default, otherwise it will
  	# be called implicitly here, and again explicitly when we try
  	# to deliver the messages.
  	local ($SIG{__DIE__}) = 'DEFAULT';
  	$ret = Getopt::Long::GetOptions (@_);
      };
  
      # Restore saved settings.
      Getopt::Long::Configure ($save);
  
      # Handle errors and return value.
      die ($@) if $@;
      return $ret;
  }
  
  package Getopt::Long;
  
  ################ Back to Normal ################
  
  # Indices in option control info.
  # Note that ParseOptions uses the fields directly. Search for 'hard-wired'.
  use constant CTL_TYPE    => 0;
  #use constant   CTL_TYPE_FLAG   => '';
  #use constant   CTL_TYPE_NEG    => '!';
  #use constant   CTL_TYPE_INCR   => '+';
  #use constant   CTL_TYPE_INT    => 'i';
  #use constant   CTL_TYPE_INTINC => 'I';
  #use constant   CTL_TYPE_XINT   => 'o';
  #use constant   CTL_TYPE_FLOAT  => 'f';
  #use constant   CTL_TYPE_STRING => 's';
  
  use constant CTL_CNAME   => 1;
  
  use constant CTL_DEFAULT => 2;
  
  use constant CTL_DEST    => 3;
   use constant   CTL_DEST_SCALAR => 0;
   use constant   CTL_DEST_ARRAY  => 1;
   use constant   CTL_DEST_HASH   => 2;
   use constant   CTL_DEST_CODE   => 3;
  
  use constant CTL_AMIN    => 4;
  use constant CTL_AMAX    => 5;
  
  # FFU.
  #use constant CTL_RANGE   => ;
  #use constant CTL_REPEAT  => ;
  
  # Rather liberal patterns to match numbers.
  use constant PAT_INT   => "[-+]?_*[0-9][0-9_]*";
  use constant PAT_XINT  =>
    "(?:".
  	  "[-+]?_*[1-9][0-9_]*".
    "|".
  	  "0x_*[0-9a-f][0-9a-f_]*".
    "|".
  	  "0b_*[01][01_]*".
    "|".
  	  "0[0-7_]*".
    ")";
  use constant PAT_FLOAT => "[-+]?[0-9._]+(\.[0-9_]+)?([eE][-+]?[0-9_]+)?";
  
  sub GetOptions(@) {
      # Shift in default array.
      unshift(@_, \@ARGV);
      # Try to keep caller() and Carp consitent.
      goto &GetOptionsFromArray;
  }
  
  sub GetOptionsFromString(@) {
      my ($string) = shift;
      require Text::ParseWords;
      my $args = [ Text::ParseWords::shellwords($string) ];
      $caller ||= (caller)[0];	# current context
      my $ret = GetOptionsFromArray($args, @_);
      return ( $ret, $args ) if wantarray;
      if ( @$args ) {
  	$ret = 0;
  	warn("GetOptionsFromString: Excess data \"@$args\" in string \"$string\"\n");
      }
      $ret;
  }
  
  sub GetOptionsFromArray(@) {
  
      my ($argv, @optionlist) = @_;	# local copy of the option descriptions
      my $argend = '--';		# option list terminator
      my %opctl = ();		# table of option specs
      my $pkg = $caller || (caller)[0];	# current context
  				# Needed if linkage is omitted.
      my @ret = ();		# accum for non-options
      my %linkage;		# linkage
      my $userlinkage;		# user supplied HASH
      my $opt;			# current option
      my $prefix = $genprefix;	# current prefix
  
      $error = '';
  
      if ( $debug ) {
  	# Avoid some warnings if debugging.
  	local ($^W) = 0;
  	print STDERR
  	  ("Getopt::Long $Getopt::Long::VERSION (",
  	   '$Revision: 2.76 $', ") ",
  	   "called from package \"$pkg\".",
  	   "\n  ",
  	   "argv: (@$argv)",
  	   "\n  ",
  	   "autoabbrev=$autoabbrev,".
  	   "bundling=$bundling,",
  	   "getopt_compat=$getopt_compat,",
  	   "gnu_compat=$gnu_compat,",
  	   "order=$order,",
  	   "\n  ",
  	   "ignorecase=$ignorecase,",
  	   "requested_version=$requested_version,",
  	   "passthrough=$passthrough,",
  	   "genprefix=\"$genprefix\",",
  	   "longprefix=\"$longprefix\".",
  	   "\n");
      }
  
      # Check for ref HASH as first argument.
      # First argument may be an object. It's OK to use this as long
      # as it is really a hash underneath.
      $userlinkage = undef;
      if ( @optionlist && ref($optionlist[0]) and
  	 UNIVERSAL::isa($optionlist[0],'HASH') ) {
  	$userlinkage = shift (@optionlist);
  	print STDERR ("=> user linkage: $userlinkage\n") if $debug;
      }
  
      # See if the first element of the optionlist contains option
      # starter characters.
      # Be careful not to interpret '<>' as option starters.
      if ( @optionlist && $optionlist[0] =~ /^\W+$/
  	 && !($optionlist[0] eq '<>'
  	      && @optionlist > 0
  	      && ref($optionlist[1])) ) {
  	$prefix = shift (@optionlist);
  	# Turn into regexp. Needs to be parenthesized!
  	$prefix =~ s/(\W)/\\$1/g;
  	$prefix = "([" . $prefix . "])";
  	print STDERR ("=> prefix=\"$prefix\"\n") if $debug;
      }
  
      # Verify correctness of optionlist.
      %opctl = ();
      while ( @optionlist ) {
  	my $opt = shift (@optionlist);
  
  	unless ( defined($opt) ) {
  	    $error .= "Undefined argument in option spec\n";
  	    next;
  	}
  
  	# Strip leading prefix so people can specify "--foo=i" if they like.
  	$opt = $+ if $opt =~ /^$prefix+(.*)$/s;
  
  	if ( $opt eq '<>' ) {
  	    if ( (defined $userlinkage)
  		&& !(@optionlist > 0 && ref($optionlist[0]))
  		&& (exists $userlinkage->{$opt})
  		&& ref($userlinkage->{$opt}) ) {
  		unshift (@optionlist, $userlinkage->{$opt});
  	    }
  	    unless ( @optionlist > 0
  		    && ref($optionlist[0]) && ref($optionlist[0]) eq 'CODE' ) {
  		$error .= "Option spec <> requires a reference to a subroutine\n";
  		# Kill the linkage (to avoid another error).
  		shift (@optionlist)
  		  if @optionlist && ref($optionlist[0]);
  		next;
  	    }
  	    $linkage{'<>'} = shift (@optionlist);
  	    next;
  	}
  
  	# Parse option spec.
  	my ($name, $orig) = ParseOptionSpec ($opt, \%opctl);
  	unless ( defined $name ) {
  	    # Failed. $orig contains the error message. Sorry for the abuse.
  	    $error .= $orig;
  	    # Kill the linkage (to avoid another error).
  	    shift (@optionlist)
  	      if @optionlist && ref($optionlist[0]);
  	    next;
  	}
  
  	# If no linkage is supplied in the @optionlist, copy it from
  	# the userlinkage if available.
  	if ( defined $userlinkage ) {
  	    unless ( @optionlist > 0 && ref($optionlist[0]) ) {
  		if ( exists $userlinkage->{$orig} &&
  		     ref($userlinkage->{$orig}) ) {
  		    print STDERR ("=> found userlinkage for \"$orig\": ",
  				  "$userlinkage->{$orig}\n")
  			if $debug;
  		    unshift (@optionlist, $userlinkage->{$orig});
  		}
  		else {
  		    # Do nothing. Being undefined will be handled later.
  		    next;
  		}
  	    }
  	}
  
  	# Copy the linkage. If omitted, link to global variable.
  	if ( @optionlist > 0 && ref($optionlist[0]) ) {
  	    print STDERR ("=> link \"$orig\" to $optionlist[0]\n")
  		if $debug;
  	    my $rl = ref($linkage{$orig} = shift (@optionlist));
  
  	    if ( $rl eq "ARRAY" ) {
  		$opctl{$name}[CTL_DEST] = CTL_DEST_ARRAY;
  	    }
  	    elsif ( $rl eq "HASH" ) {
  		$opctl{$name}[CTL_DEST] = CTL_DEST_HASH;
  	    }
  	    elsif ( $rl eq "SCALAR" || $rl eq "REF" ) {
  #		if ( $opctl{$name}[CTL_DEST] == CTL_DEST_ARRAY ) {
  #		    my $t = $linkage{$orig};
  #		    $$t = $linkage{$orig} = [];
  #		}
  #		elsif ( $opctl{$name}[CTL_DEST] == CTL_DEST_HASH ) {
  #		}
  #		else {
  		    # Ok.
  #		}
  	    }
  	    elsif ( $rl eq "CODE" ) {
  		# Ok.
  	    }
  	    else {
  		$error .= "Invalid option linkage for \"$opt\"\n";
  	    }
  	}
  	else {
  	    # Link to global $opt_XXX variable.
  	    # Make sure a valid perl identifier results.
  	    my $ov = $orig;
  	    $ov =~ s/\W/_/g;
  	    if ( $opctl{$name}[CTL_DEST] == CTL_DEST_ARRAY ) {
  		print STDERR ("=> link \"$orig\" to \@$pkg","::opt_$ov\n")
  		    if $debug;
  		eval ("\$linkage{\$orig} = \\\@".$pkg."::opt_$ov;");
  	    }
  	    elsif ( $opctl{$name}[CTL_DEST] == CTL_DEST_HASH ) {
  		print STDERR ("=> link \"$orig\" to \%$pkg","::opt_$ov\n")
  		    if $debug;
  		eval ("\$linkage{\$orig} = \\\%".$pkg."::opt_$ov;");
  	    }
  	    else {
  		print STDERR ("=> link \"$orig\" to \$$pkg","::opt_$ov\n")
  		    if $debug;
  		eval ("\$linkage{\$orig} = \\\$".$pkg."::opt_$ov;");
  	    }
  	}
  
  	if ( $opctl{$name}[CTL_TYPE] eq 'I'
  	     && ( $opctl{$name}[CTL_DEST] == CTL_DEST_ARRAY
  		  || $opctl{$name}[CTL_DEST] == CTL_DEST_HASH )
  	   ) {
  	    $error .= "Invalid option linkage for \"$opt\"\n";
  	}
  
      }
  
      # Bail out if errors found.
      die ($error) if $error;
      $error = 0;
  
      # Supply --version and --help support, if needed and allowed.
      if ( defined($auto_version) ? $auto_version : ($requested_version >= 2.3203) ) {
  	if ( !defined($opctl{version}) ) {
  	    $opctl{version} = ['','version',0,CTL_DEST_CODE,undef];
  	    $linkage{version} = \&VersionMessage;
  	}
  	$auto_version = 1;
      }
      if ( defined($auto_help) ? $auto_help : ($requested_version >= 2.3203) ) {
  	if ( !defined($opctl{help}) && !defined($opctl{'?'}) ) {
  	    $opctl{help} = $opctl{'?'} = ['','help',0,CTL_DEST_CODE,undef];
  	    $linkage{help} = \&HelpMessage;
  	}
  	$auto_help = 1;
      }
  
      # Show the options tables if debugging.
      if ( $debug ) {
  	my ($arrow, $k, $v);
  	$arrow = "=> ";
  	while ( ($k,$v) = each(%opctl) ) {
  	    print STDERR ($arrow, "\$opctl{$k} = $v ", OptCtl($v), "\n");
  	    $arrow = "   ";
  	}
      }
  
      # Process argument list
      my $goon = 1;
      while ( $goon && @$argv > 0 ) {
  
  	# Get next argument.
  	$opt = shift (@$argv);
  	print STDERR ("=> arg \"", $opt, "\"\n") if $debug;
  
  	# Double dash is option list terminator.
  	if ( $opt eq $argend ) {
  	  push (@ret, $argend) if $passthrough;
  	  last;
  	}
  
  	# Look it up.
  	my $tryopt = $opt;
  	my $found;		# success status
  	my $key;		# key (if hash type)
  	my $arg;		# option argument
  	my $ctl;		# the opctl entry
  
  	($found, $opt, $ctl, $arg, $key) =
  	  FindOption ($argv, $prefix, $argend, $opt, \%opctl);
  
  	if ( $found ) {
  
  	    # FindOption undefines $opt in case of errors.
  	    next unless defined $opt;
  
  	    my $argcnt = 0;
  	    while ( defined $arg ) {
  
  		# Get the canonical name.
  		print STDERR ("=> cname for \"$opt\" is ") if $debug;
  		$opt = $ctl->[CTL_CNAME];
  		print STDERR ("\"$ctl->[CTL_CNAME]\"\n") if $debug;
  
  		if ( defined $linkage{$opt} ) {
  		    print STDERR ("=> ref(\$L{$opt}) -> ",
  				  ref($linkage{$opt}), "\n") if $debug;
  
  		    if ( ref($linkage{$opt}) eq 'SCALAR'
  			 || ref($linkage{$opt}) eq 'REF' ) {
  			if ( $ctl->[CTL_TYPE] eq '+' ) {
  			    print STDERR ("=> \$\$L{$opt} += \"$arg\"\n")
  			      if $debug;
  			    if ( defined ${$linkage{$opt}} ) {
  			        ${$linkage{$opt}} += $arg;
  			    }
  		            else {
  			        ${$linkage{$opt}} = $arg;
  			    }
  			}
  			elsif ( $ctl->[CTL_DEST] == CTL_DEST_ARRAY ) {
  			    print STDERR ("=> ref(\$L{$opt}) auto-vivified",
  					  " to ARRAY\n")
  			      if $debug;
  			    my $t = $linkage{$opt};
  			    $$t = $linkage{$opt} = [];
  			    print STDERR ("=> push(\@{\$L{$opt}, \"$arg\")\n")
  			      if $debug;
  			    push (@{$linkage{$opt}}, $arg);
  			}
  			elsif ( $ctl->[CTL_DEST] == CTL_DEST_HASH ) {
  			    print STDERR ("=> ref(\$L{$opt}) auto-vivified",
  					  " to HASH\n")
  			      if $debug;
  			    my $t = $linkage{$opt};
  			    $$t = $linkage{$opt} = {};
  			    print STDERR ("=> \$\$L{$opt}->{$key} = \"$arg\"\n")
  			      if $debug;
  			    $linkage{$opt}->{$key} = $arg;
  			}
  			else {
  			    print STDERR ("=> \$\$L{$opt} = \"$arg\"\n")
  			      if $debug;
  			    ${$linkage{$opt}} = $arg;
  		        }
  		    }
  		    elsif ( ref($linkage{$opt}) eq 'ARRAY' ) {
  			print STDERR ("=> push(\@{\$L{$opt}, \"$arg\")\n")
  			    if $debug;
  			push (@{$linkage{$opt}}, $arg);
  		    }
  		    elsif ( ref($linkage{$opt}) eq 'HASH' ) {
  			print STDERR ("=> \$\$L{$opt}->{$key} = \"$arg\"\n")
  			    if $debug;
  			$linkage{$opt}->{$key} = $arg;
  		    }
  		    elsif ( ref($linkage{$opt}) eq 'CODE' ) {
  			print STDERR ("=> &L{$opt}(\"$opt\"",
  				      $ctl->[CTL_DEST] == CTL_DEST_HASH ? ", \"$key\"" : "",
  				      ", \"$arg\")\n")
  			    if $debug;
  			my $eval_error = do {
  			    local $@;
  			    local $SIG{__DIE__}  = 'DEFAULT';
  			    eval {
  				&{$linkage{$opt}}
  				  (Getopt::Long::CallBack->new
  				   (name    => $opt,
  				    ctl     => $ctl,
  				    opctl   => \%opctl,
  				    linkage => \%linkage,
  				    prefix  => $prefix,
  				   ),
  				   $ctl->[CTL_DEST] == CTL_DEST_HASH ? ($key) : (),
  				   $arg);
  			    };
  			    $@;
  			};
  			print STDERR ("=> die($eval_error)\n")
  			  if $debug && $eval_error ne '';
  			if ( $eval_error =~ /^!/ ) {
  			    if ( $eval_error =~ /^!FINISH\b/ ) {
  				$goon = 0;
  			    }
  			}
  			elsif ( $eval_error ne '' ) {
  			    warn ($eval_error);
  			    $error++;
  			}
  		    }
  		    else {
  			print STDERR ("Invalid REF type \"", ref($linkage{$opt}),
  				      "\" in linkage\n");
  			die("Getopt::Long -- internal error!\n");
  		    }
  		}
  		# No entry in linkage means entry in userlinkage.
  		elsif ( $ctl->[CTL_DEST] == CTL_DEST_ARRAY ) {
  		    if ( defined $userlinkage->{$opt} ) {
  			print STDERR ("=> push(\@{\$L{$opt}}, \"$arg\")\n")
  			    if $debug;
  			push (@{$userlinkage->{$opt}}, $arg);
  		    }
  		    else {
  			print STDERR ("=>\$L{$opt} = [\"$arg\"]\n")
  			    if $debug;
  			$userlinkage->{$opt} = [$arg];
  		    }
  		}
  		elsif ( $ctl->[CTL_DEST] == CTL_DEST_HASH ) {
  		    if ( defined $userlinkage->{$opt} ) {
  			print STDERR ("=> \$L{$opt}->{$key} = \"$arg\"\n")
  			    if $debug;
  			$userlinkage->{$opt}->{$key} = $arg;
  		    }
  		    else {
  			print STDERR ("=>\$L{$opt} = {$key => \"$arg\"}\n")
  			    if $debug;
  			$userlinkage->{$opt} = {$key => $arg};
  		    }
  		}
  		else {
  		    if ( $ctl->[CTL_TYPE] eq '+' ) {
  			print STDERR ("=> \$L{$opt} += \"$arg\"\n")
  			  if $debug;
  			if ( defined $userlinkage->{$opt} ) {
  			    $userlinkage->{$opt} += $arg;
  			}
  			else {
  			    $userlinkage->{$opt} = $arg;
  			}
  		    }
  		    else {
  			print STDERR ("=>\$L{$opt} = \"$arg\"\n") if $debug;
  			$userlinkage->{$opt} = $arg;
  		    }
  		}
  
  		$argcnt++;
  		last if $argcnt >= $ctl->[CTL_AMAX] && $ctl->[CTL_AMAX] != -1;
  		undef($arg);
  
  		# Need more args?
  		if ( $argcnt < $ctl->[CTL_AMIN] ) {
  		    if ( @$argv ) {
  			if ( ValidValue($ctl, $argv->[0], 1, $argend, $prefix) ) {
  			    $arg = shift(@$argv);
  			    $arg =~ tr/_//d if $ctl->[CTL_TYPE] =~ /^[iIo]$/;
  			    ($key,$arg) = $arg =~ /^([^=]+)=(.*)/
  			      if $ctl->[CTL_DEST] == CTL_DEST_HASH;
  			    next;
  			}
  			warn("Value \"$$argv[0]\" invalid for option $opt\n");
  			$error++;
  		    }
  		    else {
  			warn("Insufficient arguments for option $opt\n");
  			$error++;
  		    }
  		}
  
  		# Any more args?
  		if ( @$argv && ValidValue($ctl, $argv->[0], 0, $argend, $prefix) ) {
  		    $arg = shift(@$argv);
  		    $arg =~ tr/_//d if $ctl->[CTL_TYPE] =~ /^[iIo]$/;
  		    ($key,$arg) = $arg =~ /^([^=]+)=(.*)/
  		      if $ctl->[CTL_DEST] == CTL_DEST_HASH;
  		    next;
  		}
  	    }
  	}
  
  	# Not an option. Save it if we $PERMUTE and don't have a <>.
  	elsif ( $order == $PERMUTE ) {
  	    # Try non-options call-back.
  	    my $cb;
  	    if ( (defined ($cb = $linkage{'<>'})) ) {
  		print STDERR ("=> &L{$tryopt}(\"$tryopt\")\n")
  		  if $debug;
  		my $eval_error = do {
  		    local $@;
  		    local $SIG{__DIE__}  = 'DEFAULT';
  		    eval {
  			&$cb
  			  (Getopt::Long::CallBack->new
  			   (name    => $tryopt,
  			    ctl     => $ctl,
  			    opctl   => \%opctl,
  			    linkage => \%linkage,
  			    prefix  => $prefix,
  			   ));
  		    };
  		    $@;
  		};
  		print STDERR ("=> die($eval_error)\n")
  		  if $debug && $eval_error ne '';
  		if ( $eval_error =~ /^!/ ) {
  		    if ( $eval_error =~ /^!FINISH\b/ ) {
  			$goon = 0;
  		    }
  		}
  		elsif ( $eval_error ne '' ) {
  		    warn ($eval_error);
  		    $error++;
  		}
  	    }
  	    else {
  		print STDERR ("=> saving \"$tryopt\" ",
  			      "(not an option, may permute)\n") if $debug;
  		push (@ret, $tryopt);
  	    }
  	    next;
  	}
  
  	# ...otherwise, terminate.
  	else {
  	    # Push this one back and exit.
  	    unshift (@$argv, $tryopt);
  	    return ($error == 0);
  	}
  
      }
  
      # Finish.
      if ( @ret && $order == $PERMUTE ) {
  	#  Push back accumulated arguments
  	print STDERR ("=> restoring \"", join('" "', @ret), "\"\n")
  	    if $debug;
  	unshift (@$argv, @ret);
      }
  
      return ($error == 0);
  }
  
  # A readable representation of what's in an optbl.
  sub OptCtl ($) {
      my ($v) = @_;
      my @v = map { defined($_) ? ($_) : ("<undef>") } @$v;
      "[".
        join(",",
  	   "\"$v[CTL_TYPE]\"",
  	   "\"$v[CTL_CNAME]\"",
  	   "\"$v[CTL_DEFAULT]\"",
  	   ("\$","\@","\%","\&")[$v[CTL_DEST] || 0],
  	   $v[CTL_AMIN] || '',
  	   $v[CTL_AMAX] || '',
  #	   $v[CTL_RANGE] || '',
  #	   $v[CTL_REPEAT] || '',
  	  ). "]";
  }
  
  # Parse an option specification and fill the tables.
  sub ParseOptionSpec ($$) {
      my ($opt, $opctl) = @_;
  
      # Match option spec.
      if ( $opt !~ m;^
  		   (
  		     # Option name
  		     (?: \w+[-\w]* )
  		     # Alias names, or "?"
  		     (?: \| (?: \? | \w[-\w]* ) )*
  		   )?
  		   (
  		     # Either modifiers ...
  		     [!+]
  		     |
  		     # ... or a value/dest/repeat specification
  		     [=:] [ionfs] [@%]? (?: \{\d*,?\d*\} )?
  		     |
  		     # ... or an optional-with-default spec
  		     : (?: -?\d+ | \+ ) [@%]?
  		   )?
  		   $;x ) {
  	return (undef, "Error in option spec: \"$opt\"\n");
      }
  
      my ($names, $spec) = ($1, $2);
      $spec = '' unless defined $spec;
  
      # $orig keeps track of the primary name the user specified.
      # This name will be used for the internal or external linkage.
      # In other words, if the user specifies "FoO|BaR", it will
      # match any case combinations of 'foo' and 'bar', but if a global
      # variable needs to be set, it will be $opt_FoO in the exact case
      # as specified.
      my $orig;
  
      my @names;
      if ( defined $names ) {
  	@names =  split (/\|/, $names);
  	$orig = $names[0];
      }
      else {
  	@names = ('');
  	$orig = '';
      }
  
      # Construct the opctl entries.
      my $entry;
      if ( $spec eq '' || $spec eq '+' || $spec eq '!' ) {
  	# Fields are hard-wired here.
  	$entry = [$spec,$orig,undef,CTL_DEST_SCALAR,0,0];
      }
      elsif ( $spec =~ /^:(-?\d+|\+)([@%])?$/ ) {
  	my $def = $1;
  	my $dest = $2;
  	my $type = $def eq '+' ? 'I' : 'i';
  	$dest ||= '$';
  	$dest = $dest eq '@' ? CTL_DEST_ARRAY
  	  : $dest eq '%' ? CTL_DEST_HASH : CTL_DEST_SCALAR;
  	# Fields are hard-wired here.
  	$entry = [$type,$orig,$def eq '+' ? undef : $def,
  		  $dest,0,1];
      }
      else {
  	my ($mand, $type, $dest) =
  	  $spec =~ /^([=:])([ionfs])([@%])?(\{(\d+)?(,)?(\d+)?\})?$/;
  	return (undef, "Cannot repeat while bundling: \"$opt\"\n")
  	  if $bundling && defined($4);
  	my ($mi, $cm, $ma) = ($5, $6, $7);
  	return (undef, "{0} is useless in option spec: \"$opt\"\n")
  	  if defined($mi) && !$mi && !defined($ma) && !defined($cm);
  
  	$type = 'i' if $type eq 'n';
  	$dest ||= '$';
  	$dest = $dest eq '@' ? CTL_DEST_ARRAY
  	  : $dest eq '%' ? CTL_DEST_HASH : CTL_DEST_SCALAR;
  	# Default minargs to 1/0 depending on mand status.
  	$mi = $mand eq '=' ? 1 : 0 unless defined $mi;
  	# Adjust mand status according to minargs.
  	$mand = $mi ? '=' : ':';
  	# Adjust maxargs.
  	$ma = $mi ? $mi : 1 unless defined $ma || defined $cm;
  	return (undef, "Max must be greater than zero in option spec: \"$opt\"\n")
  	  if defined($ma) && !$ma;
  	return (undef, "Max less than min in option spec: \"$opt\"\n")
  	  if defined($ma) && $ma < $mi;
  
  	# Fields are hard-wired here.
  	$entry = [$type,$orig,undef,$dest,$mi,$ma||-1];
      }
  
      # Process all names. First is canonical, the rest are aliases.
      my $dups = '';
      foreach ( @names ) {
  
  	$_ = lc ($_)
  	  if $ignorecase > (($bundling && length($_) == 1) ? 1 : 0);
  
  	if ( exists $opctl->{$_} ) {
  	    $dups .= "Duplicate specification \"$opt\" for option \"$_\"\n";
  	}
  
  	if ( $spec eq '!' ) {
  	    $opctl->{"no$_"} = $entry;
  	    $opctl->{"no-$_"} = $entry;
  	    $opctl->{$_} = [@$entry];
  	    $opctl->{$_}->[CTL_TYPE] = '';
  	}
  	else {
  	    $opctl->{$_} = $entry;
  	}
      }
  
      if ( $dups && $^W ) {
  	foreach ( split(/\n+/, $dups) ) {
  	    warn($_."\n");
  	}
      }
      ($names[0], $orig);
  }
  
  # Option lookup.
  sub FindOption ($$$$$) {
  
      # returns (1, $opt, $ctl, $arg, $key) if okay,
      # returns (1, undef) if option in error,
      # returns (0) otherwise.
  
      my ($argv, $prefix, $argend, $opt, $opctl) = @_;
  
      print STDERR ("=> find \"$opt\"\n") if $debug;
  
      return (0) unless $opt =~ /^$prefix(.*)$/s;
      return (0) if $opt eq "-" && !defined $opctl->{''};
  
      $opt = $+;
      my $starter = $1;
  
      print STDERR ("=> split \"$starter\"+\"$opt\"\n") if $debug;
  
      my $optarg;			# value supplied with --opt=value
      my $rest;			# remainder from unbundling
  
      # If it is a long option, it may include the value.
      # With getopt_compat, only if not bundling.
      if ( ($starter=~/^$longprefix$/
            || ($getopt_compat && ($bundling == 0 || $bundling == 2)))
  	  && $opt =~ /^([^=]+)=(.*)$/s ) {
  	$opt = $1;
  	$optarg = $2;
  	print STDERR ("=> option \"", $opt,
  		      "\", optarg = \"$optarg\"\n") if $debug;
      }
  
      #### Look it up ###
  
      my $tryopt = $opt;		# option to try
  
      if ( $bundling && $starter eq '-' ) {
  
  	# To try overrides, obey case ignore.
  	$tryopt = $ignorecase ? lc($opt) : $opt;
  
  	# If bundling == 2, long options can override bundles.
  	if ( $bundling == 2 && length($tryopt) > 1
  	     && defined ($opctl->{$tryopt}) ) {
  	    print STDERR ("=> $starter$tryopt overrides unbundling\n")
  	      if $debug;
  	}
  	else {
  	    $tryopt = $opt;
  	    # Unbundle single letter option.
  	    $rest = length ($tryopt) > 0 ? substr ($tryopt, 1) : '';
  	    $tryopt = substr ($tryopt, 0, 1);
  	    $tryopt = lc ($tryopt) if $ignorecase > 1;
  	    print STDERR ("=> $starter$tryopt unbundled from ",
  			  "$starter$tryopt$rest\n") if $debug;
  	    $rest = undef unless $rest ne '';
  	}
      }
  
      # Try auto-abbreviation.
      elsif ( $autoabbrev && $opt ne "" ) {
  	# Sort the possible long option names.
  	my @names = sort(keys (%$opctl));
  	# Downcase if allowed.
  	$opt = lc ($opt) if $ignorecase;
  	$tryopt = $opt;
  	# Turn option name into pattern.
  	my $pat = quotemeta ($opt);
  	# Look up in option names.
  	my @hits = grep (/^$pat/, @names);
  	print STDERR ("=> ", scalar(@hits), " hits (@hits) with \"$pat\" ",
  		      "out of ", scalar(@names), "\n") if $debug;
  
  	# Check for ambiguous results.
  	unless ( (@hits <= 1) || (grep ($_ eq $opt, @hits) == 1) ) {
  	    # See if all matches are for the same option.
  	    my %hit;
  	    foreach ( @hits ) {
  		my $hit = $_;
  		$hit = $opctl->{$hit}->[CTL_CNAME]
  		  if defined $opctl->{$hit}->[CTL_CNAME];
  		$hit{$hit} = 1;
  	    }
  	    # Remove auto-supplied options (version, help).
  	    if ( keys(%hit) == 2 ) {
  		if ( $auto_version && exists($hit{version}) ) {
  		    delete $hit{version};
  		}
  		elsif ( $auto_help && exists($hit{help}) ) {
  		    delete $hit{help};
  		}
  	    }
  	    # Now see if it really is ambiguous.
  	    unless ( keys(%hit) == 1 ) {
  		return (0) if $passthrough;
  		warn ("Option ", $opt, " is ambiguous (",
  		      join(", ", @hits), ")\n");
  		$error++;
  		return (1, undef);
  	    }
  	    @hits = keys(%hit);
  	}
  
  	# Complete the option name, if appropriate.
  	if ( @hits == 1 && $hits[0] ne $opt ) {
  	    $tryopt = $hits[0];
  	    $tryopt = lc ($tryopt) if $ignorecase;
  	    print STDERR ("=> option \"$opt\" -> \"$tryopt\"\n")
  		if $debug;
  	}
      }
  
      # Map to all lowercase if ignoring case.
      elsif ( $ignorecase ) {
  	$tryopt = lc ($opt);
      }
  
      # Check validity by fetching the info.
      my $ctl = $opctl->{$tryopt};
      unless  ( defined $ctl ) {
  	return (0) if $passthrough;
  	# Pretend one char when bundling.
  	if ( $bundling == 1 && length($starter) == 1 ) {
  	    $opt = substr($opt,0,1);
              unshift (@$argv, $starter.$rest) if defined $rest;
  	}
  	if ( $opt eq "" ) {
  	    warn ("Missing option after ", $starter, "\n");
  	}
  	else {
  	    warn ("Unknown option: ", $opt, "\n");
  	}
  	$error++;
  	return (1, undef);
      }
      # Apparently valid.
      $opt = $tryopt;
      print STDERR ("=> found ", OptCtl($ctl),
  		  " for \"", $opt, "\"\n") if $debug;
  
      #### Determine argument status ####
  
      # If it is an option w/o argument, we're almost finished with it.
      my $type = $ctl->[CTL_TYPE];
      my $arg;
  
      if ( $type eq '' || $type eq '!' || $type eq '+' ) {
  	if ( defined $optarg ) {
  	    return (0) if $passthrough;
  	    warn ("Option ", $opt, " does not take an argument\n");
  	    $error++;
  	    undef $opt;
  	}
  	elsif ( $type eq '' || $type eq '+' ) {
  	    # Supply explicit value.
  	    $arg = 1;
  	}
  	else {
  	    $opt =~ s/^no-?//i;	# strip NO prefix
  	    $arg = 0;		# supply explicit value
  	}
  	unshift (@$argv, $starter.$rest) if defined $rest;
  	return (1, $opt, $ctl, $arg);
      }
  
      # Get mandatory status and type info.
      my $mand = $ctl->[CTL_AMIN];
  
      # Check if there is an option argument available.
      if ( $gnu_compat && defined $optarg && $optarg eq '' ) {
  	return (1, $opt, $ctl, $type eq 's' ? '' : 0) ;#unless $mand;
  	$optarg = 0 unless $type eq 's';
      }
  
      # Check if there is an option argument available.
      if ( defined $optarg
  	 ? ($optarg eq '')
  	 : !(defined $rest || @$argv > 0) ) {
  	# Complain if this option needs an argument.
  #	if ( $mand && !($type eq 's' ? defined($optarg) : 0) ) {
  	if ( $mand ) {
  	    return (0) if $passthrough;
  	    warn ("Option ", $opt, " requires an argument\n");
  	    $error++;
  	    return (1, undef);
  	}
  	if ( $type eq 'I' ) {
  	    # Fake incremental type.
  	    my @c = @$ctl;
  	    $c[CTL_TYPE] = '+';
  	    return (1, $opt, \@c, 1);
  	}
  	return (1, $opt, $ctl,
  		defined($ctl->[CTL_DEFAULT]) ? $ctl->[CTL_DEFAULT] :
  		$type eq 's' ? '' : 0);
      }
  
      # Get (possibly optional) argument.
      $arg = (defined $rest ? $rest
  	    : (defined $optarg ? $optarg : shift (@$argv)));
  
      # Get key if this is a "name=value" pair for a hash option.
      my $key;
      if ($ctl->[CTL_DEST] == CTL_DEST_HASH && defined $arg) {
  	($key, $arg) = ($arg =~ /^([^=]*)=(.*)$/s) ? ($1, $2)
  	  : ($arg, defined($ctl->[CTL_DEFAULT]) ? $ctl->[CTL_DEFAULT] :
  	     ($mand ? undef : ($type eq 's' ? "" : 1)));
  	if (! defined $arg) {
  	    warn ("Option $opt, key \"$key\", requires a value\n");
  	    $error++;
  	    # Push back.
  	    unshift (@$argv, $starter.$rest) if defined $rest;
  	    return (1, undef);
  	}
      }
  
      #### Check if the argument is valid for this option ####
  
      my $key_valid = $ctl->[CTL_DEST] == CTL_DEST_HASH ? "[^=]+=" : "";
  
      if ( $type eq 's' ) {	# string
  	# A mandatory string takes anything.
  	return (1, $opt, $ctl, $arg, $key) if $mand;
  
  	# Same for optional string as a hash value
  	return (1, $opt, $ctl, $arg, $key)
  	  if $ctl->[CTL_DEST] == CTL_DEST_HASH;
  
  	# An optional string takes almost anything.
  	return (1, $opt, $ctl, $arg, $key)
  	  if defined $optarg || defined $rest;
  	return (1, $opt, $ctl, $arg, $key) if $arg eq "-"; # ??
  
  	# Check for option or option list terminator.
  	if ($arg eq $argend ||
  	    $arg =~ /^$prefix.+/) {
  	    # Push back.
  	    unshift (@$argv, $arg);
  	    # Supply empty value.
  	    $arg = '';
  	}
      }
  
      elsif ( $type eq 'i'	# numeric/integer
              || $type eq 'I'	# numeric/integer w/ incr default
  	    || $type eq 'o' ) { # dec/oct/hex/bin value
  
  	my $o_valid = $type eq 'o' ? PAT_XINT : PAT_INT;
  
  	if ( $bundling && defined $rest
  	     && $rest =~ /^($key_valid)($o_valid)(.*)$/si ) {
  	    ($key, $arg, $rest) = ($1, $2, $+);
  	    chop($key) if $key;
  	    $arg = ($type eq 'o' && $arg =~ /^0/) ? oct($arg) : 0+$arg;
  	    unshift (@$argv, $starter.$rest) if defined $rest && $rest ne '';
  	}
  	elsif ( $arg =~ /^$o_valid$/si ) {
  	    $arg =~ tr/_//d;
  	    $arg = ($type eq 'o' && $arg =~ /^0/) ? oct($arg) : 0+$arg;
  	}
  	else {
  	    if ( defined $optarg || $mand ) {
  		if ( $passthrough ) {
  		    unshift (@$argv, defined $rest ? $starter.$rest : $arg)
  		      unless defined $optarg;
  		    return (0);
  		}
  		warn ("Value \"", $arg, "\" invalid for option ",
  		      $opt, " (",
  		      $type eq 'o' ? "extended " : '',
  		      "number expected)\n");
  		$error++;
  		# Push back.
  		unshift (@$argv, $starter.$rest) if defined $rest;
  		return (1, undef);
  	    }
  	    else {
  		# Push back.
  		unshift (@$argv, defined $rest ? $starter.$rest : $arg);
  		if ( $type eq 'I' ) {
  		    # Fake incremental type.
  		    my @c = @$ctl;
  		    $c[CTL_TYPE] = '+';
  		    return (1, $opt, \@c, 1);
  		}
  		# Supply default value.
  		$arg = defined($ctl->[CTL_DEFAULT]) ? $ctl->[CTL_DEFAULT] : 0;
  	    }
  	}
      }
  
      elsif ( $type eq 'f' ) { # real number, int is also ok
  	# We require at least one digit before a point or 'e',
  	# and at least one digit following the point and 'e'.
  	# [-]NN[.NN][eNN]
  	my $o_valid = PAT_FLOAT;
  	if ( $bundling && defined $rest &&
  	     $rest =~ /^($key_valid)($o_valid)(.*)$/s ) {
  	    $arg =~ tr/_//d;
  	    ($key, $arg, $rest) = ($1, $2, $+);
  	    chop($key) if $key;
  	    unshift (@$argv, $starter.$rest) if defined $rest && $rest ne '';
  	}
  	elsif ( $arg =~ /^$o_valid$/ ) {
  	    $arg =~ tr/_//d;
  	}
  	else {
  	    if ( defined $optarg || $mand ) {
  		if ( $passthrough ) {
  		    unshift (@$argv, defined $rest ? $starter.$rest : $arg)
  		      unless defined $optarg;
  		    return (0);
  		}
  		warn ("Value \"", $arg, "\" invalid for option ",
  		      $opt, " (real number expected)\n");
  		$error++;
  		# Push back.
  		unshift (@$argv, $starter.$rest) if defined $rest;
  		return (1, undef);
  	    }
  	    else {
  		# Push back.
  		unshift (@$argv, defined $rest ? $starter.$rest : $arg);
  		# Supply default value.
  		$arg = 0.0;
  	    }
  	}
      }
      else {
  	die("Getopt::Long internal error (Can't happen)\n");
      }
      return (1, $opt, $ctl, $arg, $key);
  }
  
  sub ValidValue ($$$$$) {
      my ($ctl, $arg, $mand, $argend, $prefix) = @_;
  
      if ( $ctl->[CTL_DEST] == CTL_DEST_HASH ) {
  	return 0 unless $arg =~ /[^=]+=(.*)/;
  	$arg = $1;
      }
  
      my $type = $ctl->[CTL_TYPE];
  
      if ( $type eq 's' ) {	# string
  	# A mandatory string takes anything.
  	return (1) if $mand;
  
  	return (1) if $arg eq "-";
  
  	# Check for option or option list terminator.
  	return 0 if $arg eq $argend || $arg =~ /^$prefix.+/;
  	return 1;
      }
  
      elsif ( $type eq 'i'	# numeric/integer
              || $type eq 'I'	# numeric/integer w/ incr default
  	    || $type eq 'o' ) { # dec/oct/hex/bin value
  
  	my $o_valid = $type eq 'o' ? PAT_XINT : PAT_INT;
  	return $arg =~ /^$o_valid$/si;
      }
  
      elsif ( $type eq 'f' ) { # real number, int is also ok
  	# We require at least one digit before a point or 'e',
  	# and at least one digit following the point and 'e'.
  	# [-]NN[.NN][eNN]
  	my $o_valid = PAT_FLOAT;
  	return $arg =~ /^$o_valid$/;
      }
      die("ValidValue: Cannot happen\n");
  }
  
  # Getopt::Long Configuration.
  sub Configure (@) {
      my (@options) = @_;
  
      my $prevconfig =
        [ $error, $debug, $major_version, $minor_version,
  	$autoabbrev, $getopt_compat, $ignorecase, $bundling, $order,
  	$gnu_compat, $passthrough, $genprefix, $auto_version, $auto_help,
  	$longprefix ];
  
      if ( ref($options[0]) eq 'ARRAY' ) {
  	( $error, $debug, $major_version, $minor_version,
  	  $autoabbrev, $getopt_compat, $ignorecase, $bundling, $order,
  	  $gnu_compat, $passthrough, $genprefix, $auto_version, $auto_help,
  	  $longprefix ) = @{shift(@options)};
      }
  
      my $opt;
      foreach $opt ( @options ) {
  	my $try = lc ($opt);
  	my $action = 1;
  	if ( $try =~ /^no_?(.*)$/s ) {
  	    $action = 0;
  	    $try = $+;
  	}
  	if ( ($try eq 'default' or $try eq 'defaults') && $action ) {
  	    ConfigDefaults ();
  	}
  	elsif ( ($try eq 'posix_default' or $try eq 'posix_defaults') ) {
  	    local $ENV{POSIXLY_CORRECT};
  	    $ENV{POSIXLY_CORRECT} = 1 if $action;
  	    ConfigDefaults ();
  	}
  	elsif ( $try eq 'auto_abbrev' or $try eq 'autoabbrev' ) {
  	    $autoabbrev = $action;
  	}
  	elsif ( $try eq 'getopt_compat' ) {
  	    $getopt_compat = $action;
              $genprefix = $action ? "(--|-|\\+)" : "(--|-)";
  	}
  	elsif ( $try eq 'gnu_getopt' ) {
  	    if ( $action ) {
  		$gnu_compat = 1;
  		$bundling = 1;
  		$getopt_compat = 0;
                  $genprefix = "(--|-)";
  		$order = $PERMUTE;
  	    }
  	}
  	elsif ( $try eq 'gnu_compat' ) {
  	    $gnu_compat = $action;
  	}
  	elsif ( $try =~ /^(auto_?)?version$/ ) {
  	    $auto_version = $action;
  	}
  	elsif ( $try =~ /^(auto_?)?help$/ ) {
  	    $auto_help = $action;
  	}
  	elsif ( $try eq 'ignorecase' or $try eq 'ignore_case' ) {
  	    $ignorecase = $action;
  	}
  	elsif ( $try eq 'ignorecase_always' or $try eq 'ignore_case_always' ) {
  	    $ignorecase = $action ? 2 : 0;
  	}
  	elsif ( $try eq 'bundling' ) {
  	    $bundling = $action;
  	}
  	elsif ( $try eq 'bundling_override' ) {
  	    $bundling = $action ? 2 : 0;
  	}
  	elsif ( $try eq 'require_order' ) {
  	    $order = $action ? $REQUIRE_ORDER : $PERMUTE;
  	}
  	elsif ( $try eq 'permute' ) {
  	    $order = $action ? $PERMUTE : $REQUIRE_ORDER;
  	}
  	elsif ( $try eq 'pass_through' or $try eq 'passthrough' ) {
  	    $passthrough = $action;
  	}
  	elsif ( $try =~ /^prefix=(.+)$/ && $action ) {
  	    $genprefix = $1;
  	    # Turn into regexp. Needs to be parenthesized!
  	    $genprefix = "(" . quotemeta($genprefix) . ")";
  	    eval { '' =~ /$genprefix/; };
  	    die("Getopt::Long: invalid pattern \"$genprefix\"") if $@;
  	}
  	elsif ( $try =~ /^prefix_pattern=(.+)$/ && $action ) {
  	    $genprefix = $1;
  	    # Parenthesize if needed.
  	    $genprefix = "(" . $genprefix . ")"
  	      unless $genprefix =~ /^\(.*\)$/;
  	    eval { '' =~ m"$genprefix"; };
  	    die("Getopt::Long: invalid pattern \"$genprefix\"") if $@;
  	}
  	elsif ( $try =~ /^long_prefix_pattern=(.+)$/ && $action ) {
  	    $longprefix = $1;
  	    # Parenthesize if needed.
  	    $longprefix = "(" . $longprefix . ")"
  	      unless $longprefix =~ /^\(.*\)$/;
  	    eval { '' =~ m"$longprefix"; };
  	    die("Getopt::Long: invalid long prefix pattern \"$longprefix\"") if $@;
  	}
  	elsif ( $try eq 'debug' ) {
  	    $debug = $action;
  	}
  	else {
  	    die("Getopt::Long: unknown config parameter \"$opt\"")
  	}
      }
      $prevconfig;
  }
  
  # Deprecated name.
  sub config (@) {
      Configure (@_);
  }
  
  # Issue a standard message for --version.
  #
  # The arguments are mostly the same as for Pod::Usage::pod2usage:
  #
  #  - a number (exit value)
  #  - a string (lead in message)
  #  - a hash with options. See Pod::Usage for details.
  #
  sub VersionMessage(@) {
      # Massage args.
      my $pa = setup_pa_args("version", @_);
  
      my $v = $main::VERSION;
      my $fh = $pa->{-output} ||
        ($pa->{-exitval} eq "NOEXIT" || $pa->{-exitval} < 2) ? \*STDOUT : \*STDERR;
  
      print $fh (defined($pa->{-message}) ? $pa->{-message} : (),
  	       $0, defined $v ? " version $v" : (),
  	       "\n",
  	       "(", __PACKAGE__, "::", "GetOptions",
  	       " version ",
  	       defined($Getopt::Long::VERSION_STRING)
  	         ? $Getopt::Long::VERSION_STRING : $VERSION, ";",
  	       " Perl version ",
  	       $] >= 5.006 ? sprintf("%vd", $^V) : $],
  	       ")\n");
      exit($pa->{-exitval}) unless $pa->{-exitval} eq "NOEXIT";
  }
  
  # Issue a standard message for --help.
  #
  # The arguments are the same as for Pod::Usage::pod2usage:
  #
  #  - a number (exit value)
  #  - a string (lead in message)
  #  - a hash with options. See Pod::Usage for details.
  #
  sub HelpMessage(@) {
      eval {
  	require Pod::Usage;
  	import Pod::Usage;
  	1;
      } || die("Cannot provide help: cannot load Pod::Usage\n");
  
      # Note that pod2usage will issue a warning if -exitval => NOEXIT.
      pod2usage(setup_pa_args("help", @_));
  
  }
  
  # Helper routine to set up a normalized hash ref to be used as
  # argument to pod2usage.
  sub setup_pa_args($@) {
      my $tag = shift;		# who's calling
  
      # If called by direct binding to an option, it will get the option
      # name and value as arguments. Remove these, if so.
      @_ = () if @_ == 2 && $_[0] eq $tag;
  
      my $pa;
      if ( @_ > 1 ) {
  	$pa = { @_ };
      }
      else {
  	$pa = shift || {};
      }
  
      # At this point, $pa can be a number (exit value), string
      # (message) or hash with options.
  
      if ( UNIVERSAL::isa($pa, 'HASH') ) {
  	# Get rid of -msg vs. -message ambiguity.
  	$pa->{-message} = $pa->{-msg};
  	delete($pa->{-msg});
      }
      elsif ( $pa =~ /^-?\d+$/ ) {
  	$pa = { -exitval => $pa };
      }
      else {
  	$pa = { -message => $pa };
      }
  
      # These are _our_ defaults.
      $pa->{-verbose} = 0 unless exists($pa->{-verbose});
      $pa->{-exitval} = 0 unless exists($pa->{-exitval});
      $pa;
  }
  
  # Sneak way to know what version the user requested.
  sub VERSION {
      $requested_version = $_[1];
      shift->SUPER::VERSION(@_);
  }
  
  package Getopt::Long::CallBack;
  
  sub new {
      my ($pkg, %atts) = @_;
      bless { %atts }, $pkg;
  }
  
  sub name {
      my $self = shift;
      ''.$self->{name};
  }
  
  use overload
    # Treat this object as an ordinary string for legacy API.
    '""'	   => \&name,
    fallback => 1;
  
  1;
  
  ################ Documentation ################
  
  =head1 NAME
  
  Getopt::Long - Extended processing of command line options
  
  =head1 SYNOPSIS
  
    use Getopt::Long;
    my $data   = "file.dat";
    my $length = 24;
    my $verbose;
    $result = GetOptions ("length=i" => \$length,    # numeric
                          "file=s"   => \$data,      # string
  			"verbose"  => \$verbose);  # flag
  
  =head1 DESCRIPTION
  
  The Getopt::Long module implements an extended getopt function called
  GetOptions(). This function adheres to the POSIX syntax for command
  line options, with GNU extensions. In general, this means that options
  have long names instead of single letters, and are introduced with a
  double dash "--". Support for bundling of command line options, as was
  the case with the more traditional single-letter approach, is provided
  but not enabled by default.
  
  =head1 Command Line Options, an Introduction
  
  Command line operated programs traditionally take their arguments from
  the command line, for example filenames or other information that the
  program needs to know. Besides arguments, these programs often take
  command line I<options> as well. Options are not necessary for the
  program to work, hence the name 'option', but are used to modify its
  default behaviour. For example, a program could do its job quietly,
  but with a suitable option it could provide verbose information about
  what it did.
  
  Command line options come in several flavours. Historically, they are
  preceded by a single dash C<->, and consist of a single letter.
  
      -l -a -c
  
  Usually, these single-character options can be bundled:
  
      -lac
  
  Options can have values, the value is placed after the option
  character. Sometimes with whitespace in between, sometimes not:
  
      -s 24 -s24
  
  Due to the very cryptic nature of these options, another style was
  developed that used long names. So instead of a cryptic C<-l> one
  could use the more descriptive C<--long>. To distinguish between a
  bundle of single-character options and a long one, two dashes are used
  to precede the option name. Early implementations of long options used
  a plus C<+> instead. Also, option values could be specified either
  like
  
      --size=24
  
  or
  
      --size 24
  
  The C<+> form is now obsolete and strongly deprecated.
  
  =head1 Getting Started with Getopt::Long
  
  Getopt::Long is the Perl5 successor of C<newgetopt.pl>. This was the
  first Perl module that provided support for handling the new style of
  command line options, hence the name Getopt::Long. This module also
  supports single-character options and bundling. Single character
  options may be any alphabetic character, a question mark, and a dash.
  Long options may consist of a series of letters, digits, and dashes.
  Although this is currently not enforced by Getopt::Long, multiple
  consecutive dashes are not allowed, and the option name must not end
  with a dash.
  
  To use Getopt::Long from a Perl program, you must include the
  following line in your Perl program:
  
      use Getopt::Long;
  
  This will load the core of the Getopt::Long module and prepare your
  program for using it. Most of the actual Getopt::Long code is not
  loaded until you really call one of its functions.
  
  In the default configuration, options names may be abbreviated to
  uniqueness, case does not matter, and a single dash is sufficient,
  even for long option names. Also, options may be placed between
  non-option arguments. See L<Configuring Getopt::Long> for more
  details on how to configure Getopt::Long.
  
  =head2 Simple options
  
  The most simple options are the ones that take no values. Their mere
  presence on the command line enables the option. Popular examples are:
  
      --all --verbose --quiet --debug
  
  Handling simple options is straightforward:
  
      my $verbose = '';	# option variable with default value (false)
      my $all = '';	# option variable with default value (false)
      GetOptions ('verbose' => \$verbose, 'all' => \$all);
  
  The call to GetOptions() parses the command line arguments that are
  present in C<@ARGV> and sets the option variable to the value C<1> if
  the option did occur on the command line. Otherwise, the option
  variable is not touched. Setting the option value to true is often
  called I<enabling> the option.
  
  The option name as specified to the GetOptions() function is called
  the option I<specification>. Later we'll see that this specification
  can contain more than just the option name. The reference to the
  variable is called the option I<destination>.
  
  GetOptions() will return a true value if the command line could be
  processed successfully. Otherwise, it will write error messages to
  STDERR, and return a false result.
  
  =head2 A little bit less simple options
  
  Getopt::Long supports two useful variants of simple options:
  I<negatable> options and I<incremental> options.
  
  A negatable option is specified with an exclamation mark C<!> after the
  option name:
  
      my $verbose = '';	# option variable with default value (false)
      GetOptions ('verbose!' => \$verbose);
  
  Now, using C<--verbose> on the command line will enable C<$verbose>,
  as expected. But it is also allowed to use C<--noverbose>, which will
  disable C<$verbose> by setting its value to C<0>. Using a suitable
  default value, the program can find out whether C<$verbose> is false
  by default, or disabled by using C<--noverbose>.
  
  An incremental option is specified with a plus C<+> after the
  option name:
  
      my $verbose = '';	# option variable with default value (false)
      GetOptions ('verbose+' => \$verbose);
  
  Using C<--verbose> on the command line will increment the value of
  C<$verbose>. This way the program can keep track of how many times the
  option occurred on the command line. For example, each occurrence of
  C<--verbose> could increase the verbosity level of the program.
  
  =head2 Mixing command line option with other arguments
  
  Usually programs take command line options as well as other arguments,
  for example, file names. It is good practice to always specify the
  options first, and the other arguments last. Getopt::Long will,
  however, allow the options and arguments to be mixed and 'filter out'
  all the options before passing the rest of the arguments to the
  program. To stop Getopt::Long from processing further arguments,
  insert a double dash C<--> on the command line:
  
      --size 24 -- --all
  
  In this example, C<--all> will I<not> be treated as an option, but
  passed to the program unharmed, in C<@ARGV>.
  
  =head2 Options with values
  
  For options that take values it must be specified whether the option
  value is required or not, and what kind of value the option expects.
  
  Three kinds of values are supported: integer numbers, floating point
  numbers, and strings.
  
  If the option value is required, Getopt::Long will take the
  command line argument that follows the option and assign this to the
  option variable. If, however, the option value is specified as
  optional, this will only be done if that value does not look like a
  valid command line option itself.
  
      my $tag = '';	# option variable with default value
      GetOptions ('tag=s' => \$tag);
  
  In the option specification, the option name is followed by an equals
  sign C<=> and the letter C<s>. The equals sign indicates that this
  option requires a value. The letter C<s> indicates that this value is
  an arbitrary string. Other possible value types are C<i> for integer
  values, and C<f> for floating point values. Using a colon C<:> instead
  of the equals sign indicates that the option value is optional. In
  this case, if no suitable value is supplied, string valued options get
  an empty string C<''> assigned, while numeric options are set to C<0>.
  
  =head2 Options with multiple values
  
  Options sometimes take several values. For example, a program could
  use multiple directories to search for library files:
  
      --library lib/stdlib --library lib/extlib
  
  To accomplish this behaviour, simply specify an array reference as the
  destination for the option:
  
      GetOptions ("library=s" => \@libfiles);
  
  Alternatively, you can specify that the option can have multiple
  values by adding a "@", and pass a scalar reference as the
  destination:
  
      GetOptions ("library=s@" => \$libfiles);
  
  Used with the example above, C<@libfiles> (or C<@$libfiles>) would
  contain two strings upon completion: C<"lib/srdlib"> and
  C<"lib/extlib">, in that order. It is also possible to specify that
  only integer or floating point numbers are acceptable values.
  
  Often it is useful to allow comma-separated lists of values as well as
  multiple occurrences of the options. This is easy using Perl's split()
  and join() operators:
  
      GetOptions ("library=s" => \@libfiles);
      @libfiles = split(/,/,join(',',@libfiles));
  
  Of course, it is important to choose the right separator string for
  each purpose.
  
  Warning: What follows is an experimental feature.
  
  Options can take multiple values at once, for example
  
      --coordinates 52.2 16.4 --rgbcolor 255 255 149
  
  This can be accomplished by adding a repeat specifier to the option
  specification. Repeat specifiers are very similar to the C<{...}>
  repeat specifiers that can be used with regular expression patterns.
  For example, the above command line would be handled as follows:
  
      GetOptions('coordinates=f{2}' => \@coor, 'rgbcolor=i{3}' => \@color);
  
  The destination for the option must be an array or array reference.
  
  It is also possible to specify the minimal and maximal number of
  arguments an option takes. C<foo=s{2,4}> indicates an option that
  takes at least two and at most 4 arguments. C<foo=s{,}> indicates one
  or more values; C<foo:s{,}> indicates zero or more option values.
  
  =head2 Options with hash values
  
  If the option destination is a reference to a hash, the option will
  take, as value, strings of the form I<key>C<=>I<value>. The value will
  be stored with the specified key in the hash.
  
      GetOptions ("define=s" => \%defines);
  
  Alternatively you can use:
  
      GetOptions ("define=s%" => \$defines);
  
  When used with command line options:
  
      --define os=linux --define vendor=redhat
  
  the hash C<%defines> (or C<%$defines>) will contain two keys, C<"os">
  with value C<"linux"> and C<"vendor"> with value C<"redhat">. It is
  also possible to specify that only integer or floating point numbers
  are acceptable values. The keys are always taken to be strings.
  
  =head2 User-defined subroutines to handle options
  
  Ultimate control over what should be done when (actually: each time)
  an option is encountered on the command line can be achieved by
  designating a reference to a subroutine (or an anonymous subroutine)
  as the option destination. When GetOptions() encounters the option, it
  will call the subroutine with two or three arguments. The first
  argument is the name of the option. (Actually, it is an object that
  stringifies to the name of the option.) For a scalar or array destination,
  the second argument is the value to be stored. For a hash destination,
  the second arguments is the key to the hash, and the third argument
  the value to be stored. It is up to the subroutine to store the value,
  or do whatever it thinks is appropriate.
  
  A trivial application of this mechanism is to implement options that
  are related to each other. For example:
  
      my $verbose = '';	# option variable with default value (false)
      GetOptions ('verbose' => \$verbose,
  	        'quiet'   => sub { $verbose = 0 });
  
  Here C<--verbose> and C<--quiet> control the same variable
  C<$verbose>, but with opposite values.
  
  If the subroutine needs to signal an error, it should call die() with
  the desired error message as its argument. GetOptions() will catch the
  die(), issue the error message, and record that an error result must
  be returned upon completion.
  
  If the text of the error message starts with an exclamation mark C<!>
  it is interpreted specially by GetOptions(). There is currently one
  special command implemented: C<die("!FINISH")> will cause GetOptions()
  to stop processing options, as if it encountered a double dash C<-->.
  
  In version 2.37 the first argument to the callback function was
  changed from string to object. This was done to make room for
  extensions and more detailed control. The object stringifies to the
  option name so this change should not introduce compatibility
  problems.
  
  =head2 Options with multiple names
  
  Often it is user friendly to supply alternate mnemonic names for
  options. For example C<--height> could be an alternate name for
  C<--length>. Alternate names can be included in the option
  specification, separated by vertical bar C<|> characters. To implement
  the above example:
  
      GetOptions ('length|height=f' => \$length);
  
  The first name is called the I<primary> name, the other names are
  called I<aliases>. When using a hash to store options, the key will
  always be the primary name.
  
  Multiple alternate names are possible.
  
  =head2 Case and abbreviations
  
  Without additional configuration, GetOptions() will ignore the case of
  option names, and allow the options to be abbreviated to uniqueness.
  
      GetOptions ('length|height=f' => \$length, "head" => \$head);
  
  This call will allow C<--l> and C<--L> for the length option, but
  requires a least C<--hea> and C<--hei> for the head and height options.
  
  =head2 Summary of Option Specifications
  
  Each option specifier consists of two parts: the name specification
  and the argument specification.
  
  The name specification contains the name of the option, optionally
  followed by a list of alternative names separated by vertical bar
  characters.
  
      length	      option name is "length"
      length|size|l     name is "length", aliases are "size" and "l"
  
  The argument specification is optional. If omitted, the option is
  considered boolean, a value of 1 will be assigned when the option is
  used on the command line.
  
  The argument specification can be
  
  =over 4
  
  =item !
  
  The option does not take an argument and may be negated by prefixing
  it with "no" or "no-". E.g. C<"foo!"> will allow C<--foo> (a value of
  1 will be assigned) as well as C<--nofoo> and C<--no-foo> (a value of
  0 will be assigned). If the option has aliases, this applies to the
  aliases as well.
  
  Using negation on a single letter option when bundling is in effect is
  pointless and will result in a warning.
  
  =item +
  
  The option does not take an argument and will be incremented by 1
  every time it appears on the command line. E.g. C<"more+">, when used
  with C<--more --more --more>, will increment the value three times,
  resulting in a value of 3 (provided it was 0 or undefined at first).
  
  The C<+> specifier is ignored if the option destination is not a scalar.
  
  =item = I<type> [ I<desttype> ] [ I<repeat> ]
  
  The option requires an argument of the given type. Supported types
  are:
  
  =over 4
  
  =item s
  
  String. An arbitrary sequence of characters. It is valid for the
  argument to start with C<-> or C<-->.
  
  =item i
  
  Integer. An optional leading plus or minus sign, followed by a
  sequence of digits.
  
  =item o
  
  Extended integer, Perl style. This can be either an optional leading
  plus or minus sign, followed by a sequence of digits, or an octal
  string (a zero, optionally followed by '0', '1', .. '7'), or a
  hexadecimal string (C<0x> followed by '0' .. '9', 'a' .. 'f', case
  insensitive), or a binary string (C<0b> followed by a series of '0'
  and '1').
  
  =item f
  
  Real number. For example C<3.14>, C<-6.23E24> and so on.
  
  =back
  
  The I<desttype> can be C<@> or C<%> to specify that the option is
  list or a hash valued. This is only needed when the destination for
  the option value is not otherwise specified. It should be omitted when
  not needed.
  
  The I<repeat> specifies the number of values this option takes per
  occurrence on the command line. It has the format C<{> [ I<min> ] [ C<,> [ I<max> ] ] C<}>.
  
  I<min> denotes the minimal number of arguments. It defaults to 1 for
  options with C<=> and to 0 for options with C<:>, see below. Note that
  I<min> overrules the C<=> / C<:> semantics.
  
  I<max> denotes the maximum number of arguments. It must be at least
  I<min>. If I<max> is omitted, I<but the comma is not>, there is no
  upper bound to the number of argument values taken.
  
  =item : I<type> [ I<desttype> ]
  
  Like C<=>, but designates the argument as optional.
  If omitted, an empty string will be assigned to string values options,
  and the value zero to numeric options.
  
  Note that if a string argument starts with C<-> or C<-->, it will be
  considered an option on itself.
  
  =item : I<number> [ I<desttype> ]
  
  Like C<:i>, but if the value is omitted, the I<number> will be assigned.
  
  =item : + [ I<desttype> ]
  
  Like C<:i>, but if the value is omitted, the current value for the
  option will be incremented.
  
  =back
  
  =head1 Advanced Possibilities
  
  =head2 Object oriented interface
  
  Getopt::Long can be used in an object oriented way as well:
  
      use Getopt::Long;
      $p = new Getopt::Long::Parser;
      $p->configure(...configuration options...);
      if ($p->getoptions(...options descriptions...)) ...
  
  Configuration options can be passed to the constructor:
  
      $p = new Getopt::Long::Parser
               config => [...configuration options...];
  
  =head2 Thread Safety
  
  Getopt::Long is thread safe when using ithreads as of Perl 5.8.  It is
  I<not> thread safe when using the older (experimental and now
  obsolete) threads implementation that was added to Perl 5.005.
  
  =head2 Documentation and help texts
  
  Getopt::Long encourages the use of Pod::Usage to produce help
  messages. For example:
  
      use Getopt::Long;
      use Pod::Usage;
  
      my $man = 0;
      my $help = 0;
  
      GetOptions('help|?' => \$help, man => \$man) or pod2usage(2);
      pod2usage(1) if $help;
      pod2usage(-exitstatus => 0, -verbose => 2) if $man;
  
      __END__
  
      =head1 NAME
  
      sample - Using Getopt::Long and Pod::Usage
  
      =head1 SYNOPSIS
  
      sample [options] [file ...]
  
       Options:
         -help            brief help message
         -man             full documentation
  
      =head1 OPTIONS
  
      =over 8
  
      =item B<-help>
  
      Print a brief help message and exits.
  
      =item B<-man>
  
      Prints the manual page and exits.
  
      =back
  
      =head1 DESCRIPTION
  
      B<This program> will read the given input file(s) and do something
      useful with the contents thereof.
  
      =cut
  
  See L<Pod::Usage> for details.
  
  =head2 Parsing options from an arbitrary array
  
  By default, GetOptions parses the options that are present in the
  global array C<@ARGV>. A special entry C<GetOptionsFromArray> can be
  used to parse options from an arbitrary array.
  
      use Getopt::Long qw(GetOptionsFromArray);
      $ret = GetOptionsFromArray(\@myopts, ...);
  
  When used like this, the global C<@ARGV> is not touched at all.
  
  The following two calls behave identically:
  
      $ret = GetOptions( ... );
      $ret = GetOptionsFromArray(\@ARGV, ... );
  
  =head2 Parsing options from an arbitrary string
  
  A special entry C<GetOptionsFromString> can be used to parse options
  from an arbitrary string.
  
      use Getopt::Long qw(GetOptionsFromString);
      $ret = GetOptionsFromString($string, ...);
  
  The contents of the string are split into arguments using a call to
  C<Text::ParseWords::shellwords>. As with C<GetOptionsFromArray>, the
  global C<@ARGV> is not touched.
  
  It is possible that, upon completion, not all arguments in the string
  have been processed. C<GetOptionsFromString> will, when called in list
  context, return both the return status and an array reference to any
  remaining arguments:
  
      ($ret, $args) = GetOptionsFromString($string, ... );
  
  If any arguments remain, and C<GetOptionsFromString> was not called in
  list context, a message will be given and C<GetOptionsFromString> will
  return failure.
  
  =head2 Storing options values in a hash
  
  Sometimes, for example when there are a lot of options, having a
  separate variable for each of them can be cumbersome. GetOptions()
  supports, as an alternative mechanism, storing options values in a
  hash.
  
  To obtain this, a reference to a hash must be passed I<as the first
  argument> to GetOptions(). For each option that is specified on the
  command line, the option value will be stored in the hash with the
  option name as key. Options that are not actually used on the command
  line will not be put in the hash, on other words,
  C<exists($h{option})> (or defined()) can be used to test if an option
  was used. The drawback is that warnings will be issued if the program
  runs under C<use strict> and uses C<$h{option}> without testing with
  exists() or defined() first.
  
      my %h = ();
      GetOptions (\%h, 'length=i');	# will store in $h{length}
  
  For options that take list or hash values, it is necessary to indicate
  this by appending an C<@> or C<%> sign after the type:
  
      GetOptions (\%h, 'colours=s@');	# will push to @{$h{colours}}
  
  To make things more complicated, the hash may contain references to
  the actual destinations, for example:
  
      my $len = 0;
      my %h = ('length' => \$len);
      GetOptions (\%h, 'length=i');	# will store in $len
  
  This example is fully equivalent with:
  
      my $len = 0;
      GetOptions ('length=i' => \$len);	# will store in $len
  
  Any mixture is possible. For example, the most frequently used options
  could be stored in variables while all other options get stored in the
  hash:
  
      my $verbose = 0;			# frequently referred
      my $debug = 0;			# frequently referred
      my %h = ('verbose' => \$verbose, 'debug' => \$debug);
      GetOptions (\%h, 'verbose', 'debug', 'filter', 'size=i');
      if ( $verbose ) { ... }
      if ( exists $h{filter} ) { ... option 'filter' was specified ... }
  
  =head2 Bundling
  
  With bundling it is possible to set several single-character options
  at once. For example if C<a>, C<v> and C<x> are all valid options,
  
      -vax
  
  would set all three.
  
  Getopt::Long supports two levels of bundling. To enable bundling, a
  call to Getopt::Long::Configure is required.
  
  The first level of bundling can be enabled with:
  
      Getopt::Long::Configure ("bundling");
  
  Configured this way, single-character options can be bundled but long
  options B<must> always start with a double dash C<--> to avoid
  ambiguity. For example, when C<vax>, C<a>, C<v> and C<x> are all valid
  options,
  
      -vax
  
  would set C<a>, C<v> and C<x>, but
  
      --vax
  
  would set C<vax>.
  
  The second level of bundling lifts this restriction. It can be enabled
  with:
  
      Getopt::Long::Configure ("bundling_override");
  
  Now, C<-vax> would set the option C<vax>.
  
  When any level of bundling is enabled, option values may be inserted
  in the bundle. For example:
  
      -h24w80
  
  is equivalent to
  
      -h 24 -w 80
  
  When configured for bundling, single-character options are matched
  case sensitive while long options are matched case insensitive. To
  have the single-character options matched case insensitive as well,
  use:
  
      Getopt::Long::Configure ("bundling", "ignorecase_always");
  
  It goes without saying that bundling can be quite confusing.
  
  =head2 The lonesome dash
  
  Normally, a lone dash C<-> on the command line will not be considered
  an option. Option processing will terminate (unless "permute" is
  configured) and the dash will be left in C<@ARGV>.
  
  It is possible to get special treatment for a lone dash. This can be
  achieved by adding an option specification with an empty name, for
  example:
  
      GetOptions ('' => \$stdio);
  
  A lone dash on the command line will now be a legal option, and using
  it will set variable C<$stdio>.
  
  =head2 Argument callback
  
  A special option 'name' C<< <> >> can be used to designate a subroutine
  to handle non-option arguments. When GetOptions() encounters an
  argument that does not look like an option, it will immediately call this
  subroutine and passes it one parameter: the argument name. Well, actually
  it is an object that stringifies to the argument name.
  
  For example:
  
      my $width = 80;
      sub process { ... }
      GetOptions ('width=i' => \$width, '<>' => \&process);
  
  When applied to the following command line:
  
      arg1 --width=72 arg2 --width=60 arg3
  
  This will call
  C<process("arg1")> while C<$width> is C<80>,
  C<process("arg2")> while C<$width> is C<72>, and
  C<process("arg3")> while C<$width> is C<60>.
  
  This feature requires configuration option B<permute>, see section
  L<Configuring Getopt::Long>.
  
  =head1 Configuring Getopt::Long
  
  Getopt::Long can be configured by calling subroutine
  Getopt::Long::Configure(). This subroutine takes a list of quoted
  strings, each specifying a configuration option to be enabled, e.g.
  C<ignore_case>, or disabled, e.g. C<no_ignore_case>. Case does not
  matter. Multiple calls to Configure() are possible.
  
  Alternatively, as of version 2.24, the configuration options may be
  passed together with the C<use> statement:
  
      use Getopt::Long qw(:config no_ignore_case bundling);
  
  The following options are available:
  
  =over 12
  
  =item default
  
  This option causes all configuration options to be reset to their
  default values.
  
  =item posix_default
  
  This option causes all configuration options to be reset to their
  default values as if the environment variable POSIXLY_CORRECT had
  been set.
  
  =item auto_abbrev
  
  Allow option names to be abbreviated to uniqueness.
  Default is enabled unless environment variable
  POSIXLY_CORRECT has been set, in which case C<auto_abbrev> is disabled.
  
  =item getopt_compat
  
  Allow C<+> to start options.
  Default is enabled unless environment variable
  POSIXLY_CORRECT has been set, in which case C<getopt_compat> is disabled.
  
  =item gnu_compat
  
  C<gnu_compat> controls whether C<--opt=> is allowed, and what it should
  do. Without C<gnu_compat>, C<--opt=> gives an error. With C<gnu_compat>,
  C<--opt=> will give option C<opt> and empty value.
  This is the way GNU getopt_long() does it.
  
  =item gnu_getopt
  
  This is a short way of setting C<gnu_compat> C<bundling> C<permute>
  C<no_getopt_compat>. With C<gnu_getopt>, command line handling should be
  fully compatible with GNU getopt_long().
  
  =item require_order
  
  Whether command line arguments are allowed to be mixed with options.
  Default is disabled unless environment variable
  POSIXLY_CORRECT has been set, in which case C<require_order> is enabled.
  
  See also C<permute>, which is the opposite of C<require_order>.
  
  =item permute
  
  Whether command line arguments are allowed to be mixed with options.
  Default is enabled unless environment variable
  POSIXLY_CORRECT has been set, in which case C<permute> is disabled.
  Note that C<permute> is the opposite of C<require_order>.
  
  If C<permute> is enabled, this means that
  
      --foo arg1 --bar arg2 arg3
  
  is equivalent to
  
      --foo --bar arg1 arg2 arg3
  
  If an argument callback routine is specified, C<@ARGV> will always be
  empty upon successful return of GetOptions() since all options have been
  processed. The only exception is when C<--> is used:
  
      --foo arg1 --bar arg2 -- arg3
  
  This will call the callback routine for arg1 and arg2, and then
  terminate GetOptions() leaving C<"arg3"> in C<@ARGV>.
  
  If C<require_order> is enabled, options processing
  terminates when the first non-option is encountered.
  
      --foo arg1 --bar arg2 arg3
  
  is equivalent to
  
      --foo -- arg1 --bar arg2 arg3
  
  If C<pass_through> is also enabled, options processing will terminate
  at the first unrecognized option, or non-option, whichever comes
  first.
  
  =item bundling (default: disabled)
  
  Enabling this option will allow single-character options to be
  bundled. To distinguish bundles from long option names, long options
  I<must> be introduced with C<--> and bundles with C<->.
  
  Note that, if you have options C<a>, C<l> and C<all>, and
  auto_abbrev enabled, possible arguments and option settings are:
  
      using argument               sets option(s)
      ------------------------------------------
      -a, --a                      a
      -l, --l                      l
      -al, -la, -ala, -all,...     a, l
      --al, --all                  all
  
  The surprising part is that C<--a> sets option C<a> (due to auto
  completion), not C<all>.
  
  Note: disabling C<bundling> also disables C<bundling_override>.
  
  =item bundling_override (default: disabled)
  
  If C<bundling_override> is enabled, bundling is enabled as with
  C<bundling> but now long option names override option bundles.
  
  Note: disabling C<bundling_override> also disables C<bundling>.
  
  B<Note:> Using option bundling can easily lead to unexpected results,
  especially when mixing long options and bundles. Caveat emptor.
  
  =item ignore_case  (default: enabled)
  
  If enabled, case is ignored when matching long option names. If,
  however, bundling is enabled as well, single character options will be
  treated case-sensitive.
  
  With C<ignore_case>, option specifications for options that only
  differ in case, e.g., C<"foo"> and C<"Foo">, will be flagged as
  duplicates.
  
  Note: disabling C<ignore_case> also disables C<ignore_case_always>.
  
  =item ignore_case_always (default: disabled)
  
  When bundling is in effect, case is ignored on single-character
  options also.
  
  Note: disabling C<ignore_case_always> also disables C<ignore_case>.
  
  =item auto_version (default:disabled)
  
  Automatically provide support for the B<--version> option if
  the application did not specify a handler for this option itself.
  
  Getopt::Long will provide a standard version message that includes the
  program name, its version (if $main::VERSION is defined), and the
  versions of Getopt::Long and Perl. The message will be written to
  standard output and processing will terminate.
  
  C<auto_version> will be enabled if the calling program explicitly
  specified a version number higher than 2.32 in the C<use> or
  C<require> statement.
  
  =item auto_help (default:disabled)
  
  Automatically provide support for the B<--help> and B<-?> options if
  the application did not specify a handler for this option itself.
  
  Getopt::Long will provide a help message using module L<Pod::Usage>. The
  message, derived from the SYNOPSIS POD section, will be written to
  standard output and processing will terminate.
  
  C<auto_help> will be enabled if the calling program explicitly
  specified a version number higher than 2.32 in the C<use> or
  C<require> statement.
  
  =item pass_through (default: disabled)
  
  Options that are unknown, ambiguous or supplied with an invalid option
  value are passed through in C<@ARGV> instead of being flagged as
  errors. This makes it possible to write wrapper scripts that process
  only part of the user supplied command line arguments, and pass the
  remaining options to some other program.
  
  If C<require_order> is enabled, options processing will terminate at
  the first unrecognized option, or non-option, whichever comes first.
  However, if C<permute> is enabled instead, results can become confusing.
  
  Note that the options terminator (default C<-->), if present, will
  also be passed through in C<@ARGV>.
  
  =item prefix
  
  The string that starts options. If a constant string is not
  sufficient, see C<prefix_pattern>.
  
  =item prefix_pattern
  
  A Perl pattern that identifies the strings that introduce options.
  Default is C<--|-|\+> unless environment variable
  POSIXLY_CORRECT has been set, in which case it is C<--|->.
  
  =item long_prefix_pattern
  
  A Perl pattern that allows the disambiguation of long and short
  prefixes. Default is C<-->.
  
  Typically you only need to set this if you are using nonstandard
  prefixes and want some or all of them to have the same semantics as
  '--' does under normal circumstances.
  
  For example, setting prefix_pattern to C<--|-|\+|\/> and
  long_prefix_pattern to C<--|\/> would add Win32 style argument
  handling.
  
  =item debug (default: disabled)
  
  Enable debugging output.
  
  =back
  
  =head1 Exportable Methods
  
  =over
  
  =item VersionMessage
  
  This subroutine provides a standard version message. Its argument can be:
  
  =over 4
  
  =item *
  
  A string containing the text of a message to print I<before> printing
  the standard message.
  
  =item *
  
  A numeric value corresponding to the desired exit status.
  
  =item *
  
  A reference to a hash.
  
  =back
  
  If more than one argument is given then the entire argument list is
  assumed to be a hash.  If a hash is supplied (either as a reference or
  as a list) it should contain one or more elements with the following
  keys:
  
  =over 4
  
  =item C<-message>
  
  =item C<-msg>
  
  The text of a message to print immediately prior to printing the
  program's usage message.
  
  =item C<-exitval>
  
  The desired exit status to pass to the B<exit()> function.
  This should be an integer, or else the string "NOEXIT" to
  indicate that control should simply be returned without
  terminating the invoking process.
  
  =item C<-output>
  
  A reference to a filehandle, or the pathname of a file to which the
  usage message should be written. The default is C<\*STDERR> unless the
  exit value is less than 2 (in which case the default is C<\*STDOUT>).
  
  =back
  
  You cannot tie this routine directly to an option, e.g.:
  
      GetOptions("version" => \&VersionMessage);
  
  Use this instead:
  
      GetOptions("version" => sub { VersionMessage() });
  
  =item HelpMessage
  
  This subroutine produces a standard help message, derived from the
  program's POD section SYNOPSIS using L<Pod::Usage>. It takes the same
  arguments as VersionMessage(). In particular, you cannot tie it
  directly to an option, e.g.:
  
      GetOptions("help" => \&HelpMessage);
  
  Use this instead:
  
      GetOptions("help" => sub { HelpMessage() });
  
  =back
  
  =head1 Return values and Errors
  
  Configuration errors and errors in the option definitions are
  signalled using die() and will terminate the calling program unless
  the call to Getopt::Long::GetOptions() was embedded in C<eval { ...
  }>, or die() was trapped using C<$SIG{__DIE__}>.
  
  GetOptions returns true to indicate success.
  It returns false when the function detected one or more errors during
  option parsing. These errors are signalled using warn() and can be
  trapped with C<$SIG{__WARN__}>.
  
  =head1 Legacy
  
  The earliest development of C<newgetopt.pl> started in 1990, with Perl
  version 4. As a result, its development, and the development of
  Getopt::Long, has gone through several stages. Since backward
  compatibility has always been extremely important, the current version
  of Getopt::Long still supports a lot of constructs that nowadays are
  no longer necessary or otherwise unwanted. This section describes
  briefly some of these 'features'.
  
  =head2 Default destinations
  
  When no destination is specified for an option, GetOptions will store
  the resultant value in a global variable named C<opt_>I<XXX>, where
  I<XXX> is the primary name of this option. When a progam executes
  under C<use strict> (recommended), these variables must be
  pre-declared with our() or C<use vars>.
  
      our $opt_length = 0;
      GetOptions ('length=i');	# will store in $opt_length
  
  To yield a usable Perl variable, characters that are not part of the
  syntax for variables are translated to underscores. For example,
  C<--fpp-struct-return> will set the variable
  C<$opt_fpp_struct_return>. Note that this variable resides in the
  namespace of the calling program, not necessarily C<main>. For
  example:
  
      GetOptions ("size=i", "sizes=i@");
  
  with command line "-size 10 -sizes 24 -sizes 48" will perform the
  equivalent of the assignments
  
      $opt_size = 10;
      @opt_sizes = (24, 48);
  
  =head2 Alternative option starters
  
  A string of alternative option starter characters may be passed as the
  first argument (or the first argument after a leading hash reference
  argument).
  
      my $len = 0;
      GetOptions ('/', 'length=i' => $len);
  
  Now the command line may look like:
  
      /length 24 -- arg
  
  Note that to terminate options processing still requires a double dash
  C<-->.
  
  GetOptions() will not interpret a leading C<< "<>" >> as option starters
  if the next argument is a reference. To force C<< "<" >> and C<< ">" >> as
  option starters, use C<< "><" >>. Confusing? Well, B<using a starter
  argument is strongly deprecated> anyway.
  
  =head2 Configuration variables
  
  Previous versions of Getopt::Long used variables for the purpose of
  configuring. Although manipulating these variables still work, it is
  strongly encouraged to use the C<Configure> routine that was introduced
  in version 2.17. Besides, it is much easier.
  
  =head1 Tips and Techniques
  
  =head2 Pushing multiple values in a hash option
  
  Sometimes you want to combine the best of hashes and arrays. For
  example, the command line:
  
    --list add=first --list add=second --list add=third
  
  where each successive 'list add' option will push the value of add
  into array ref $list->{'add'}. The result would be like
  
    $list->{add} = [qw(first second third)];
  
  This can be accomplished with a destination routine:
  
    GetOptions('list=s%' =>
                 sub { push(@{$list{$_[1]}}, $_[2]) });
  
  =head1 Troubleshooting
  
  =head2 GetOptions does not return a false result when an option is not supplied
  
  That's why they're called 'options'.
  
  =head2 GetOptions does not split the command line correctly
  
  The command line is not split by GetOptions, but by the command line
  interpreter (CLI). On Unix, this is the shell. On Windows, it is
  COMMAND.COM or CMD.EXE. Other operating systems have other CLIs.
  
  It is important to know that these CLIs may behave different when the
  command line contains special characters, in particular quotes or
  backslashes. For example, with Unix shells you can use single quotes
  (C<'>) and double quotes (C<">) to group words together. The following
  alternatives are equivalent on Unix:
  
      "two words"
      'two words'
      two\ words
  
  In case of doubt, insert the following statement in front of your Perl
  program:
  
      print STDERR (join("|",@ARGV),"\n");
  
  to verify how your CLI passes the arguments to the program.
  
  =head2 Undefined subroutine &main::GetOptions called
  
  Are you running Windows, and did you write
  
      use GetOpt::Long;
  
  (note the capital 'O')?
  
  =head2 How do I put a "-?" option into a Getopt::Long?
  
  You can only obtain this using an alias, and Getopt::Long of at least
  version 2.13.
  
      use Getopt::Long;
      GetOptions ("help|?");    # -help and -? will both set $opt_help
  
  =head1 AUTHOR
  
  Johan Vromans <jvromans@squirrel.nl>
  
  =head1 COPYRIGHT AND DISCLAIMER
  
  This program is Copyright 1990,2009 by Johan Vromans.
  This program is free software; you can redistribute it and/or
  modify it under the terms of the Perl Artistic License or the
  GNU General Public License as published by the Free Software
  Foundation; either version 2 of the License, or (at your option) any
  later version.
  
  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.
  
  If you do not have a copy of the GNU General Public License write to
  the Free Software Foundation, Inc., 675 Mass Ave, Cambridge,
  MA 02139, USA.
  
  =cut
  
GETOPT_LONG

$fatpacked{"Net/Address/IP/Local.pm"} = <<'NET_ADDRESS_IP_LOCAL';
  #
  # Net::Address::IP::Local class,
  # a class for discovering the local system's IP address.
  #
  # (C) 2005-2009 Julian Mehnle <julian@mehnle.net>
  # $Id: Local.pm 24 2009-01-14 21:23:40Z julian $
  #
  ###############################################################################
  
  =head1 NAME
  
  Net::Address::IP::Local - A class for discovering the local system's IP address
  
  =cut
  
  package Net::Address::IP::Local;
  
  =head1 VERSION
  
  0.1.2
  
  =cut
  
  # use version; our $VERSION = qv('0.1.2');
  
  use warnings;
  use strict;
  
  use Error ':try';
  
  use constant TRUE   => (0 == 0);
  use constant FALSE  => not TRUE;
  
  use constant remote_address_ipv4_default => '198.41.0.4';           # a.root-servers.net
  use constant remote_address_ipv6_default => '2001:503:ba3e::2:30';  # a.root-servers.net
  
  use constant remote_port_default         => 53;                     # DNS
  
  =head1 SYNOPSIS
  
      use Net::Address::IP::Local;
      
      # Get the local system's IP address that is "en route" to "the internet":
      my $address      = Net::Address::IP::Local->public;
      my $address_ipv4 = Net::Address::IP::Local->public_ipv4;
      my $address_ipv6 = Net::Address::IP::Local->public_ipv6;
      
      # Get the local system's IP address that is "en route" to the given remote
      # IP address:
      my $address = Net::Address::IP::Local->connected_to($remote_address);
  
  =head1 DESCRIPTION
  
  B<Net::Address::IP::Local> discovers the local system's IP address that would
  be used as the source address when contacting "the internet" or a certain
  specified remote IP address.
  
  =cut
  
  # Implementation:
  ###############################################################################
  
  =head2 Class methods
  
  This class just provides the following class methods:
  
  =over
  
  =item B<public>: returns I<string>; throws I<Net::Address::IP::Local::Error>
  
  Returns the textual representation of the local system's IP address that is
  "en route" to "the internet".  If the system supports IPv6 and has an IPv6
  address that is "en route" to "the internet", that is returned.  Otherwise, the
  IPv4 address that is "en route" to "the internet" is returned.  If there is no
  route at all to the internet, a I<Net::Address::IP::Local::Error> exception is
  thrown.
  
  =cut
  
  sub public {
      my ($class) = @_;
      
      return $class->connected_to($class->remote_address_ipv4_default)
          if not $class->ipv6_support;
          # Short-cut for the common case with no IPv6 support.
      
      my $ip_address;
      
      try {
          $ip_address = $class->connected_to($class->remote_address_ipv6_default);
      }
      catch Net::Address::IP::Local::Error with {
          my $error = shift;
          try {
              $ip_address = $class->connected_to($class->remote_address_ipv4_default);
          }
          catch Net::Address::IP::Local::Error with {
              # If neither the IPv4 nor IPv6 local address could be determined,
              # re-throw the first error that occurred:
              $error->throw;
          };
      };
      
      return $ip_address;
  }
  
  =item B<public_ipv4>: returns I<string>; throws I<Net::Address::IP::Local::Error>
  
  Returns the textual representation of the local system's IPv4 address that is "en
  route" to "the internet".  If there is no IPv4 route to the internet, a
  I<Net::Address::IP::Local::Error> exception is thrown.
  
  =cut
  
  sub public_ipv4 {
      my ($class) = @_;
      $class->ipv4_support
          or throw Net::Address::IP::Local::Error("IPv4 not supported");
      return $class->connected_to($class->remote_address_ipv4_default);
  }
  
  =item B<public_ipv6>: returns I<string>; throws I<Net::Address::IP::Local::Error>
  
  Returns the textual representation of the local system's IPv6 address that is "en
  route" to "the internet".  If there is no IPv6 route to the internet, a
  I<Net::Address::IP::Local::Error> exception is thrown.
  
  =cut
  
  sub public_ipv6 {
      my ($class) = @_;
      $class->ipv6_support
          or throw Net::Address::IP::Local::Error("IPv6 not supported");
      return $class->connected_to($class->remote_address_ipv6_default);
  }
  
  =item B<connected_to($remote_address)>: returns I<string>; throws
  I<Net::Address::IP::Local::Error>
  
  Returns the textual representation of the local system's IP address that is "en
  route" to the given remote IP address.  If there is no route to the given
  remote IP address, a I<Net::Address::IP::Local::Error> exception is thrown.
  
  =cut
  
  sub connected_to {
      my ($class, $remote_address) = @_;
      
      my $socket_class;
      if ($class->ipv6_support) {
          $socket_class = 'IO::Socket::INET6';
      }
      elsif ($class->ipv4_support) {
          $socket_class = 'IO::Socket::INET';
      }
      else {
          throw Net::Address::IP::Local::Error("Neither IPv4 nor IPv6 supported");
      }
      
      my $socket = $socket_class->new(
          Proto       => 'udp',
          PeerAddr    => $remote_address,
          PeerPort    => $class->remote_port_default
      );
      
      defined($socket)
          or throw Net::Address::IP::Local::Error("Unable to create UDP socket: $!");
      
      return $socket->sockhost;
  }
  
  =back
  
  =cut
  
  # Private helper methods:
  
  my $ipv4_support;
  
  sub ipv4_support {
      if (not defined($ipv4_support)) {
          eval { require IO::Socket::INET };
          $ipv4_support = not $@;
      }
      return $ipv4_support;
  }
  
  my $ipv6_support;
  
  sub ipv6_support {
      if (not defined($ipv6_support)) {
          eval { require IO::Socket::INET6 };
          $ipv6_support = not $@;
      }
      return $ipv6_support;
  }
  
  =head1 AVAILABILITY and SUPPORT
  
  The latest version of Net::Address::IP::Local is available on CPAN and at
  L<http://www.mehnle.net/software/net-address-ip-local-perl>.
  
  Support is usually (but not guaranteed to be) given by the author, Julian
  Mehnle <julian@mehnle.net>.
  
  =head1 AUTHOR and LICENSE
  
  Net::Address::IP::Local is Copyright (C) 2005-2009 Julian Mehnle
  <julian@mehnle.net>.
  
  Net::Address::IP::Local is free software.  You may use, modify, and distribute
  it under the same terms as Perl itself, i.e. under the GNU GPL or the Artistic
  License.
  
  =cut
  
  package Net::Address::IP::Local::Error;
  use base qw(Error::Simple);
  
  package Net::Address::IP::Local;
  
  TRUE;
NET_ADDRESS_IP_LOCAL

$fatpacked{"Ocollector/AccountServer/AC.pm"} = <<'OCOLLECTOR_ACCOUNTSERVER_AC';
  package Ocollector::AccountServer::AC;
  
  use strict;
  use warnings;
  use Date::Parse;
  use Data::Dumper;
  use Net::Address::IP::Local;
  
  my @accessors = qw( metric logdir logname tag_partial interval errormsg pattern );
  
  use base qw(Class::Accessor Ocollector::Common);
  Ocollector::AccountServer::AC->mk_accessors(@accessors);
  
  our $VERSION = '1.0';
  
  # æˆ‘ä»¬å‡è®¾ACä¸ä¼šå¾ˆå¤§ï¼Œæ‰€ä»¥æ¯æ¬¡è¯»å–å½“å¤©çš„æ€»è¡Œæ•°
  # AC.logæ–‡ä»¶ä»…åœ¨å‡ºå¼‚å¸¸æ—¶ç”Ÿæˆï¼Œæ‰€ä»¥å…ˆåˆ¤æ–­æ–‡ä»¶æ˜¯å¦å­˜åœ¨
  
  my $re_ipv4 = qr/(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2}))/ixsm;
  
  sub new {
      my $class = shift;
      my $opts  = ref($_[0]) ? shift : {@_};
  
      my $self;
      foreach my $opt (keys %{$opts}) {
          $self->{$opt} = $opts->{$opt};
      }
  
      $self->{metric}    = 'AccsvrStats.AC';
      $self->{errormsg}  = '';
  
      # 23:09:27.289    [Error]CommonSDK Register Failed, [strValue kkgfxz03668.sdo] [uNumId 1441509681] [MsgTye 1] [nRet -10242408]
      $self->{pattern}   = qr/^\d{2}:\d{2}:\d{2}\.\d{3} \s+ \[Error\](CommonSDK \s Register \s Failed)/ixsm;
  
      my @tags;
      push @tags, 'host=' . Net::Address::IP::Local->public_ipv4;
  
      if (exists $self->{svcgrp}) {
          push @tags, 'svcgrp=' . $self->{svcgrp};
      } else {
          push @tags, 'svcgrp=rachel';
      }
  
      $self->{tag_partial} = join(' ', @tags);
      
  
      return bless $self, $class;
  }
  
  sub show_results {
      my ($self) = @_;
  
      my $logfile = $self->determine_log($self->logdir, $self->logname);
      my $pattern = $self->pattern;
  
      my $results;
      my $rc;
  
      if (-e $logfile) {
          open my $fh, '<', $logfile;
          if ($fh) {
              while (defined (my $line = <$fh>)) {
                  if ($line =~ $pattern) {
                      $rc->{$1}++;
                  }
              }
  
              foreach my $reason (sort keys %{$rc}) {
                  my $rtag = $reason;
                  $rtag =~ s/\s/_/g;
                  $results .= sprintf("put %s %d %d reason=%s %s\n", $self->metric, time, $rc->{$reason}, $rtag, $self->{tag_partial});
              }
          } else {
              $self->errormsg("open logfile: $logfile failed");
          }
      } else {
          $self->errormsg("logfile: $logfile does not exists");
      }
  
      return $results;
  }
OCOLLECTOR_ACCOUNTSERVER_AC

$fatpacked{"Ocollector/AccountServer/Cache.pm"} = <<'OCOLLECTOR_ACCOUNTSERVER_CACHE';
  package Ocollector::AccountServer::Cache;
  
  use strict;
  use warnings;
  use Date::Parse;
  use Data::Dumper;
  use Net::Address::IP::Local;
  
  my @accessors = qw( metric logdir logname tag_partial interval errormsg);
  
  use base qw(Class::Accessor Ocollector::Common);
  Ocollector::AccountServer::Cache->mk_accessors(@accessors);
  
  our $VERSION = '1.0';
  
  sub new {
      my $class = shift;
      my $opts  = ref($_[0]) ? shift : {@_};
  
      my $self;
      foreach my $opt (keys %{$opts}) {
          $self->{$opt} = $opts->{$opt};
      }
  
      $self->{metric}    = 'AccsvrStats';
      $self->{errormsg}  = '';
  
      my @tags;
      push @tags, 'host=' . Net::Address::IP::Local->public_ipv4;
  
      if (exists $self->{svcgrp}) {
          push @tags, 'svcgrp=' . $self->{svcgrp};
      } else {
          push @tags, 'svcgrp=rachel';
      }
  
      $self->{tag_partial} = join(' ', @tags);
      
  
      return bless $self, $class;
  }
  
  sub show_results {
      my ($self) = @_;
  
      my $rc;
  
      my $logfile = $self->determine_log($self->logdir, $self->logname);
      my $bw = File::ReadBackwards->new($logfile);
  
      my $results;
      if ($bw) {
          my $stop = time - $self->interval;
  
          BACKWARD_READ:
          while (defined (my $line = $bw->readline)) {
              chomp $line;
  
              # 00:23:26.582    [CacheInfo] [TotalCount: 8415] [TrustCache: 7574] [CacheSucc: 5103]
  
              my ($time) = ($line =~ /^(\d{2}:\d{2}:\d{2})/);
              $time = sprintf("%s %s", Date::Tiny->now->ymd, $time);
  
              # each line
              my $sec = str2time($time);
              if ($sec >= $stop) {
                  # è¿‡æ»¤æŽ‰éžCacheInfoçš„
                  if ($line =~ /\[TotalCount:\s*(\d+)\] \s* \[TrustCache:\s*(\d+)\] \s* \[CacheSucc:\s*(\d+)\]/ixsm) {
                      my ($totalcount, $trustcache, $cachesucc) = ($1, $2, $3);
                      $results .= sprintf("put AccsvrStats.Cache.TotalCount %d %d %s\n", time, $totalcount, $self->{tag_partial});
                      $results .= sprintf("put AccsvrStats.Cache.TrustCache %d %d %s\n", time, $trustcache, $self->{tag_partial});
                      $results .= sprintf("put AccsvrStats.Cache.CacheSucc %d %d %s\n", time, $cachesucc, $self->{tag_partial});
                  }
  
                  next BACKWARD_READ;
              }
              else {
                  # åœæ­¢parseï¼Œæ—¶é—´åˆ°
                  last BACKWARD_READ;
              }
          }
      } else {
          $self->errormsg("open logfile: $logfile failed");
      }
  
      return $results;;
  }
OCOLLECTOR_ACCOUNTSERVER_CACHE

$fatpacked{"Ocollector/AccountServer/DBComErr.pm"} = <<'OCOLLECTOR_ACCOUNTSERVER_DBCOMERR';
  package Ocollector::AccountServer::DBComErr;
  
  use strict;
  use warnings;
  use Date::Parse;
  use Data::Dumper;
  use Net::Address::IP::Local;
  
  my @accessors = qw( metric logdir logname tag_partial interval errormsg pattern );
  
  use base qw(Class::Accessor Ocollector::Common);
  Ocollector::AccountServer::DBComErr->mk_accessors(@accessors);
  
  our $VERSION = '1.0';
  
  # æˆ‘ä»¬å‡è®¾DBComErrä¸ä¼šå¾ˆå¤§ï¼Œæ‰€ä»¥æ¯æ¬¡è¯»å–å½“å¤©çš„æ€»è¡Œæ•°
  # DBComErr.logæ–‡ä»¶ä»…åœ¨å‡ºå¼‚å¸¸æ—¶ç”Ÿæˆï¼Œæ‰€ä»¥å…ˆåˆ¤æ–­æ–‡ä»¶æ˜¯å¦å­˜åœ¨
  
  my $re_ipv4 = qr/(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2}))/ixsm;
  sub new {
      my $class = shift;
      my $opts  = ref($_[0]) ? shift : {@_};
  
      my $self;
      foreach my $opt (keys %{$opts}) {
          $self->{$opt} = $opts->{$opt};
      }
  
      $self->{metric}    = 'AccsvrStats.DBComErr';
      $self->{errormsg}  = '';
  
      # 14:45:34.324  [ip=10.126.7.112]strError=[DBNETLIB][ConnectionWrite (send()).]
      $self->{pattern}   = qr/^\d{2}:\d{2}:\d{2}\.\d{3} \s+ \[ip=($re_ipv4)\]strError=\[DBNETLIB\]\[ConnectionWrite\s\(send\(\)\)\.\]/ixsm;
  
      my @tags;
      push @tags, 'host=' . Net::Address::IP::Local->public_ipv4;
  
      if (exists $self->{svcgrp}) {
          push @tags, 'svcgrp=' . $self->{svcgrp};
      } else {
          push @tags, 'svcgrp=rachel';
      }
  
      $self->{tag_partial} = join(' ', @tags);
      
  
      return bless $self, $class;
  }
  
  sub show_results {
      my ($self) = @_;
  
      my $logfile = $self->determine_log($self->logdir, $self->logname);
      my $pattern = $self->pattern;
  
      my $results;
      my $rc;
  
      if (-e $logfile) {
          open my $fh, '<', $logfile;
          if ($fh) {
              while (defined (my $line = <$fh>)) {
                  if ($line =~ $pattern) {
                      $rc->{$1}++;
                  }
              }
  
              foreach my $db (sort keys %{$rc}) {
                  $results .= sprintf("put %s %d %d database=%s %s\n", $self->metric, time, $rc->{$db}, $db, $self->{tag_partial});
              }
          } else {
              $self->errormsg("open logfile: $logfile failed");
          }
      } else {
          $self->errormsg("logfile: $logfile does not exists");
      }
  
      return $results;
  }
OCOLLECTOR_ACCOUNTSERVER_DBCOMERR

$fatpacked{"Ocollector/AccountServer/StatisticDetails.pm"} = <<'OCOLLECTOR_ACCOUNTSERVER_STATISTICDETAILS';
  package Ocollector::AccountServer::StatisticDetails;
  
  use strict;
  use warnings;
  use Date::Parse;
  use Data::Dumper;
  use Net::Address::IP::Local;
  
  my @accessors = qw( metric logdir logname tag_partial interval errormsg);
  
  use base qw(Class::Accessor Ocollector::Common);
  Ocollector::AccountServer::StatisticDetails->mk_accessors(@accessors);
  
  our $VERSION = '1.1';
  
  my $rex_zero      = qr{ , \s 0$}ixsm;
  my $rex_game      = qr{ \[ (\d+):(-?\d+) \] }ixsm;
  my $rex_all       = qr{ [(] (\d+) [)] .+? [(] (\d+):(\d+) [)] .+? [(] (\d+):(\d+) [)] .+? [(] (\d+):(\d+) [)] }ixsm;
  
  sub new {
      my $class = shift;
      my $opts  = ref($_[0]) ? shift : {@_};
  
      my $self;
      foreach my $opt (keys %{$opts}) {
          $self->{$opt} = $opts->{$opt};
      }
  
      $self->{metric}    = 'AccsvrStats';
      $self->{errormsg}  = '';
  
      my @tags;
      push @tags, 'host=' . Net::Address::IP::Local->public_ipv4;
  
      if (exists $self->{svcgrp}) {
          push @tags, 'svcgrp=' . $self->{svcgrp};
      } else {
          push @tags, 'svcgrp=rachel';
      }
  
      $self->{tag_partial} = join(' ', @tags);
      
  
      return bless $self, $class;
  }
  
  sub show_results {
      my ($self) = @_;
  
      my $rc;
  
      my $logfile = $self->determine_log($self->logdir, $self->logname);
      my $bw = File::ReadBackwards->new($logfile);
  
      my $results;
      if ($bw) {
          my $re_ipv4 = $Ocollector::Common::re_ipv4;
          my $stop = time - $self->interval;
  
          BACKWARD_READ:
          while (defined (my $line = $bw->readline)) {
              chomp $line;
  
              my ($time, $stats) = split /\s+/, $line;
  
              # anti garbled log here
              unless (defined $time && defined $stats) {
                  next BACKWARD_READ;
              }
  
              # convert 19:47 to 2011-02-10 19:47:00
              $time = sprintf("%s %s:59", Date::Tiny->now->ymd, $time);
  
              # each line
              my $sec = str2time($time);
              if ($sec >= $stop) {
                  my ($gameid, $gamearea) = ($stats =~ $rex_game);
  
                  # metrics are:
                  # accountserver.statisticdetails.total
                  # accountserver.statisticdetails.staticauthen
                  # accountserver.statisticdetails.ekeyauthen
                  # accountserver.statisticdetails.ecardauthen
  
                  # tags are: failed, succeed, gameid, gamearea, host, lb
  
                  if ($stats !~ $rex_all) {
                      next BACKWARD_READ;
                  } else {
                      my ($total, $static_all, $static_success, $ekey_all, $ekey_success, $ecard_all, $ecard_success)
                          = ($1, $2, $3, $4, $5, $6, $7);
                  
                      my $static_fail = $static_all - $static_success;
                      my $ekey_fail   = $ekey_all   - $ekey_success;
                      my $ecard_fail  = $ecard_all  - $ecard_success;
  
                      $results .= sprintf("put %s %d %d gameid=%d gamearea=%d %s\n",
                          $self->metric . '.total', $sec, $total, $gameid, $gamearea, $self->tag_partial);
                  
                      $results .= sprintf("put %s %d %d gameid=%d gamearea=%d type=succeed %s\n",
                          $self->metric . '.static', $sec, $static_success, $gameid, $gamearea, $self->tag_partial);
  
                      $results .= sprintf("put %s %d %d gameid=%d gamearea=%d type=failed %s\n",
                          $self->metric . '.static', $sec, $static_fail, $gameid, $gamearea, $self->tag_partial);
  
                      $results .= sprintf("put %s %d %d gameid=%d gamearea=%d type=succeed %s\n",
                          $self->metric . '.ekey', $sec, $ekey_success, $gameid, $gamearea, $self->tag_partial);
  
                      $results .= sprintf("put %s %d %d gameid=%d gamearea=%d type=failed %s\n",
                          $self->metric . '.ekey', $sec, $ekey_fail, $gameid, $gamearea, $self->tag_partial);
  
                      $results .= sprintf("put %s %d %d gameid=%d gamearea=%d type=succeed %s\n",
                          $self->metric . '.ecard', $sec, $ecard_success, $gameid, $gamearea, $self->tag_partial);
  
                      $results .= sprintf("put %s %d %d gameid=%d gamearea=%d type=failed %s\n",
                          $self->metric . '.ecard', $sec, $ecard_fail, $gameid, $gamearea, $self->tag_partial);
                  }
              }
              else {
                  # åœæ­¢parseï¼Œæ—¶é—´åˆ°
                  last BACKWARD_READ;
              }
          }
      } else {
          $self->errormsg("open logfile: $logfile failed");
      }
  
      return $results;;
  }
OCOLLECTOR_ACCOUNTSERVER_STATISTICDETAILS

$fatpacked{"Ocollector/CloudStat/Cpu.pm"} = <<'OCOLLECTOR_CLOUDSTAT_CPU';
  package Ocollector::CloudStat::Cpu;
  
  use strict;
  use warnings;
  use Net::Address::IP::Local;
  use Sys::Hostname;
  
  my @accessors = qw( tag_partial interval errormsg metric );
  
  use base qw(Class::Accessor Ocollector::Common);
  Ocollector::CloudStat::Disk->mk_accessors(@accessors);
  
  
  our $VERSION = '1.0';
  
  sub new {
      my $class = shift;
      my $opts  = ref($_[0]) ? shift : {@_};
  
      my $self;
      foreach my $opt (keys %{$opts}) {
          $self->{$opt} = $opts->{$opt};
      }
  
      $self->{errormsg}  = '';
  
      my @tags;
      if ($self->{prefer} && $self->{prefer} =~ /hostname/ixsm) {
          push @tags, 'host=' . hostname;
      } else {
          push @tags, 'host=' . Net::Address::IP::Local->public_ipv4;
      }
  
      $self->{tag_partial} = join(' ', @tags);
      $self->{metric} = 'Cloud.HostStat.Dis';
  
      my $nr_cpus = `/usr/sbin/xm info | grep 'nr_cpus'`;
      ($self->{ncpus}) = ($nr_cpus =~ /(\d+)/);
  
      return bless $self, $class;
  }
  
  sub show_results {
      my $self = shift;
  
      # except domain 0
      my $xentop = `/usr/sbin/xentop -i 2 -d 1 -b`;
      my ($total, $used, $usage, $free);
  
      # let's see if we should integrate further
  
      my $results;
      if (defined $total && defined $free) {
          $used = $total - $free;
          $usage = ($used/$total)*100;
  
          my $metric = $self->metric;
          my $tag_partial = $self->tag_partial;
      }
  
      return $results;
  }
OCOLLECTOR_CLOUDSTAT_CPU

$fatpacked{"Ocollector/CloudStat/Disk.pm"} = <<'OCOLLECTOR_CLOUDSTAT_DISK';
  package Ocollector::CloudStat::Disk;
  
  use strict;
  use warnings;
  use Net::Address::IP::Local;
  use Sys::Hostname;
  
  my @accessors = qw( tag_partial interval errormsg);
  
  use base qw(Class::Accessor Ocollector::Common);
  Ocollector::CloudStat::Disk->mk_accessors(@accessors);
  
  
  our $VERSION = '1.0';
  
  sub new {
      my $class = shift;
      my $opts  = ref($_[0]) ? shift : {@_};
  
      my $self;
      foreach my $opt (keys %{$opts}) {
          $self->{$opt} = $opts->{$opt};
      }
  
      $self->{errormsg}  = '';
  
      my @tags;
      if ($self->{prefer} && $self->{prefer} =~ /hostname/ixsm) {
          push @tags, 'host=' . hostname;
      } else {
          push @tags, 'host=' . Net::Address::IP::Local->public_ipv4;
      }
  
      $self->{tag_partial} = join(' ', @tags);
      $self->{metric} = 'Cloud.HostStat.Memory';
  
  
      return bless $self, $class;
  }
  
  
  # pdis_nod0=(`$VGS_CMD | tr -d 'G' | awk '/xenvg/{print $6,$7}'`)
  # pdis_total_nod0=${pdis_nod0[0]}
  # pdis_free_nod0=${pdis_nod0[1]}
  # pdis_used_nod0=`echo $pdis_total_nod0 $pdis_free_nod0 | awk '{printf "%s",$1-$2}'`
  # pdis_usage_nod0=`echo $pdis_used_nod0 $pdis_total_nod0 | awk '{printf "%.2f",$1/$2*100}'`
  # echo "$METRICNAME_DIS $ts $pdis_used_nod0 disinfo=used vname=allv v=0"
  # echo "$METRICNAME_DIS $ts $pdis_total_nod0 disinfo=total vname=allv v=0"
  # echo "$METRICNAME_DIS $ts $pdis_usage_nod0 disinfo=usage vname=allv v=0"
  
  
  # VG    #PV #LV #SN Attr   VSize   VFree
  #   xenvg   1   6   0 wz--n- 689.61G 526.94G
  sub show_results {
      my $self = shift;
  
      # except domain 0
      my $vgs = `/usr/sbin/vgs --units G`;
      my ($total, $used, $usage, $free);
  
      foreach (split /\n/, $vgs) {
          next unless /\s* xenvg/ixsm;
          ($total, $free) = ($_ =~ /([0-9.]+)G \s ([0-9.]+)G$/ixsm);
      }
  
  
      my $results;
  
      if (defined $total && defined $free) {
          $used = $total - $free;
          $usage = ($used/$total)*100;
  
          my $metric = $self->metric;
          my $tag_partial = $self->tag_partial;
          $results .= sprintf("put %s %d %d %s disinfo=used vname=allv v=0\n", $metric, time, $used, $tag_partial);
          $results .= sprintf("put %s %d %d %s disinfo=total vname=allv v=0\n", $metric, time, $total, $tag_partial);
          $results .= sprintf("put %s %d %d %s disinfo=usage vname=allv v=0\n", $metric, time, $usage, $tag_partial);
      }
  
      return $results;
  }
OCOLLECTOR_CLOUDSTAT_DISK

$fatpacked{"Ocollector/CloudStat/Memory.pm"} = <<'OCOLLECTOR_CLOUDSTAT_MEMORY';
  package Ocollector::CloudStat::Memory;
  
  use strict;
  use warnings;
  use Net::Address::IP::Local;
  
  my @accessors = qw( tag_partial interval errormsg);
  
  use base qw(Class::Accessor Ocollector::Common);
  Ocollector::CloudStat::Memory->mk_accessors(@accessors);
  
  
  our $VERSION = '1.0';
  
  sub new {
      my $class = shift;
      my $opts  = ref($_[0]) ? shift : {@_};
  
      my $self;
      foreach my $opt (keys %{$opts}) {
          $self->{$opt} = $opts->{$opt};
      }
  
      $self->{errormsg}  = '';
  
      my @tags;
      if ($self->{prefer} && $self->{prefer} =~ /hostname/ixsm) {
          push @tags, 'host=' . hostname;
      } else {
          push @tags, 'host=' . Net::Address::IP::Local->public_ipv4;
      }
  
      $self->{tag_partial} = join(' ', @tags);
      $self->{metric} = 'Cloud.HostStat.Memory';
  
  
      return bless $self, $class;
  }
  
  sub get_xminfo {
      my $rc;
      my $pmem = `xm info`;
  
      foreach (split /\n/, $pmem) {
          next unless /(total|free)_memory/ixsm;
          my $k = $1;
          my ($v) = ($_ =~ /\w+ .* (\d+)/);
          $rc->{$k} = $v;
      }
  
      my $used_percent = (1 - ($rc->{free} / $rc->{total}))*100;
      $rc->{used} = $rc->{total} - $rc->{free};
      $rc->{usage} = $rc->{used}/$rc->{total}*100;
      delete $rc->{free};
  
      return $rc;
  }
  
  sub get_free {
      my $rc;
      my $d0mem = `free -m`;
  
      foreach (split /\n/, $d0mem) {
          next unless /^Mem/ixsm;
          my ($total, $used) = ($_ =~ /(\d+) .*? (\d+)/);
          $rc->{total} = $total;
          $rc->{used} = $used;
      }
  
      my $used_percent = ($rc->{used} / $rc->{total})*100;
      $rc->{usage} = $used_percent;
  
      return $rc;
  }
  
  sub show_results {
      my $self = shift;
  
      my $pmem = get_xminfo();
      my $dom0 = get_free();
  
      my $pmem_total_nod0 = $pmem->{total} - $dom0->{total};
      my $pmem_used_nod0  = $pmem->{used}  - $dom0->{used};
      my $pmem_usage_nod0 = ($pmem_used_nod0/$pmem_total_nod0)*100;
  
      my $results;
      my $metric = $self->metric;
      my $tag_partial = $self->tag_partial;
  
      $results .= sprintf("put %s %d %d %s meminfo=used vname=all v=0\n", $metric, time, $pmem->{used}, $tag_partial);
      $results .= sprintf("put %s %d %d %s meminfo=total vname=all v=0\n", $metric, time, $pmem->{total}, $tag_partial);
      $results .= sprintf("put %s %d %d %s meminfo=usage vname=all v=0\n", $metric, time, $pmem->{usage}, $tag_partial);
  
      $results .= sprintf("put %s %d %d %s meminfo=used vname=allv v=0\n", $metric, time, $pmem_used_nod0, $tag_partial);
      $results .= sprintf("put %s %d %d %s meminfo=total vname=allv v=0\n", $metric, time, $pmem_total_nod0, $tag_partial);
      $results .= sprintf("put %s %d %d %s meminfo=usage vname=allv v=0\n", $metric, time, $pmem_usage_nod0, $tag_partial);
  
      return $results;
  }
OCOLLECTOR_CLOUDSTAT_MEMORY

$fatpacked{"Ocollector/CloudStat/Wrapper.pm"} = <<'OCOLLECTOR_CLOUDSTAT_WRAPPER';
  package Ocollector::CloudStat::Wrapper;
  
  use strict;
  use warnings;
  use Net::Address::IP::Local;
  use Sys::Hostname;
  
  my @accessors = qw( tag_partial interval errormsg script );
  
  use base qw(Class::Accessor Ocollector::Common);
  Ocollector::CloudStat::Wrapper->mk_accessors(@accessors);
  
  
  our $VERSION = '1.0';
  
  sub new {
      my $class = shift;
      my $opts  = ref($_[0]) ? shift : {@_};
  
      my $self;
      foreach my $opt (keys %{$opts}) {
          $self->{$opt} = $opts->{$opt};
      }
  
      $self->{errormsg}  = '';
  
      my @tags;
      if ($self->{prefer} && $self->{prefer} =~ /hostname/ixsm) {
          push @tags, 'host=' . hostname;
      } else {
          push @tags, 'host=' . Net::Address::IP::Local->public_ipv4;
      }
  
      $self->{tag_partial} = join(' ', @tags);
  
  
      return bless $self, $class;
  }
  
  sub show_results {
      my $self = shift;
  
      my $results;
      my $tag_partial = $self->tag_partial;
  
      my $script = $self->script;
      my $rc = `$script`;
      if ($rc) {
          foreach (split /\n/, $rc) {
              chomp;
              $results .= sprintf("put %s %s\n", $_, $tag_partial);
          }
      }
  
      return $results;
  }
OCOLLECTOR_CLOUDSTAT_WRAPPER

$fatpacked{"Ocollector/Common.pm"} = <<'OCOLLECTOR_COMMON';
  package Ocollector::Common;
  
  use strict;
  use warnings;
  use Digest::MD5;
  use File::ReadBackwards;
  use File::Spec;
  use Date::Tiny;
  use Exporter 'import';
  our @EXPORT_OK = qw($re_ipv4);
  
  my @accessors;
  
  use base 'Class::Accessor';
  Ocollector::Common->mk_accessors(@accessors);
  
  our $VERSION = '1.0';
  our $re_ipv4 = qr/(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2}))/ixsm;
  
  sub new {
      my $class = shift;
      my $opts  = ref($_[0]) ? shift : {@_};
  
      my $self = {};
      return bless $self, $class;
  }
  
  sub determine_log {
      my ($self, $logdir, $logname) = @_;
  
      my $dt = Date::Tiny->now;
      return File::Spec->catfile($logdir, $dt->ymd, $logname);
  }
  
  sub give_md5 {
      my ($self, $content) = @_;
  
      my $ctx = Digest::MD5->new;
      $ctx->add($content);
      return $ctx->hexdigest;
  }
  
  sub determine_latest {
      my ($self, $logdir, $pattern) = @_;
  
      my $dir_fh;
      if (-d $logdir) {
          opendir $dir_fh, $logdir;
  
          unless ($dir_fh) {
              return;
          } else {
              my $rc;
              while ((my $filename = readdir($dir_fh))) {
                  next unless $filename =~ qr/$pattern/ixsm;
  
                  my $full_filename = File::Spec->catfile($logdir, $filename);
                  my $mtime = (stat($full_filename))[9];
                  $rc->{$mtime} = $full_filename;
              }
  
              my @sorted = sort { $b <=> $a } keys %{$rc};
              my $this_file = $rc->{$sorted[0]};
  
              return $this_file;
          }
      }
  
      return;
  }
  
  1;
OCOLLECTOR_COMMON

$fatpacked{"Ocollector/IIS/Error2.pm"} = <<'OCOLLECTOR_IIS_ERROR2';
  package Ocollector::IIS::Error2;
  
  use strict;
  use warnings;
  use Date::Parse;
  use Data::Dumper;
  
  my @accessors = qw(metric logdir logfile interval errormsg tag_partial);
  
  use base qw(Class::Accessor Ocollector::Common);
  Ocollector::IIS::Error2->mk_accessors(@accessors);
  
  our $VERSION = '1.0';
  
  # Fields: date time c-ip c-port s-ip s-port cs-version cs-method cs-uri sc-status s-siteid s-reason s-queuename
  # 2011-02-25 11:18:33 119.188.13.68 4010 61.172.251.22 4387 HTTP/1.1 GET /Protect/SessionSvrDispatch.asp?type=89&area=9&server=4 503 447434323 AppOffline DefaultAppPool
  # 2011-02-25 11:18:33 222.73.21.124 48833 61.172.251.22 4387 HTTP/1.1 GET /Protect/SessionSvrDispatch.asp?type=41&area=1&server=1 503 447434323 AppOffline DefaultAppPool
  # 2011-02-25 11:18:33 210.51.29.203 1977 61.172.251.22 4387 HTTP/1.1 GET /Protect/SessionSvrDispatch.asp?type=41&area=1&server=1 503 447434323 AppOffline DefaultAppPool
  # 2011-02-25 12:46:36 115.238.116.5 3741 61.172.251.22 4387 - - - - - Timer_ConnectionIdle -
  
  #======================================================================
  # The documetation of HTTP Error can be found at:
  # http://support.microsoft.com/default.aspx?scid=kb;en-us;820729
  
  my $re_ipv4 = qr/(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2}))/ixsm;
  my $re_ipv4_iis_xff = qr/($re_ipv4)(?:\,?\+$re_ipv4\,?)*/ixsm;
  my $re_uri = qr/(?:[^ ]+|-)/ixsm;
  my $re_status = qr/\d+|-/ixsm;
  my $re_port = qr/\d+/ixsm;
  my $re_httpver = qr/(?:HTTP\/[\d.]+|-)/ixsm;
  my $re_method = qr/(?:\w+|-)/ixsm;
  my $re_siteid = qr/(?:\d+|-)/ixsm;
  my $re_reason = qr/(?:AppOffline|AppPoolTimer|AppShutdown|Connection_Abandoned_By_AppPool|Connection_Abandoned_By_ReqQueue|Connection_Dropped|Connection_Dropped_List_Full|ConnLimit|Connections_Refuse|Disabled|EntityTooLarge|Internal|Header|Forbidden|FieldLength|Hostname|N\/A|N\/I|QueueFull|Timer_AppPool|RequestLength|Timer_ReqQueue|-)/ixsm;
  my $re_queuename = qr/(?:[\w.]+|-)/ixsm;
  my $re_httperr = qr/httperr\d+\.log/ixsm;
  my $re_iis_time = qr/\d{4}-\d{2}-\d{2} \s \d{2}:\d{2}:\d{2}/ixsm;
  my $re_iis6_httperr = qr/$re_iis_time \s $re_ipv4_iis_xff \s $re_port \s ($re_ipv4) \s $re_port \s $re_httpver \s $re_method \s $re_uri \s ($re_status) \s $re_siteid \s ($re_reason) \s ($re_queuename)/ixsm;
  
  sub new {
      my $class = shift;
      my $opts  = ref($_[0]) ? shift : {@_};
  
      # å…è®¸ç”¨æˆ·æŒ‡å®š
      my $self;
      $self->{logdir}    = "C:\\WINDOWS\\system32\\LogFiles\\HTTPERR";
      $self->{metric}     = 'iis.error2';
      $self->{errormsg}   = '';
  
      foreach my $opt (keys %{$opts}) {
          $self->{$opt} = $opts->{$opt};
      }
  
      my @tags;
      push @tags, 'host=' . Net::Address::IP::Local->public_ipv4;
  
      $self->{tag_partial} = join(' ', @tags);
  
      return bless $self, $class;
  }
  
  sub do_parse {
      my $self = shift;
  
      my $timefrm = $self->interval;
      my $logfile = $self->determin_iislog;
  
  #   print "logfile is: $logfile\n";
  
      my $stop = time() - $timefrm;
  
      my $bw = File::ReadBackwards->new($logfile);
      my $rc;
      if ($bw) {
          BACKWARD_READ:
          while (defined (my $line = $bw->readline)) {
              chomp $line;
  
              # debug purpose
  #           if ($self->logfile) {
  #               if ($line =~ $re_iis6_httperr) {
  #                   my ($cip, $sip, $status, $reason, $queuename) = ($1, $2, $3, $4, $5);
  #                   print "$sip, $status, $reason, $queuename\n";
  
  #                   if ($reason eq '-') { $reason = 'none' };
  #                   if ($queuename eq '-') { $queuename = 'none' };
  
  #                   # ä¸è®¡ç®—éž500çš„é”™è¯¯ 
  #                   if ($status =~ /^5\d{2}/ixsm) {
  #                       $rc->{$sip}->{$queuename}->{$reason}++;
  #                   } else {
  #                       next BACKWARD_READ;
  #                   }
  #               } else {
  #                   next BACKWARD_READ;
  #               }
  
  #               last BACKWARD_READ;
  #           }
  
              if ($line =~ qr/($re_iis_time)/ixsm) {
                  my $msec = str2time($1);
  
                  if ($msec < $stop) {
                      last BACKWARD_READ;
                  } else {
                      if ($line =~ $re_iis6_httperr) {
                          my ($cip, $sip, $status, $reason, $queuename) = ($1, $2, $3, $4, $5);
  
                          if ($reason eq '-') { $reason = 'none' };
                          if ($queuename eq '-') { $queuename = 'none' };
  
                          # ä¸è®¡ç®—éž500çš„é”™è¯¯ 
                          if ($status =~ /^5\d{2}/ixsm) {
                              $rc->{$sip}->{$queuename}->{$reason}++;
                          } else {
                              next BACKWARD_READ;
                          }
                      } else {
                          next BACKWARD_READ;
                      }
                  }
              }
          }
      } else {
          $self->errormsg("failed to open $logfile");
          return undef;
      }
  
      unless (defined $rc) {
          $self->errormsg("empty parse");
      }
  
      return $rc;
  }
  
  
  sub show_results {
      my $self = shift;
  
      my $rc = $self->do_parse;
      my $results;
  
      my $metric = $self->metric;
      my $tag_partial = $self->tag_partial;
      foreach my $queuename (sort keys %{$rc}) {
          foreach my $reason (sort keys %{$rc->{$queuename}}) {
              $results .= sprintf("put %s %d %d queuename=%s reason=%s %s\n",
                      $metric, time, $rc->{$queuename}->{$reason}, $queuename, $reason, $tag_partial);
          }
      }
  
      return $results;
  }
  
  sub determin_iislog {
      my $self = shift;
  
      my $logdir = $self->logdir;
  
      # å¦‚æžœæŒ‡å®šäº†logfileï¼Œå°±ä¸è‡ªåŠ¨é€‰å–
      # å¯ç”¨äºŽDebug 
      if ($self->logfile) {
          return $logdir . '\\' . $self->logfile;
      }
  
      my $dir_fh;
      opendir $dir_fh, $logdir;
  
      unless ($dir_fh) {
          $self->errormsg("failed to open dir: $logdir");
          return undef;
      }
  
      my $rc;
      while ((my $filename = readdir($dir_fh))) {
          # è·³è¿‡ä¸ç¬¦åˆIISæ—¥å¿—(httperr\d+.log)
          next unless $filename =~ $re_httperr;
  
          # ç„¶åŽå–mtimeæœ€å¤§çš„
          my $full_filename = File::Spec->catfile($logdir, $filename);
          my $mtime = (stat($full_filename))[9];
          $rc->{$mtime} = $full_filename;
      }
  
      my @sorted = sort { $b <=> $a } keys %{$rc};
      my $this_file = $rc->{$sorted[0]};
  
      unless ($this_file) {
          $self->errormsg("failed to obtain iis logfile, no max mtime");
      }
  
      return $this_file;
  }
  
  1;
OCOLLECTOR_IIS_ERROR2

$fatpacked{"Ocollector/NetAppliance/Cisco/Switch.pm"} = <<'OCOLLECTOR_NETAPPLIANCE_CISCO_SWITCH';
  package Ocollector::NetAppliance::Cisco::Switch;
  
  use strict;
  use warnings;
  use Date::Parse;
  use Data::Dumper;
  use File::Spec;
  
  my @accessors = qw( metric logdir logfile interval errormsg tag_partial debug tzdiff );
  
  use base qw(Class::Accessor Ocollector::Common);
  Ocollector::NetAppliance::Cisco::Switch->mk_accessors(@accessors);
  
  our $VERSION = '1.0';
  
  my $date_fmt_re = qr/\d{4}\/\d{2}\/\d{2}-\d{2}:\d{2}:\d{2}/ixsm;
  
  sub new {
      my $class = shift;
  
      my $opts  = ref($_[0]) ? shift : {@_};
  
      # å…è®¸ç”¨æˆ·æŒ‡å®š
      my $self;
      $self->{logdir}    = q{C:\Program Files (x86)\Cisco Systems\dcm\fm\logs};
      $self->{logfile}   = 'NH-MDS-1_summarylog.txt,NH-MDS-2_summarylog.txt';
      $self->{metric}    = 'NetAppliance.Cisco.Switch';
      $self->{tzdiff}    = 0;
      $self->{interval}  = 10;
      $self->{errormsg}  = '';
      $self->{debug}     = '';
  
      foreach my $opt (keys %{$opts}) {
          $self->{$opt} = $opts->{$opt};
      }
  
      my @tags;
      push @tags, 'host=' . Net::Address::IP::Local->public_ipv4;
  
      $self->{tag_partial} = join(' ', @tags);
  
      return bless $self, $class;
  }
  
  sub build_log_targets {
      my $self = shift;
  
      my @logfiles = map { File::Spec->catfile($self->logdir, $_) } split /\s*,\s*/, $self->logfile;
      return @logfiles;
  }
  
  sub do_parse {
      my $self = shift;
  
      my $timefrm = $self->interval;
      my ($logfile) = @_;
  
  
      my $stop = time() - $timefrm;
  
      # if the timezone is provided, adjust stop value from the current timezone 
      # for example, if we are in +8 and the log is written in -12, timezone should be set to 20
      if ($self->tzdiff != 0) {
          $stop -= $self->tzdiff * 3600;
      }
  
      my $rc;
      my $bw = File::ReadBackwards->new($logfile);
      if ($bw) {
          BACKWARD_READ:
          while (defined (my $line = $bw->readline)) {
              chomp $line;
  
              if ($line =~ /($date_fmt_re)/ixsm) {
                  # convert 2011/03/17-22:49:49 to 2011-03-17 22:49:49
                  my $ts = $1;
                  $ts =~ s/-/ /;
                  $ts =~ s/\//-/g;
  
                  my $msec = str2time($ts);
                  if ($msec < $stop && !$self->debug) {
                      last BACKWARD_READ;
                  } else {
                      my ($interface, $rx, $tx, $error, $discard) = split /\s+/, $line;
                      if ($interface eq 'Interface') {
                          next BACKWARD_READ; # see a header line
                      } else {
                          $interface =~ s/\//_/;
                          $rc->{$interface}->{rx} += $rx;
                          $rc->{$interface}->{tx} += $tx;
                          $rc->{$interface}->{errors} += $error;
                          $rc->{$interface}->{discards} += $discard;
                      }
                  }
              }
          }
      }
  
      return $rc;
  }
  
  sub show_results {
      my $self = shift;
  
      my @logfiles = $self->build_log_targets();
  
      my $results;
  
      foreach my $logfile (sort @logfiles) {
          my $rc = $self->do_parse($logfile);
          foreach my $interface (sort keys %{$rc}) {
              my $rx        = $rc->{$interface}->{rx};
              my $tx        = $rc->{$interface}->{tx};
              my $errors    = $rc->{$interface}->{errors};
              my $discards  = $rc->{$interface}->{discards};
  
              $results .= sprintf("put %s.rx %d %.0f interface=%s %s\n",
                  $self->metric, time(), $rx, $interface, $self->tag_partial);
  
              $results .= sprintf("put %s.tx %d %.0f interface=%s %s\n",
                  $self->metric, time(), $tx, $interface, $self->tag_partial);
  
              $results .= sprintf("put %s.error %d %.0f interface=%s %s\n",
                  $self->metric, time(), $errors, $interface, $self->tag_partial);
  
              $results .= sprintf("put %s.discard %d %.0f interface=%s %s\n",
                  $self->metric, time(), $discards, $interface, $self->tag_partial);
          }
  
          if ($self->debug) {
              return $rc;
          }
      }
  
      return $results;
  }
  
  
  1;
OCOLLECTOR_NETAPPLIANCE_CISCO_SWITCH

$fatpacked{"Ocollector/Nginx/ErrorLog.pm"} = <<'OCOLLECTOR_NGINX_ERRORLOG';
  package Ocollector::Nginx::ErrorLog;
  
  use strict;
  use warnings;
  use Date::Parse;
  use Data::Dumper;
  use Sys::Statistics::Linux::DiskUsage;
  
  my @accessors = qw(metric logfile interval errormsg);
  
  use base qw(Class::Accessor Ocollector::Common);
  Ocollector::Nginx::ErrorLog->mk_accessors(@accessors);
  
  our $VERSION = '1.0';
  
  my $re_ipv4 = qr/(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2}))/ixsm;
  my $re_static = qr/\.(?:gif|png|jpg|jpeg|js|css|swf)/ixsm;
  
  sub new {
      my $class = shift;
      my $opts  = ref($_[0]) ? shift : {@_};
  
      # å…è®¸ç”¨æˆ·æŒ‡å®š
      my $self;
      $self->{logfile}    = '/dev/shm/nginx_metrics/errors.log';
      $self->{metric}     = 'nginx.error2';
      $self->{errormsg}   = '';
  
      foreach my $opt (keys %{$opts}) {
          $self->{$opt} = $opts->{$opt};
      }
  
      my @tags;
      push @tags, 'host=' . Net::Address::IP::Local->public_ipv4;
  
      $self->{tag_partial} = join(' ', @tags);
  
      return bless $self, $class;
  }
  
  sub do_parse {
      my $self = shift;
  
      my $timefrm = $self->interval;
      my $logfile = $self->logfile;
  
      my $stop = time() - $timefrm;
  
      my ($rc_dynamic, $rc_static);
      my $bw = File::ReadBackwards->new($logfile);
      if ($bw) {
          BACKWARD_READ:
          while (defined (my $line = $bw->readline)) {
              chomp $line;
  
              if ($line =~ /(\d{4}\/\d{2}\/\d{2} \s \d{2}:\d{2}:\d{2}) \s \[error\]/ixsm) {
                  my $msec = str2time($1);
  
                  if ($msec < $stop) {
                      last BACKWARD_READ;
                  } else {
                      # 1. upstream timed out (slow upstream)
                      # 2. connect() failed (upstream went away)
                      # 3. no live upstream (all upstreams failed)
                      if ($line =~ /(upstream \s timed \s out|connect[()]{2} \s failed) .* request: \s+ "(?:GET|POST|PUT) \s ([^ ?]+) .* upstream: \s+ "http:\/\/($re_ipv4):\d+ .* host: \s+ "([\w.]+)"/ixsm) {
                          my ($uri, $upstream, $domain) = ($2, $3, $4);
  
                          my $reason = '';
                          if ($1 eq 'upstream timed out') {
                              $reason = 'upstream_timed_out';
                          } else {
                              $reason = 'connect_failed';
                          }
  
                          if ($uri !~ $re_static) {
                              $rc_dynamic->{$domain}->{$upstream}->{$reason}++;
                          } else {
                              $rc_static->{$domain}->{$upstream}->{$reason}++;
                          }
                      } elsif ($line =~ /no \s live \s upstream .* request: \s+ "(?:GET|POST|PUT) \s ([^ ?]+) .*  host: \s+ "([\w.]+)"/ixsm) {
                          my ($uri, $domain) = ($1, $2);
  
                          my $upstream = '25.255.255.255';
                          my $reason = 'no_live_upstreams';
                          if ($uri !~ $re_static) {
                              $rc_dynamic->{$domain}->{$upstream}->{$reason}++;
                          } else {
                              $rc_static->{$domain}->{$upstream}->{$reason}++;
                          }
                      } else {
                          1;
                      }
  
                  }
              }
          }
      } else {
          $self->errormsg("failed to open $logfile");
          return undef;
      }
  
      unless (defined $rc_dynamic && defined $rc_static) {
          $self->errormsg('no error produced, great');
      }
  
      return ($rc_dynamic, $rc_static);
  }
  
  
  sub show_results {
      my $self = shift;
      
      # å¦‚æžœä¸çŸ¥é“æ˜¯ä¸æ˜¯åœ¨tmpfsä¸Šï¼Œæˆ‘ä»¬ä¹Ÿå¯ä»¥flushä¸€ä¸‹ã€‚
      # tmpfså°‘äº†ï¼Œè¯´ä¸å®šå°±æ˜¯æˆ‘ä»¬å¼•èµ·çš„ã€‚
      if (flush_tmpfs()) {
          system '>' . $self->logfile;
  
          # flushåŽæ—¥å¿—ä¸ºç©ºï¼Œæœ¬æ¬¡prepare_metricså¤±è´¥ã€‚ 
          $self->errormsg('tmpfs flushed.');
          return 0;
      }
  
      my ($rc_dynamic, $rc_static) = $self->do_parse;
  
      my $results;
      if (defined $rc_dynamic) {
          # å¼€å§‹è®¡ç®—åŠ¨æ€
          foreach my $domain (keys %{$rc_dynamic}) {
              foreach my $upstream (keys %{$rc_dynamic->{$domain}}) {
                  # å¦‚æžœæŸç§ç±»åž‹çš„erroræ²¡æœ‰ï¼Œæˆ‘ä»¬è¿™é‡Œè¡¥ä¸ª0ä¸ŠåŽ»
                  unless (exists $rc_dynamic->{$domain}->{$upstream}->{no_live_upstreams}) {
                      $rc_dynamic->{$domain}->{$upstream}->{no_live_upstreams} = 0;
                  }
  
                  unless (exists $rc_dynamic->{$domain}->{$upstream}->{connect_failed}) {
                      $rc_dynamic->{$domain}->{$upstream}->{connect_failed} = 0;
                  }
  
                  unless (exists $rc_dynamic->{$domain}->{$upstream}->{upstream_timed_out}) {
                      $rc_dynamic->{$domain}->{$upstream}->{upstream_timed_out} = 0;
                  }
  
                  foreach my $reason (keys %{$rc_dynamic->{$domain}->{$upstream}}) {
                      $results .= sprintf("put %s %d %d domain=%s upstream=%s reason=%s %s type=dynamic\n",
                          $self->metric, time(), $rc_dynamic->{$domain}->{$upstream}->{$reason},
                          $domain, $upstream, $reason, $self->{tag_partial});
                  }
              }
          }
          
      }
  
      if (defined $rc_static) {
          foreach my $domain (keys %{$rc_static}) {
              foreach my $upstream (keys %{$rc_static->{$domain}}) {
                  # å¦‚æžœæŸç§ç±»åž‹çš„erroræ²¡æœ‰ï¼Œæˆ‘ä»¬è¿™é‡Œè¡¥ä¸ª0ä¸ŠåŽ»
                  unless (exists $rc_static->{$domain}->{$upstream}->{no_live_upstreams}) {
                      $rc_static->{$domain}->{$upstream}->{no_live_upstreams} = 0;
                  }
  
                  unless (exists $rc_static->{$domain}->{$upstream}->{connect_failed}) {
                      $rc_static->{$domain}->{$upstream}->{connect_failed} = 0;
                  }
  
                  unless (exists $rc_static->{$domain}->{$upstream}->{upstream_timed_out}) {
                      $rc_static->{$domain}->{$upstream}->{upstream_timed_out} = 0;
                  }
  
                  foreach my $reason (keys %{$rc_static->{$domain}->{$upstream}}) {
                      $results .= sprintf("put %s %d %d domain=%s upstream=%s reason=%s %s type=static\n",
                          $self->metric, time(), $rc_static->{$domain}->{$upstream}->{$reason},
                          $domain, $upstream, $reason, $self->{tag_partial});
                  }
              }
          }
      }
  
      return $results;
  }
  
  sub flush_tmpfs {
      my $lxs = Sys::Statistics::Linux::DiskUsage->new;
      my $stat = $lxs->get;
      my $threshold = 90;
  
      if (exists $stat->{tmpfs}) {
          my ($free, $total) = ($stat->{tmpfs}->{free}, $stat->{tmpfs}->{total});
  
          # å¤§å°ä¸º0çš„tmpfså¯èƒ½å­˜åœ¨ä¹ˆï¼Ÿ
          if ($total >= 0) {
              my $used = sprintf("%.2f", ($total - $free)/$total*100);
              # ä½ŽäºŽè¿™ç‚¹æ—¶å¼€å§‹flush 
              if ($used >= $threshold) {
                  return 1;
              }
          }
      }
  
      return 0;
  }
  
  1;
OCOLLECTOR_NGINX_ERRORLOG

$fatpacked{"Ocollector/Nginx/RegionLatency.pm"} = <<'OCOLLECTOR_NGINX_REGIONLATENCY';
  package Ocollector::Nginx::RegionLatency;
  
  use strict;
  use warnings;
  use Net::Address::IP::Local;
  use Sys::Hostname;
  
  my @accessors = qw( tag_partial interval errormsg script );
  
  use base qw(Class::Accessor Ocollector::Common);
  Ocollector::Nginx::RegionLatency->mk_accessors(@accessors);
  
  
  our $VERSION = '1.0';
  
  sub new {
      my $class = shift;
      my $opts  = ref($_[0]) ? shift : {@_};
  
      my $self;
      foreach my $opt (keys %{$opts}) {
          $self->{$opt} = $opts->{$opt};
      }
  
      $self->{errormsg}  = '';
  
      my @tags;
      if ($self->{prefer} && $self->{prefer} =~ /hostname/ixsm) {
          push @tags, 'host=' . hostname;
      } else {
          push @tags, 'host=' . Net::Address::IP::Local->public_ipv4;
      }
  
      $self->{tag_partial} = join(' ', @tags);
  
  
      return bless $self, $class;
  }
  
  sub show_results {
      my $self = shift;
  
      my $results;
      my $tag_partial = $self->tag_partial;
  
      my $script = $self->script;
      my $s = time;
      my $rc = `$script`;
      my $cost = time - $s;
      if ($rc) {
          foreach (split /\n/, $rc) {
              chomp;
              my ($vendor, $region, $counts) = split /\t/;
              $results .= sprintf("put nginx.regioncount %d %d vendor=%s region=%s %s\n",
                  time, $counts, $vendor, $region, $tag_partial);
          }
      }
  
      return $results;
  }
OCOLLECTOR_NGINX_REGIONLATENCY

$fatpacked{"Ocollector/Nginx/SLA.pm"} = <<'OCOLLECTOR_NGINX_SLA';
  package Ocollector::Nginx::SLA;
  
  use strict;
  use warnings;
  use Date::Parse;
  use Data::Dumper;
  use File::Spec;
  use Carp;
  use Sys::Hostname;
  use Sys::Statistics::Linux::DiskUsage;
  
  my @accessors = qw(metric logfile interval errormsg prefer cluster threshold myself virtual tag_partial percentile);
  
  use base qw(Class::Accessor Ocollector::Common);
  Ocollector::Nginx::SLA->mk_accessors(@accessors);
  
  our $VERSION = '1.1';
  
  my $re_ipv4 = qr/(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2}))/ixsm;
  my $re_ipv4_nginx_xff = qr/(?:$re_ipv4)(?: \,? \s+ $re_ipv4)*/ixsm;
  my $re_static_simple = qr/^\/[^?]*?\.(?:gif|png|jpg|jpeg|js|css|swf)$/ixsm; # no parameter
  my $re_static_complex = qr/^\/[^?]*?\.(?:gif|png|jpg|jpeg|js|css|swf)[?]/ixsm; # has parameter
  my $re_static = qr/$re_static_simple|$re_static_complex/ixsm;
  my $re_domain = qr/(?:[0-9A-Za-z](?:(?:[-A-Za-z0-9]){0,61}[A-Za-z0-9])?(?:\.[A-Za-z](?:(?:[-A-Za-z0-9]){0,61}[A-Za-z0-9])?)*)/ixsm;
  my $re_uri = qr/[^ ]+/ixsm;
  my $re_qstring = qr/(?:[^ ]+|-)/ixsm;
  my $re_msec = qr/\d{10}\.\d{3}/ixsm;
  my $re_status = qr/\d{3}|-/ixsm;
  my $re_cost = qr/(?:\d+\.\d+|-|\d+)/ixsm;
  my $re_static_err = qr/(?:5\d{2}|404)/ixsm;
  my $re_dynamic_err = qr/(?:5\d{2})/ixsm;
  
  
  sub new {
      my $class = shift;
      my $opts  = ref($_[0]) ? shift : {@_};
  
      # Allow user to customize, but provide sensible defaults
      my $self;
      $self->{logfile}    = '/dev/shm/nginx_metrics/metrics.log';
      $self->{interval}   = 60;
      $self->{prefer}     = 'ip';
      $self->{cluster}    = 'none';
      $self->{threshold}  = 90;
      $self->{errormsg}   = '';
      $self->{virtual}    = 'no';
      $self->{percentile} = 0.05;
      $self->{myself}     = Net::Address::IP::Local->public_ipv4;
      
  
      foreach my $opt (keys %{$opts}) {
          $self->{$opt} = $opts->{$opt};
      }
  
      # Test logfile existance
      unless (-e $self->{logfile}) {
          # Of course, we can't work without a logfile, but we'd like to give user as much freedom as possible,
          # so we just warn them and pervail.
          carp $self->{logfile} . ' does not exist.';
      }
  
      my @tags;
      if ($self->{prefer} eq 'hostname') {
          push @tags, 'host=' . hostname;
      } else {
          push @tags, 'host=' . $self->{myself};
      }
  
      $self->{tag_partial} = join(' ', @tags);
  
      return bless $self, $class;
  }
  
  sub do_parse {
      my $self = shift;
  
      my $timefrm = $self->interval;
      my $logfile = $self->logfile;
  
      my $stop = time() - $timefrm;
  
      my ($rc_dynamic, $rc_static);
  
      my $bw = File::ReadBackwards->new($logfile);
      if ($bw) {
          BACKWARD_READ:
          while (defined (my $line = $bw->readline)) {
              chomp $line;
  
              if ($line =~ /^($re_msec) \s+ ($re_domain|$re_ipv4) \s+ ($re_uri) \s+ ($re_status) \s+ ($re_ipv4:\d+|-) \s+ $re_ipv4_nginx_xff \s+ ($re_cost|-)$/ixsm) {
                  my ($msec, $domain, $uri, $status, $upstream, $cost) = ($1, $2, $3, $4, $5, $6);
  
                  if ($msec < $stop) {
                      last BACKWARD_READ;
                  } else {
                      # remove port   
                      $upstream =~ s/:\d+//g;
  
                      if ($domain =~ $re_ipv4) {
                          # It's weird that the domain part is an IP address, so we don't process them now
                          next BACKWARD_READ;
                      } else {
                          if ($uri eq '-') {
                              # sometimes uri can be empty, 
                              # 1302221251.460 aig.sdo.com - 400 - 10.129.1.230 -
                              next BACKWARD_READ;
                          }
  
                          if ($uri !~ $re_static) {
                              if ($upstream eq '-') {
                                  # If upstream_addr is empty, Nginx must process the dynamic request itself. for example:
                                  # 1302239999.636 www.sdo.com /center/index.asp 301 - 180.119.181.98, 127.0.1.1, 10.129.1.230 -
                                  # 1302239916.110 www.sdo.com /center/index.asp 301 - 58.17.160.47, 127.0.1.1, 10.129.1.230 -
  
                                  # No matter who process the request, it's a dynamic one indeed, thus we must process them
                                  # The biggest problem is that if nginx process the request itself, upstream_response_time is zero.
                                  # we can't help but write a 3ms cost, this won't give too much confidence to nginx.
                                  $cost = 0.003;
  
                                  # upstream address is nginx itslef now, so we use hostname/ip address, depend on user choice
                                  $upstream = $self->myself;
                              }
  
                              if ($cost eq '-') {
                                  # It's impossible for a dynamic request with non-empty upstream_addr has empty cost, skip them
                                  next BACKWARD_READ;
                              }
  
                              if ($status =~ /($re_dynamic_err)/) {
                                  $rc_dynamic->{$domain}->{$upstream}->{error}->{$1}++;
                              }
  
                              # platency is an arrayref which holds all request's latency
                              $rc_dynamic->{$domain}->{$upstream}->{latency} += $cost;
                              push @{$rc_dynamic->{$domain}->{$upstream}->{platency}}, $cost;
  
                              $rc_dynamic->{$domain}->{$upstream}->{throughput}++;
                          }
                          else {
                              # Nginx cached the response, so the upstream is -
                              if ($upstream eq '-') {
                                  # For static content, the latency value is not that useful. We give a 1ms here
                                  $cost = 0.001;
  
                                  $upstream = $self->myself;
                              }
  
                              if ($cost eq '-') {
                                  # It's impossible for a dynamic request with non-empty upstream_addr has empty cost, skip them
                                  next BACKWARD_READ;
                              }
  
                              # Currently, 404 is an error
                              if ($status =~ /($re_static_err)/) {
                                  $rc_static->{$domain}->{$upstream}->{error}->{$1}++;
                              }
  
                              $rc_static->{$domain}->{$upstream}->{latency} += $cost;
                              push @{$rc_static->{$domain}->{$upstream}->{platency}}, $cost;
  
                              $rc_static->{$domain}->{$upstream}->{throughput}++;
                          }
                      }
                  }
              }
          }
      } else {
          $self->errormsg("open $logfile failed");
          return undef;
      }
  
      return ($rc_dynamic, $rc_static);
  }
  
  sub show_results {
      my $self = shift;
  
      # If logfile in tmpfs, we won't do any harm.
      # If logfile is not in tmpfs, tmpfs can't reach threshold.(flush_tmpfs always return 0)
      if ($self->flush_tmpfs) {
          system '>' . $self->logfile;
  
          # so the logfile has beed flushed, we just report to outer function
          $self->errormsg('tmpfs flushed');
          return 0;
      }
  
      my $results;
      my ($rc_dynamic, $rc_static) = $self->do_parse;
  
      if (defined $rc_dynamic) {
          foreach my $domain (keys %{$rc_dynamic}) {
              foreach my $upstream (keys %{$rc_dynamic->{$domain}}) {
                  my $errors = 0;
  
                  # If no error found, set number of errors to zero
                  unless (exists $rc_dynamic->{$domain}->{$upstream}->{error}) {
                      $errors = 0;
                  }
  
                  METRIC_HANDLING:
                  foreach my $item (keys %{$rc_dynamic->{$domain}->{$upstream}}) {
                      # process latency here
                      if ($item eq 'latency') {
                          $results .= sprintf("put nginx.latency %d %d domain=%s upstream=%s virtualized=%s cluster=%s %s type=dynamic\n",
                              time(),
                              ($rc_dynamic->{$domain}->{$upstream}->{latency}/$rc_dynamic->{$domain}->{$upstream}->{throughput})*1000,
                              $domain,
                              $upstream,
                              $self->virtual,
                              $self->cluster,
                              $self->tag_partial,
                          );
                      } elsif ($item eq 'throughput') {
                          $results .= sprintf("put nginx.throughput %d %d domain=%s upstream=%s virtualized=%s cluster=%s %s type=dynamic\n",
                              time(),
                              $rc_dynamic->{$domain}->{$upstream}->{throughput},
                              $domain,
                              $upstream,
                              $self->virtual,
                              $self->cluster,
                              $self->tag_partial,
                          );
                      } elsif ($item eq 'error') {
                          foreach my $err (keys %{$rc_dynamic->{$domain}->{$upstream}->{error}}) {
                              $results .= sprintf("put nginx.error %d %d domain=%s upstream=%s virtualized=%s cluster=%s code=%s %s type=dynamic\n",
                                  time(),
                                  $rc_dynamic->{$domain}->{$upstream}->{error}->{$err},
                                  $domain,
                                  $upstream,
                                  $self->virtual,
                                  $self->cluster,
                                  $err,
                                  $self->tag_partial,
                              );
                          }
                      } elsif ($item eq 'platency') {
                          my $platency = $self->compute_platency($rc_dynamic->{$domain}->{$upstream}->{platency}, $rc_dynamic->{$domain}->{$upstream}->{throughput});
  
                          next METRIC_HANDLING unless $platency;
  
                          $results .= sprintf("put nginx.platency %d %d domain=%s upstream=%s virtualized=%s cluster=%s %s type=dynamic\n",
                              time(),
                              $platency,
                              $domain,
                              $upstream,
                              $self->virtual,
                              $self->cluster,
                              $self->tag_partial,
                          );
                      } else {
                          # impossible
                          1;
                      }
                  }
              }
          }
      }
          
      if (defined $rc_static) {
          foreach my $domain (keys %{$rc_static}) {
              foreach my $upstream (keys %{$rc_static->{$domain}}) {
                  my $errors = 0;
  
                  # If no error found, set number of errors to zero
                  unless (exists $rc_static->{$domain}->{$upstream}->{error}) {
                      $errors = 0;
                  }
  
                  foreach my $item (keys %{$rc_static->{$domain}->{$upstream}}) {
                      # process latency here
                      if ($item eq 'latency') {
                          $results .= sprintf("put nginx.latency %d %d domain=%s upstream=%s virtualized=%s cluster=%s %s type=static\n",
                              time(),
                              ($rc_static->{$domain}->{$upstream}->{latency}/$rc_static->{$domain}->{$upstream}->{throughput})*1000,
                              $domain,
                              $upstream,
                              $self->virtual,
                              $self->cluster,
                              $self->tag_partial,
                          );
                      } elsif ($item eq 'throughput') {
                          $results .= sprintf("put nginx.throughput %d %d domain=%s upstream=%s virtualized=%s cluster=%s %s type=static\n",
                              time(),
                              $rc_static->{$domain}->{$upstream}->{throughput},
                              $domain,
                              $upstream,
                              $self->virtual,
                              $self->cluster,
                              $self->tag_partial,
                          );
                      } elsif ($item eq 'error') {
                          foreach my $err (keys %{$rc_static->{$domain}->{$upstream}->{error}}) {
                              $results .= sprintf("put nginx.error %d %d domain=%s upstream=%s virtualized=%s cluster=%s code=%s %s type=static\n",
                                  time(),
                                  $rc_static->{$domain}->{$upstream}->{error}->{$err},
                                  $domain,
                                  $upstream,
                                  $self->virtual,
                                  $self->cluster,
                                  $err,
                                  $self->tag_partial,
                              );
                          }
                      } else {
                          # impossible
                          1;
                      }
                  }
              }
          }
      }
  
      if ($results eq '') {
          $self->errormsg('empty parse');
      }
  
      return $results;
  }
  
  
  sub flush_tmpfs {
      my $self = shift;
      my $lxs = Sys::Statistics::Linux::DiskUsage->new;
      my $stat = $lxs->get;
      my $threshold = $self->threshold;
  
      if (exists $stat->{tmpfs}) {
          my ($free, $total) = ($stat->{tmpfs}->{free}, $stat->{tmpfs}->{total});
  
          # å¤§å°ä¸º0çš„tmpfså¯èƒ½å­˜åœ¨ä¹ˆï¼Ÿ
          if ($total >= 0) {
              my $used = sprintf("%.2f", ($total - $free)/$total*100);
              # ä½ŽäºŽè¿™ç‚¹æ—¶å¼€å§‹flush 
              if ($used >= $threshold) {
                  return 1;
              }
          }
      }
  
      return 0;
  }
  
  # This function computes the percentile latency(platency). The goal is to exclude anomalies so as to give
  # a better average. Otherwise, the arithmetic average is inaccurate when very high or low latency requests present.
  # The actual implementation will subject to change where the goal is determined.
  sub compute_platency {
      my $self = shift;
      my ($platency, $throughput) = @_;
  
      my $result;
  
      # It's a trivial case when throughput equals one
      if ($throughput == 1) {
          $result = shift @{$platency};
          return $result;
      }
  
      # The percentile is implemented as throw away 1/2 requests of total requests
      # from the beginning and the end. So the current implementation is simlar to the scoring rules of diving.
      my $throw_reqs = int(($self->percentile / 2) * $throughput);
  
      # Of course, we should sort
      my @sorted_platency = sort { $a <=> $b } @{$platency};
  
      # throw away X requests from the beginning, they are the ones with lower latency
      my @spliced_sorted_platency = splice(@sorted_platency, $throw_reqs);
  
      # throw away X requests from the end, they are the ones with higher latency
      @spliced_sorted_platency = splice(@spliced_sorted_platency, 0, $#spliced_sorted_platency-$throw_reqs);
  
      # now we can compute percentile latency
      my ($total_latency, $total_reqs);
      foreach my $latency (@spliced_sorted_platency) {
          $total_latency += $latency;
          $total_reqs++;
      }
  
      if ($total_latency && $total_reqs) {
          $result = $total_latency / $total_reqs * 1000;
      } else {
          # debug empty total_latency or total_reqs here
          1;
  
          # print STDERR sprintf("throughput: %d total_latency: %d total_reqs: %d throw_reqs: %d left_reqs: %d\n",
          #         $throughput, $total_latency, $total_reqs, $throw_reqs, $#spliced_sorted_platency - $throw_reqs);
      }
  
      return $result;
  }
  
  1;
OCOLLECTOR_NGINX_SLA

$fatpacked{"Ocollector/ServiceMonitor/Memcached.pm"} = <<'OCOLLECTOR_SERVICEMONITOR_MEMCACHED';
  package Ocollector::ServiceMonitor::Memcached;
  
  use strict;
  use warnings;
  use Date::Parse;
  use Data::Dumper;
  
  my @accessors = qw( metric logdir logfile interval pattern lastpos errormsg);
  
  use base qw(Class::Accessor Ocollector::Common);
  Ocollector::ServiceMonitor::Memcached->mk_accessors(@accessors);
  
  our $VERSION = '1.0';
  
  sub new {
      my $class = shift;
      my $opts  = ref($_[0]) ? shift : {@_};
  
      my $self;
      foreach my $opt (keys %{$opts}) {
          $self->{$opt} = $opts->{$opt};
      }
  
      $self->{metric}    = 'servicemonitor.memcached';
      $self->{lastpos}   = '';
      $self->{logfile}   = '';
      $self->{errormsg}  = '';
  
      return bless $self, $class;
  }
  
  sub do_parse {
      my ($self) = @_;
  
      $self->logfile($self->determine_latest($self->logdir, $self->pattern));
  
      my $rc;
  
      my $logfile = $self->logfile;
      my $bw = File::ReadBackwards->new($logfile);
  
      if ($bw) {
          my $re_ipv4 = $Ocollector::Common::re_ipv4;
          my $stop = time - $self->interval;
  
          BACKWARD_READ:
          while (defined (my $line = $bw->readline)) {
              chomp $line;
  
              # å¦‚æžœå’Œæœ€è¿‘ä¸€æ¬¡è¯»å–çš„md5ä¸€æ ·ï¼Œè¯´æ˜Žæ ¹æœ¬æ²¡å˜è¿‡ã€‚  
              # é‚£å°±æ²¡å¿…è¦åšä»»ä½•äº‹æƒ…ã€‚
              last BACKWARD_READ if $self->give_md5($line) eq $self->lastpos;
  
              # 1. é˜²æ­¢å¼‚å¸¸æ—¥å¿—
              # 2. ä¿è¯æ—¶é—´èƒ½è¢«æ­£å¸¸parse
              next BACKWARD_READ unless $line =~ /^time:(\d{4}-\d{2}-\d{2} \s+ \d{2}:\d{2}:\d{2}) \s+/ixsm;
  
              my $sec = str2time($1);
  
              if ($sec >= $stop) {
                  if ($line !~ /($re_ipv4) : (\d+) .*? cost_time:(\d+) .*? [:=]+(\w+)/ixsm) {
                      next BACKWARD_READ;
                  } else {
                      my ($ip, $port, $cost, $result) = ($1, $2, $3, $4);
  
                      if ($result eq 'SUCCESS') {
                          $rc->{$ip}->{$port}->{succeed_cost} += $cost;
                          $rc->{$ip}->{$port}->{succeed}++;
                      } else {
                          $rc->{$ip}->{$port}->{failed_cost} += $cost;
                          $rc->{$ip}->{$port}->{failed}++;
                      }
  
                      $rc->{$ip}->{$port}->{total}++;
  
  
                      # è®°å½•æœ€è¿‘ä¸€æ¬¡çš„æ•°æ®
                      $self->lastpos($self->give_md5($line));
                  }
              }
              else {
                  # åœæ­¢parseï¼Œæ—¶é—´åˆ°
                  last BACKWARD_READ;
              }
          }
      } else {
          $self->errormsg("open logfile: $logfile failed");
      }
  
      return $rc;
  }
  
  sub format_result {
      my ($self, $rc) = @_;
  
      my $results;
      if ($rc) {
          foreach my $ip (keys %{$rc}) {
              foreach my $port (keys %{$rc->{$ip}}) {
                  foreach my $item (keys %{$rc->{$ip}->{$port}}) {
                      # å› ä¸ºsucceedå’Œfailedéƒ½å¯èƒ½ä¸å­˜åœ¨ï¼Œæ‰€ä»¥ç”¨total
                      next unless $item eq 'total';
  
                      # ä¿è¯succeedå’Œfailedæœ‰å€¼
                      unless (exists $rc->{$ip}->{$port}->{succeed}) {
                          $rc->{$ip}->{$port}->{succeed} = 0;
                          $rc->{$ip}->{$port}->{succeed_cost} = 1;
                      }
  
                      unless (exists $rc->{$ip}->{$port}->{failed}) {
                          $rc->{$ip}->{$port}->{failed} = 0;
                          $rc->{$ip}->{$port}->{failed_cost} = 1;
                      }
  
                      my $total = $rc->{$ip}->{$port}->{$item};
  
                      # è®¡ç®—: error rate
                      $results .= sprintf("put %s.error %d %.2f host=%s port=%s\n",
                              $self->metric, time, $rc->{$ip}->{$port}->{failed}/$total*100, $ip, $port);
  
                      # è®¡ç®—: throughput and latency
                      for (qw/succeed failed/) {
                          $results .= sprintf("put %s.throughput %d %d host=%s port=%s type=%s\n",
                                  $self->metric, time, $rc->{$ip}->{$port}->{$_}, $ip, $port, $_);
  
                          if ($rc->{$ip}->{$port}->{$_} == 0) {
                              $results .= sprintf("put %s.latency %d 0 host=%s port=%s type=%s\n",
                                      $self->metric, time, $ip, $port, $_);
                          } else {
                              $results .= sprintf("put %s.latency %d %d host=%s port=%s type=%s\n",
                                      $self->metric, time, $rc->{$ip}->{$port}->{$_ . '_cost'}/$rc->{$ip}->{$port}->{$_}, $ip, $port, $_);
                          }
                      }
                  }
              }
          }
      } else {
          $self->errormsg($self->metric . " empty parse");
      }
  
      return $results;
  }
  
  sub show_results {
      my $self = shift;
      
      my $rc = $self->do_parse;
  
      if ($rc) {
          return $self->format_result($rc);
      }
  
      return;
  }
  
  1;
OCOLLECTOR_SERVICEMONITOR_MEMCACHED

$fatpacked{"Ocollector/Tcpbasic/Linux.pm"} = <<'OCOLLECTOR_TCPBASIC_LINUX';
  
OCOLLECTOR_TCPBASIC_LINUX

$fatpacked{"Ocollector/Tcpbasic/Windows.pm"} = <<'OCOLLECTOR_TCPBASIC_WINDOWS';
  package Ocollector::Tcpbasic::Windows;
  
  use strict;
  use warnings;
  use Net::Address::IP::Local;
  
  my @accessors = qw( tag_partial interval errormsg);
  
  use base qw(Class::Accessor Ocollector::Common);
  Ocollector::Tcpbasic::Windows->mk_accessors(@accessors);
  
  
  our $VERSION = '1.0';
  
  sub new {
      my $class = shift;
      my $opts  = ref($_[0]) ? shift : {@_};
  
      my $self;
      foreach my $opt (keys %{$opts}) {
          $self->{$opt} = $opts->{$opt};
      }
  
      $self->{errormsg}  = '';
  
      my @tags;
      push @tags, 'host=' . Net::Address::IP::Local->public_ipv4;
  
      if (exists $self->{type}) {
          push @tags, 'type=' . $self->{type};
      } else {
          push @tags, 'type=rachel';
      }
  
      $self->{tag_partial} = join(' ', @tags);
  
  
      return bless $self, $class;
  }
  
  sub show_results {
      my $self = shift;
  
      my $output = `netstat -s`;
      my @lines = split /\n/, $output;
  
      my $results;
  
      # Active Opens                        = 7268
      # Passive Opens                       = 940
      # Failed Connection Attempts          = 184
      # Reset Connections                   = 470
      # Current Connections                 = 22
      # Segments Received                   = 397427
      # Segments Sent                       = 341375
      # Segments Retransmitted              = 1168
  
      foreach my $line (@lines) {
          next unless $line =~ /(Active\sOpens|Passive\sOpens|Failed\sConnection\sAttempts|Reset\sConnections|Current\sConnections|Segments\sReceived|Segments\sSent|Segments\sRetransmitted) \s+ = \s+ (\d+)/ixsm;
  
          my ($counter, $value) = ($1, $2);
          $counter =~ s/\s/_/g;
          $results .= sprintf("put windows.netstat.tcp %d %.0f counter=%s %s\n", time, $value, $counter, $self->tag_partial);
      }
  
      return $results;
  }
OCOLLECTOR_TCPBASIC_WINDOWS

$fatpacked{"Sys/Statistics/Linux.pm"} = <<'SYS_STATISTICS_LINUX';
  =head1 NAME
  
  Sys::Statistics::Linux - Front-end module to collect system statistics
  
  =head1 SYNOPSIS
  
      use Sys::Statistics::Linux;
  
      my $lxs = Sys::Statistics::Linux->new(
          sysinfo   => 1,
          cpustats  => 1,
          procstats => 1,
          memstats  => 1,
          pgswstats => 1,
          netstats  => 1,
          sockstats => 1,
          diskstats => 1,
          diskusage => 1,
          loadavg   => 1,
          filestats => 1,
          processes => 1,
      );
  
      sleep 1;
      my $stat = $lxs->get;
  
  =head1 DESCRIPTION
  
  Sys::Statistics::Linux is a front-end module and gather different linux system information
  like processor workload, memory usage, network and disk statistics and a lot more. Refer the
  documentation of the distribution modules to get more information about all possible statistics.
  
  =head1 MOTIVATION
  
  My motivation is very simple... every linux administrator knows the well-known tool sar of sysstat.
  It helps me a lot of time to search for system bottlenecks and to solve problems, but it's hard to
  parse the output if you want to store the statistics into a database. So I thought to develope
  Sys::Statistics::Linux. It's not a replacement but it should make it simpler to you to write your
  own system monitor.
  
  If Sys::Statistics::Linux doesn't provide statistics that are strongly needed then let me know it.
  
  =head1 TECHNICAL NOTE
  
  This distribution collects statistics by the virtual F</proc> filesystem (procfs) and is
  developed on the default vanilla kernel. It is tested on x86 hardware with the distributions
  RHEL, Fedora, Debian, Ubuntu, Asianux, Slackware, Mandriva and openSuSE (SLES on zSeries as
  well but a long time ago) on kernel versions 2.4 and/or 2.6. It's possible that it doesn't
  run on all linux distributions if some procfs features are deactivated or too much modified.
  As example the linux kernel 2.4 can compiled with the option C<CONFIG_BLK_STATS> what turn
  on or off block statistics for devices.
  
  Don't give up if some of the modules doesn't run on your hardware! Tell me what's wrong
  and I will try to solve it! You just have to make the first move and to send me a mail. :-)
  
  =head1 VIRTUAL MACHINES
  
  Note that if you try to install or run C<Sys::Statistics::Linux> under virtual machines
  on guest systems that some statistics are not available, such as C<SockStats>, C<PgSwStats>
  and C<DiskStats>. The reason is that not all /proc data are passed to the guests.
  
  If the installation fails then try to force the installation with
  
      cpan> force install Sys::Statistics::Linux
  
  and notice which tests fails, because this statistics maybe not available on the virtual machine - sorry.
  
  =head1 DELTAS
  
  The statistics for C<CpuStats>, C<ProcStats>, C<PgSwStats>, C<NetStats>, C<DiskStats> and C<Processes>
  are deltas, for this reason it's necessary to initialize the statistics before the data can be
  prepared by C<get()>. These statistics can be initialized with the methods C<new()>, C<set()> and
  C<init()>. For any option that is set to 1, the statistics will be initialized by the call of
  C<new()> or C<set()>. The call of init() re-initialize all statistics that are set to 1 or 2.
  By the call of C<get()> the initial statistics will be updated automatically. Please refer the
  section L</METHODS> to get more information about the usage of C<new()>, C<set()>, C<init()>
  and C<get()>.
  
  Another exigence is to sleep for a while - at least for one second - before the call of C<get()>
  if you want to get useful statistics. The statistics for C<SysInfo>, C<MemStats>, C<SockStats>,
  C<DiskUsage>, C<LoadAVG> and C<FileStats> are no deltas. If you need only one of these information
  you don't need to sleep before the call of C<get()>.
  
  The method C<get()> prepares all requested statistics and returns the statistics as a
  L<Sys::Statistics::Linux::Compilation> object. The inital statistics will be updated.
  
  =head1 MANUAL PROC(5)
  
  The Linux Programmer's Manual
  
      http://www.kernel.org/doc/man-pages/online/pages/man5/proc.5.html
  
  If you have questions or don't understand the sense of some statistics then take a look
  into this awesome documentation.
  
  =head1 OPTIONS
  
  All options are identical with the package names of the distribution in lowercase. To activate
  the gathering of statistics you have to set the options by the call of C<new()> or C<set()>.
  In addition you can deactivate statistics with C<set()>.
  
  The options must be set with one of the following values:
  
      0 - deactivate statistics
      1 - activate and init statistics
      2 - activate statistics but don't init
  
  In addition it's possible to pass a hash reference with options.
  
      my $lxs = Sys::Statistics::Linux->new(
          processes => {
              init => 1,
              pids => [ 1, 2, 3 ]
          },
          netstats => {
              init => 1,
              initfile => $file,
          },
      );
  
  Option C<initfile> is useful if you want to store initial statistics on the filesystem.
  
      my $lxs = Sys::Statistics::Linux->new(
          cpustats => {
              init     => 1,
              initfile => '/tmp/cpustats.yml',
          },
          diskstats => {
              init     => 1,
              initfile => '/tmp/diskstats.yml',
          },
          netstats => {
              init     => 1,
              initfile => '/tmp/netstats.yml',
          },
          pgswstats => {
              init     => 1,
              initfile => '/tmp/pgswstats.yml',
          },
          procstats => {
              init     => 1,
              initfile => '/tmp/procstats.yml',
          },
      );
  
  Example:
  
      #!/usr/bin/perl
      use strict;
      use warnings;
      use Sys::Statistics::Linux;
  
      my $lxs = Sys::Statistics::Linux->new(
          pgswstats => {
              init => 1,
              initfile => '/tmp/pgswstats.yml'
          }
      );
  
      $lxs->get(); # without to sleep
  
  The initial statistics are stored to the temporary file:
  
      #> cat /tmp/pgswstats.yml
      --- 
      pgfault: 397040955
      pgmajfault: 4611
      pgpgin: 21531693
      pgpgout: 49511043
      pswpin: 8
      pswpout: 272
      time: 1236783534.9328
  
  Every time you call the script the initial statistics are loaded/stored from/to the file.
  This could be helpful if you doesn't run it as daemon and if you want to calculate the
  average load of your system since the last call. Do you understand? I hope so :)
  
  To get more information about the statistics refer the different modules of the distribution.
  
      sysinfo     -  Collect system information              with Sys::Statistics::Linux::SysInfo.
      cpustats    -  Collect cpu statistics                  with Sys::Statistics::Linux::CpuStats.
      procstats   -  Collect process statistics              with Sys::Statistics::Linux::ProcStats.
      memstats    -  Collect memory statistics               with Sys::Statistics::Linux::MemStats.
      pgswstats   -  Collect paging and swapping statistics  with Sys::Statistics::Linux::PgSwStats.
      netstats    -  Collect net statistics                  with Sys::Statistics::Linux::NetStats.
      sockstats   -  Collect socket statistics               with Sys::Statistics::Linux::SockStats.
      diskstats   -  Collect disk statistics                 with Sys::Statistics::Linux::DiskStats.
      diskusage   -  Collect the disk usage                  with Sys::Statistics::Linux::DiskUsage.
      loadavg     -  Collect the load average                with Sys::Statistics::Linux::LoadAVG.
      filestats   -  Collect inode statistics                with Sys::Statistics::Linux::FileStats.
      processes   -  Collect process statistics              with Sys::Statistics::Linux::Processes.
  
  =head1 METHODS
  
  =head2 new()
  
  Call C<new()> to create a new Sys::Statistics::Linux object. You can call C<new()> with options.
  This options would be passed to the method C<set()>.
  
  Without options
  
      my $lxs = Sys::Statistics::Linux->new();
  
  Or with options
  
      my $lxs = Sys::Statistics::Linux->new( cpustats => 1 );
  
  Would do nothing
  
      my $lxs = Sys::Statistics::Linux->new( cpustats => 0 );
  
  It's possible to call C<new()> with a hash reference of options.
  
      my %options = (
          cpustats => 1,
          memstats => 1
      );
  
      my $lxs = Sys::Statistics::Linux->new(\%options);
  
  =head2 set()
  
  Call C<set()> to activate or deactivate options.
  
  The following example would call C<new()> and initialize C<Sys::Statistics::Linux::CpuStats>
  and delete the object of C<Sys::Statistics::Linux::SysInfo>.
  
      $lxs->set(
          processes =>  0, # deactivate this statistic
          pgswstats =>  1, # activate the statistic and calls new() and init() if necessary
          netstats  =>  2, # activate the statistic and call new() if necessary but not init()
      );
  
  It's possible to call C<set()> with a hash reference of options.
  
      my %options = (
          cpustats => 2,
          memstats => 2
      );
  
      $lxs->set(\%options);
  
  =head2 get()
  
  Call C<get()> to get the collected statistics. C<get()> returns a L<Sys::Statistics::Linux::Compilation>
  object.
  
      my $lxs  = Sys::Statistics::Linux->new(\%options);
      sleep(1);
      my $stat = $lxs->get();
  
  Or you can pass the time to sleep with the call of C<get()>.
  
      my $stat = $lxs->get($time_to_sleep);
  
  Now the statistcs are available with
  
      $stat->cpustats
  
      # or
  
      $stat->{cpustats}
  
  Take a look to the documentation of L<Sys::Statistics::Linux::Compilation> for more information.
  
  =head2 init()
  
  The call of C<init()> initiate all activated statistics that are necessary for deltas. That could
  be helpful if your script runs in a endless loop with a high sleep interval. Don't forget that if
  you call C<get()> that the statistics are deltas since the last time they were initiated.
  
  The following example would calculate average statistics for 30 minutes:
  
      # initiate cpustats
      my $lxs = Sys::Statistics::Linux->new( cpustats => 1 );
  
      while ( 1 ) {
          sleep(1800);
          my $stat = $lxs->get;
      }
  
  If you just want a current snapshot of the system each 30 minutes and not the average
  then the following example would be better for you:
  
      # do not initiate cpustats
      my $lxs = Sys::Statistics::Linux->new( cpustats => 2 );
  
      while ( 1 ) {
          $lxs->init;              # init the statistics
          my $stat = $lxs->get(1); # get the statistics
          sleep(1800);             # sleep until the next run
      }
  
  If you want to write a simple command line utility that prints the current workload
  to the screen then you can use something like this:
  
      my @order = qw(user system iowait idle nice irq softirq total);
      printf "%-20s%8s%8s%8s%8s%8s%8s%8s%8s\n", 'time', @order;
  
      my $lxs = Sys::Statistics::Linux->new( cpustats => 1 );
  
      while ( 1 ){
          my $cpu  = $lxs->get(1)->cpustats;
          my $time = $lxs->gettime;
          printf "%-20s%8s%8s%8s%8s%8s%8s%8s%8s\n",
              $time, @{$cpu->{cpu}}{@order};
      }
  
  =head2 settime()
  
  Call C<settime()> to define a POSIX formatted time stamp, generated with localtime().
  
      $lxs->settime('%Y/%m/%d %H:%M:%S');
  
  To get more information about the formats take a look at C<strftime()> of POSIX.pm
  or the manpage C<strftime(3)>.
  
  =head2 gettime()
  
  C<gettime()> returns a POSIX formatted time stamp, @foo in list and $bar in scalar context.
  If the time format isn't set then the default format "%Y-%m-%d %H:%M:%S" will be set
  automatically. You can also set a time format with C<gettime()>.
  
      my $date_time = $lxs->gettime;
  
  Or
  
      my ($date, $time) = $lxs->gettime();
  
  Or
  
      my ($date, $time) = $lxs->gettime('%Y/%m/%d %H:%M:%S');
  
  =head1 EXAMPLES
  
  A very simple perl script could looks like this:
  
      use strict;
      use warnings;
      use Sys::Statistics::Linux;
  
      my $lxs = Sys::Statistics::Linux->new( cpustats => 1 );
      sleep(1);
      my $stat = $lxs->get;
      my $cpu  = $stat->cpustats->{cpu};
  
      print "Statistics for CpuStats (all)\n";
      print "  user      $cpu->{user}\n";
      print "  nice      $cpu->{nice}\n";
      print "  system    $cpu->{system}\n";
      print "  idle      $cpu->{idle}\n";
      print "  ioWait    $cpu->{iowait}\n";
      print "  total     $cpu->{total}\n";
  
  Set and get a time stamp:
  
      use strict;
      use warnings;
      use Sys::Statistics::Linux;
  
      my $lxs = Sys::Statistics::Linux->new();
      $lxs->settime('%Y/%m/%d %H:%M:%S');
      print $lxs->gettime, "\n";
  
  If you want to know how the data structure looks like you can use C<Data::Dumper> to check it:
  
      use strict;
      use warnings;
      use Sys::Statistics::Linux;
      use Data::Dumper;
  
      my $lxs = Sys::Statistics::Linux->new( cpustats => 1 );
      sleep(1);
      my $stat = $lxs->get;
  
      print Dumper($stat);
  
  How to get the top 5 processes with the highest cpu workload:
  
      use strict;
      use warnings;
      use Sys::Statistics::Linux;
  
      my $lxs = Sys::Statistics::Linux->new( processes => 1 );
      sleep(1);
      my $stat = $lxs->get;
      my @top5 = $stat->pstop( ttime => 5 );
  
  =head1 BACKWARD COMPATIBILITY
  
  The old options and keys - CpuStats, NetStats, etc - are still available but deprecated!
  It's not possible to access the statistics via L<Sys::Statistics::Linux::Compilation> and it's
  not possible to call C<search()> and C<psfind()> if you use the old options.
  
  You should use the new options and access the statistics over the accessors
  
      $stats->cpustats
  
  or directly with
  
      $stats->{cpustats}
  
  =head1 PREREQUISITES
  
      Carp
      POSIX
      Test::More
      Time::HiRes
      UNIVERSAL
  
  =head1 EXPORTS
  
  No exports.
  
  =head1 TODOS
  
     * Are there any wishs from your side? Send me a mail!
  
  =head1 REPORTING BUGS
  
  Please report all bugs to <jschulz.cpan(at)bloonix.de>.
  
  =head1 AUTHOR
  
  Jonny Schulz <jschulz.cpan(at)bloonix.de>.
  
  =head1 COPYRIGHT
  
  Copyright (C) 2006-2008 by Jonny Schulz. All rights reserved.
  
  This program is free software; you can redistribute it and/or modify it under the same terms as Perl itself.
  
  =cut
  
  package Sys::Statistics::Linux;
  our $VERSION = '0.59';
  
  use strict;
  use warnings;
  use Carp qw(croak);
  use POSIX qw(strftime);
  use UNIVERSAL;
  use Sys::Statistics::Linux::Compilation;
  
  sub new {
      my $class = shift;
      my $self  = bless { obj => { } }, $class; 
  
      my @options = qw(
          SysInfo   CpuStats  ProcStats
          MemStats  PgSwStats NetStats
          SockStats DiskStats DiskUsage
          LoadAVG   FileStats Processes
      );
  
      foreach my $opt (@options) {
          # backward compatibility
          $self->{opts}->{$opt} = 0;
          $self->{maps}->{$opt} = $opt;
          # new style
          my $lcopt = lc($opt);
          $self->{opts}->{$lcopt} = 0;
          $self->{maps}->{$lcopt} = $opt;
      }
  
      $self->set(@_) if @_;
      return $self;
  }
  
  sub set {
      my $self  = shift;
      my $class = ref $self;
      my $args  = ref($_[0]) eq 'HASH' ? shift : {@_};
      my $opts  = $self->{opts};
      my $obj   = $self->{obj};
      my $maps  = $self->{maps};
      my $pids  = ();
  
      foreach my $opt (keys %$args) {
          if (!exists $opts->{$opt}) {
              croak "$class: invalid option '$opt'";
          }
  
          if (ref($args->{$opt})) {
              $opts->{$opt} = delete $args->{$opt}->{init} || 1;
          } elsif ($args->{$opt} !~ qr/^[012]\z/) {
              croak "$class: invalid value for '$opt'";
          } else {
              $opts->{$opt} = $args->{$opt};
          }
  
          if ($opts->{$opt}) {
              my $package = $class.'::'.$maps->{$opt};
  
              # require module - require know which modules are loaded
              # and doesn't load a module twice.
              my $require = $package;
              $require =~ s/::/\//g;
              $require .= '.pm';
              require $require;
  
              if (!$obj->{$opt}) {
                  if (ref($args->{$opt})) {
                      $obj->{$opt} = $package->new(%{$args->{$opt}});
                  } else {
                      $obj->{$opt} = $package->new();
                  }
              }
  
              # get initial statistics if the function init() exists
              # and the option is set to 1
              if ($opts->{$opt} == 1 && UNIVERSAL::can($package, 'init')) {
                  $obj->{$opt}->init();
              }
  
          } elsif (exists $obj->{$opt}) {
              delete $obj->{$opt};
          }
      }
  }
  
  sub init {
      my $self  = shift;
      my $class = ref $self;
      my $maps  = $self->{maps};
  
      foreach my $opt (keys %{$self->{opts}}) {
          if ($self->{opts}->{$opt} > 0 && UNIVERSAL::can(ref($self->{obj}->{$opt}), 'init')) {
              $self->{obj}->{$opt}->init();
          }
      }
  }
  
  sub get {
      my ($self, $time) = @_;
      sleep $time if $time;
      my %stat = ();
  
      foreach my $opt (keys %{$self->{opts}}) {
          if ($self->{opts}->{$opt}) {
              $stat{$opt} = $self->{obj}->{$opt}->get();
              if ($opt eq 'netstats') {
                  $stat{netinfo} = $self->{obj}->{$opt}->get_raw();
              }
          }
      }
  
      return Sys::Statistics::Linux::Compilation->new(\%stat);
  }
  
  sub settime {
      my $self = shift;
      my $format = @_ ? shift : '%Y-%m-%d %H:%M:%S';
      $self->{timeformat} = $format;
  }
  
  sub gettime {
      my $self = shift;
      $self->settime(@_) unless $self->{timeformat};
      my $tm = strftime($self->{timeformat}, localtime);
      return wantarray ? split /\s+/, $tm : $tm;
  }
  
  1;
SYS_STATISTICS_LINUX

$fatpacked{"Sys/Statistics/Linux/Compilation.pm"} = <<'SYS_STATISTICS_LINUX_COMPILATION';
  =head1 NAME
  
  Sys::Statistics::Linux::Compilation - Statistics compilation.
  
  =head1 SYNOPSIS
  
      use Sys::Statistics::Linux;
  
      my $lxs  = Sys::Statistics::Linux->new( loadavg => 1 );
      my $stat = $lxs->get;
  
      foreach my $key ($stat->loadavg) {
          print $key, " ", $stat->loadavg($key), "\n";
      }
  
      # or
  
      use Sys::Statistics::Linux::LoadAVG;
      use Sys::Statistics::Linux::Compilation;
  
      my $lxs  = Sys::Statistics::Linux::LoadAVG->new();
      my $load = $lxs->get;
      my $stat = Sys::Statistics::Linux::Compilation->new({ loadavg => $load });
  
      foreach my $key ($stat->loadavg) {
          print $key, " ", $stat->loadavg($key), "\n";
      }
  
      # or
  
      foreach my $key ($stat->loadavg) {
          print $key, " ", $stat->loadavg->{$key}, "\n";
      }
  
  =head1 DESCRIPTION
  
  This module provides different methods to access and filter the statistics compilation.
  
  =head1 METHODS
  
  =head2 new()
  
  Create a new C<Sys::Statistics::Linux::Compilation> object. This creator is only useful if you
  don't call C<get()> of C<Sys::Statistics::Linux>. You can create a new object with:
  
      my $lxs  = Sys::Statistics::Linux::LoadAVG->new();
      my $load = $lxs->get;
      my $stat = Sys::Statistics::Linux::Compilation->new({ loadavg => $load });
  
  =head2 Statistic methods
  
  =over 4
  
  =item sysinfo()
  
  =item cpustats()
  
  =item procstats()
  
  =item memstats()
  
  =item pgswstats()
  
  =item netstats()
  
  =item netinfo()
  
  C<netinfo()> provides raw data - no deltas.
  
  =item sockstats()
  
  =item diskstats()
  
  =item diskusage()
  
  =item loadavg()
  
  =item filestats()
  
  =item processes()
  
  =back
  
  All methods returns the statistics as a hash reference in scalar context. In list all methods
  returns the first level keys of the statistics. Example:
  
      my $net  = $stat->netstats;                 # netstats as a hash reference
      my @dev  = $stat->netstats;                 # the devices eth0, eth1, ...
      my $eth0 = $stat->netstats('eth0');         # eth0 statistics as a hash reference
      my @keys = $stat->netstats('eth0');         # the statistic keys
      my @vals = $stat->netstats('eth0', @keys);  # the values for the passed device and @keys
      my $val  = $stat->netstats('eth0', $key);   # the value for the passed device and key
  
  Sorted ...
  
      my @dev  = sort $stat->netstats;
      my @keys = sort $stat->netstats('eth0');
  
  =head2 pstop()
  
  This method is looking for top processes and returns a sorted list of PIDs as an array or
  array reference depending on the context. It expected two values: a key name and the number
  of top processes to return.
  
  As example you want to get the top 5 processes with the highest cpu usage:
  
      my @top5 = $stat->pstop( ttime => 5 );
      # or as a reference
      my $top5 = $stat->pstop( ttime => 5 );
  
  If you want to get all processes:
  
      my @top_all = $stat->pstop( ttime => $FALSE );
      # or just
      my @top_all = $stat->pstop( 'ttime' );
  
  =head2 search(), psfind()
  
  Both methods provides a simple scan engine to find special statistics. Both methods except a filter
  as a hash reference. It's possible to pass the statistics as second argument if the data is not stored
  in the object.
  
  The method C<search()> scans for statistics and rebuilds the hash tree until that keys that matched
  your filter and returns the hits as a hash reference.
  
      my $hits = $stat->search({
          processes => {
              cmd   => qr/\[su\]/,
              owner => qr/root/
          },
          cpustats => {
              idle   => 'lt:10',
              iowait => 'gt:10'
          },
          diskusage => {
              '/dev/sda1' => {
                  usageper => 'gt:80'
              }
          }
      });
  
  This would return the following matches:
  
      * processes with the command "[su]"
      * processes with the owner "root"
      * all cpu where "idle" is less than 50
      * all cpu where "iowait" is grather than 10
      * only disk '/dev/sda1' if "usageper" is grather than 80
  
  The method C<psfind()> scans for processes only and returns a array reference with all process
  IDs that matched the filter. Example:
  
      my $pids = $stat->psfind({ cmd => qr/init/, owner => 'eq:apache' });
  
  This would return the following process ids:
  
      * processes that matched the command "init"
      * processes with the owner "apache"
  
  There are different match operators available:
  
      gt  -  grather than
      lt  -  less than
      eq  -  is equal
      ne  -  is not equal
  
  Notation examples:
  
      gt:50
      lt:50
      eq:50
      ne:50
  
  Both argumnents have to be set as a hash reference.
  
  Note: the operators < > = ! are not available any more. It's possible that in further releases
  could be different changes for C<search()> and C<psfind()>. So please take a look to the 
  documentation if you use it.
  
  =head1 EXPORTS
  
  No exports.
  
  =head1 TODOS
  
     * Are there any wishs from your side? Send me a mail!
  
  =head1 REPORTING BUGS
  
  Please report all bugs to <jschulz.cpan(at)bloonix.de>.
  
  =head1 AUTHOR
  
  Jonny Schulz <jschulz.cpan(at)bloonix.de>.
  
  Thanks to Moritz Lenz for his suggestion for the name of this module.
  
  =head1 COPYRIGHT
  
  Copyright (c) 2006, 2007 by Jonny Schulz. All rights reserved.
  
  This program is free software; you can redistribute it and/or modify it under the same terms as Perl itself.
  
  =cut
  
  package Sys::Statistics::Linux::Compilation;
  
  use strict;
  use warnings;
  use Carp qw(croak);
  
  our $VERSION = '0.10';
  
  # Creating the statistics accessors
  BEGIN {
      foreach my $stat (qw/sysinfo procstats memstats sockstats loadavg filestats/) {
          no strict 'refs';
          *{$stat} = sub {
              use strict 'refs';
              my ($self, @keys) = @_;
              return () unless $self->{$stat};
              if (@keys) {
                  return @{$self->{$stat}}{@keys};
              }
              return wantarray ? keys %{$self->{$stat}} : $self->{$stat};
          };
      }
      foreach my $stat (qw/cpustats pgswstats netstats netinfo diskstats diskusage processes/) {
          no strict 'refs';
          *{$stat} = sub {
              use strict 'refs';
              my ($self, $sub, @keys) = @_;
              return () unless $self->{$stat};
              if ($sub) {
                  my $ref = $self->{$stat};
                  return () unless exists $ref->{$sub};
                  if (@keys) {
                      return @{$ref->{$sub}}{@keys};
                  } else {
                      return wantarray ? keys %{$ref->{$sub}} : $ref->{$sub};
                  }
              }
              return wantarray ? keys %{$self->{$stat}} : $self->{$stat};
          };
      }
  }
  
  sub new {
      my ($class, $stats) = @_;
      unless (ref($stats) eq 'HASH') {
          croak 'Usage: $class->new( \%statistics )';
      }
      return bless $stats, $class;
  }
  
  sub search {
      my $self   = shift;
      my $filter = ref($_[0]) eq 'HASH' ? shift : {@_};
      my $class  = ref($self);
      my %hits   = ();
  
      foreach my $opt (keys %{$filter}) {
  
          unless (ref($filter->{$opt}) eq 'HASH') {
              croak "$class: not a hash ref opt '$opt'";
          }
  
          # next if the object isn't loaded
          next unless exists $self->{$opt};
          my $fref = $filter->{$opt};
          my $proc = $self->{$opt};
          my $subref;
  
          # we search for matches for each key that is defined
          # in %filter and rebuild the tree until that key that
          # matched the searched string
  
          foreach my $x (keys %{$fref}) {
              if (ref($fref->{$x}) eq 'HASH') {
                  # if the key $proc->{eth0} doesn't exists
                  # then we continue with the next defined filter
                  next unless exists $proc->{$x};
                  $subref = $proc->{$x};
  
                  while ( my ($name, $value) = each %{$fref->{$x}} ) {
                      if (exists $subref->{$name} && $self->_compare($subref->{$name}, $value)) {
                          $hits{$opt}{$x}{$name} = $subref->{$name};
                      }
                  }
              } else {
                  foreach my $key (keys %{$proc}) {
                      if (ref($proc->{$key}) eq 'HASH') {
                          $subref = $proc->{$key};
                          if (ref $subref->{$x} eq 'HASH') {
                              foreach my $y (keys %{$subref->{$x}}) {
                                  if ($self->_compare($subref->{$x}->{$y}, $fref->{$x})) {
                                      $hits{$opt}{$key}{$x}{$y} = $subref->{$x}->{$y};
                                  }
                              }
                          } elsif (defined $subref->{$x} && $self->_compare($subref->{$x}, $fref->{$x})) {
                              $hits{$opt}{$key}{$x} = $subref->{$x};
                          }
                      } else { # must be a scalar now
                          if (defined $proc->{$x} && $self->_compare($proc->{$x}, $fref->{$x})) {
                              $hits{$opt}{$x} = $proc->{$x}
                          }
                          last;
                      }
                  }
              }
          }
      }
  
      return wantarray ? %hits : \%hits;
  }
  
  sub psfind {
      my $self   = shift;
      my $filter = ref($_[0]) eq 'HASH' ? shift : {@_};
      my $proc   = $self->{processes} or return undef;
      my @hits   = ();
  
      PID: foreach my $pid (keys %{$proc}) {
          my $proc = $proc->{$pid};
          while ( my ($key, $value) = each %{$filter} ) {
              if (exists $proc->{$key}) {
                  if (ref $proc->{$key} eq 'HASH') {
                      foreach my $v (values %{$proc->{$key}}) {
                          if ($self->_compare($v, $value)) {
                              push @hits, $pid;
                              next PID;
                          }
                      }
                  } elsif ($self->_compare($proc->{$key}, $value)) {
                      push @hits, $pid;
                      next PID;
                  }
              }
          }
      }
  
      return wantarray ? @hits : \@hits;
  }
  
  sub pstop {
      my ($self, $key, $count) = @_;
      unless ($key) {
          croak 'Usage: pstop( $key => $count )';
      }
      my $proc = $self->{processes};
      my @top = (
          map { $_->[0] }
          reverse sort { $a->[1] <=> $b->[1] }
          map { [ $_, $proc->{$_}->{$key} ] } keys %{$proc}
      );
      if ($count) {
          @top = @top[0..--$count];
      }
      return wantarray ? @top : \@top;
  }
  
  #
  # private stuff
  #
  
  sub _compare {
      my ($self, $x, $y) = @_;
  
      if (ref($y) eq 'Regexp') {
          return $x =~ $y;
      } elsif ($y =~ s/^eq://) {
          return $x eq $y;
      } elsif ($y =~ s/^ne://) {
          return $x ne $y;
      } elsif ($y =~ s/^gt://) {
          return $x > $y;
      } elsif ($y =~ s/^lt://) {
          return $x < $y;
      } else {
          croak ref($self).": bad search() / psfind() operator '$y'";
      }
  
      return undef;
  }
  
  1;
SYS_STATISTICS_LINUX_COMPILATION

$fatpacked{"Sys/Statistics/Linux/CpuStats.pm"} = <<'SYS_STATISTICS_LINUX_CPUSTATS';
  =head1 NAME
  
  Sys::Statistics::Linux::CpuStats - Collect linux cpu statistics.
  
  =head1 SYNOPSIS
  
      use Sys::Statistics::Linux::CpuStats;
  
      my $lxs = Sys::Statistics::Linux::CpuStats->new;
      $lxs->init;
      sleep 1;
      my $stats = $lxs->get;
  
  Or
  
      my $lxs = Sys::Statistics::Linux::CpuStats->new(initfile => $file);
      $lxs->init;
      my $stats = $lxs->get;
  
  =head1 DESCRIPTION
  
  Sys::Statistics::Linux::CpuStats gathers cpu statistics from the virtual
  F</proc> filesystem (procfs).
  
  For more information read the documentation of the front-end module
  L<Sys::Statistics::Linux>.
  
  =head1 CPU STATISTICS
  
  Generated by F</proc/stat> for each cpu (cpu0, cpu1 ...). F<cpu> without
  a number is the summary.
  
      user    -  Percentage of CPU utilization at the user level.
      nice    -  Percentage of CPU utilization at the user level with nice priority.
      system  -  Percentage of CPU utilization at the system level.
      idle    -  Percentage of time the CPU is in idle state.
      total   -  Total percentage of CPU utilization.
  
  Statistics with kernels >= 2.6.
  
      iowait  -  Percentage of time the CPU is in idle state because an I/O operation
                 is waiting to complete.
      irq     -  Percentage of time the CPU is servicing interrupts.
      softirq -  Percentage of time the CPU is servicing softirqs.
      steal   -  Percentage of stolen CPU time, which is the time spent in other
                 operating systems when running in a virtualized environment (>=2.6.11).
  
  =head1 METHODS
  
  =head2 new()
  
  Call C<new()> to create a new object.
  
      my $lxs = Sys::Statistics::Linux::CpuStats->new;
  
  Maybe you want to store/load the initial statistics to/from a file:
  
      my $lxs = Sys::Statistics::Linux::CpuStats->new(initfile => '/tmp/cpustats.yml');
  
  If you set C<initfile> it's not necessary to call sleep before C<get()>.
  
  It's also possible to set the path to the proc filesystem.
  
       Sys::Statistics::Linux::CpuStats->new(
          files => {
              # This is the default
              path => '/proc'
              stat => 'stat',
          }
      );
  
  =head2 init()
  
  Call C<init()> to initialize the statistics.
  
      $lxs->init;
  
  =head2 get()
  
  Call C<get()> to get the statistics. C<get()> returns the statistics as a hash reference.
  
      my $stats = $lxs->get;
  
  =head2 raw()
  
  Get raw values.
  
  =head1 EXPORTS
  
  No exports.
  
  =head1 SEE ALSO
  
  B<proc(5)>
  
  =head1 REPORTING BUGS
  
  Please report all bugs to <jschulz.cpan(at)bloonix.de>.
  
  =head1 AUTHOR
  
  Jonny Schulz <jschulz.cpan(at)bloonix.de>.
  
  =head1 COPYRIGHT
  
  Copyright (c) 2006, 2007 by Jonny Schulz. All rights reserved.
  
  This program is free software; you can redistribute it and/or modify it under the same terms as Perl itself.
  
  =cut
  
  package Sys::Statistics::Linux::CpuStats;
  
  use strict;
  use warnings;
  use Carp qw(croak);
  
  our $VERSION = '0.20';
  
  sub new {
      my $class = shift;
      my $opts  = ref($_[0]) ? shift : {@_};
  
      my %self = (
          files => {
              path => '/proc',
              stat => 'stat',
          }
      );
  
      if (defined $opts->{initfile}) {
          require YAML::Syck;
          $self{initfile} = $opts->{initfile};
      }
  
      foreach my $file (keys %{ $opts->{files} }) {
          $self{files}{$file} = $opts->{files}->{$file};
      }
  
      return bless \%self, $class;
  }
  
  sub raw {
      my $self = shift;
      my $stat = $self->_load;
      return $stat;
  }
  
  sub init {
      my $self = shift;
  
      if ($self->{initfile} && -r $self->{initfile}) {
          $self->{init} = YAML::Syck::LoadFile($self->{initfile});
      } else {
          $self->{init} = $self->_load;
      }
  }
  
  sub get {
      my $self  = shift;
      my $class = ref $self;
  
      if (!exists $self->{init}) {
          croak "$class: there are no initial statistics defined";
      }
  
      $self->{stats} = $self->_load;
      $self->_deltas;
  
      if ($self->{initfile}) {
          YAML::Syck::DumpFile($self->{initfile}, $self->{init});
      }
  
      return $self->{stats};
  }
  
  #
  # private stuff
  #
  
  sub _load {
      my $self  = shift;
      my $class = ref $self;
      my $file  = $self->{files};
      my (%stats, $iowait, $irq, $softirq, $steal);
  
      my $filename = $file->{path} ? "$file->{path}/$file->{stat}" : $file->{stat};
      open my $fh, '<', $filename or croak "$class: unable to open $filename ($!)";
  
      while (my $line = <$fh>) {
          if ($line =~ /^(cpu.*?)\s+(.*)$/) {
              my $cpu = \%{$stats{$1}};
              (@{$cpu}{qw(user nice system idle)},
                  $iowait, $irq, $softirq, $steal) = split /\s+/, $2;
              # iowait, irq and softirq are only set 
              # by kernel versions higher than 2.4.
              # steal is available since 2.6.11.
              $cpu->{iowait}  = $iowait  if defined $iowait;
              $cpu->{irq}     = $irq     if defined $irq;
              $cpu->{softirq} = $softirq if defined $softirq;
              $cpu->{steal}   = $steal   if defined $steal;
          }
      }
  
      close($fh);
      return \%stats;
  }
  
  sub _deltas {
      my $self  = shift;
      my $class = ref $self;
      my $istat = $self->{init};
      my $lstat = $self->{stats};
  
      foreach my $cpu (keys %{$lstat}) {
          my $icpu = $istat->{$cpu};
          my $dcpu = $lstat->{$cpu};
          my $uptime;
  
          while (my ($k, $v) = each %{$dcpu}) {
              if (!defined $icpu->{$k}) {
                  croak "$class: not defined key found '$k'";
              }
  
              if ($v !~ /^\d+\z/ || $dcpu->{$k} !~ /^\d+\z/) {
                  croak "$class: invalid value for key '$k'";
              }
  
              $dcpu->{$k} -= $icpu->{$k};
              $icpu->{$k}  = $v;
              $uptime += $dcpu->{$k};
          }
  
          foreach my $k (keys %{$dcpu}) {
              if ($dcpu->{$k} > 0) {
                  $dcpu->{$k} = sprintf('%.2f', 100 * $dcpu->{$k} / $uptime);
              } elsif ($dcpu->{$k} < 0) {
                  $dcpu->{$k} = sprintf('%.2f', 0);
              } else {
                  $dcpu->{$k} = sprintf('%.2f', $dcpu->{$k});
              }
          }
  
          $dcpu->{total} = sprintf('%.2f', 100 - $dcpu->{idle});
      }
  }
  
  1;
SYS_STATISTICS_LINUX_CPUSTATS

$fatpacked{"Sys/Statistics/Linux/DiskStats.pm"} = <<'SYS_STATISTICS_LINUX_DISKSTATS';
  =head1 NAME
  
  Sys::Statistics::Linux::DiskStats - Collect linux disk statistics.
  
  =head1 SYNOPSIS
  
      use Sys::Statistics::Linux::DiskStats;
  
      my $lxs = Sys::Statistics::Linux::DiskStats->new;
      $lxs->init;
      sleep 1;
      my $stat = $lxs->get;
  
  Or
  
      my $lxs = Sys::Statistics::Linux::DiskStats->new(initfile => $file);
      $lxs->init;
      my $stat = $lxs->get;
  
  =head1 DESCRIPTION
  
  Sys::Statistics::Linux::DiskStats gathers disk statistics from the virtual F</proc> filesystem (procfs).
  
  For more information read the documentation of the front-end module L<Sys::Statistics::Linux>.
  
  =head1 DISK STATISTICS
  
  Generated by F</proc/diskstats> or F</proc/partitions>.
  
      major   -  The mayor number of the disk
      minor   -  The minor number of the disk
      rdreq   -  Number of read requests that were made to physical disk per second.
      rdbyt   -  Number of bytes that were read from physical disk per second.
      wrtreq  -  Number of write requests that were made to physical disk per second.
      wrtbyt  -  Number of bytes that were written to physical disk per second.
      ttreq   -  Total number of requests were made from/to physical disk per second.
      ttbyt   -  Total number of bytes transmitted from/to physical disk per second.
  
  =head1 METHODS
  
  =head2 new()
  
  Call C<new()> to create a new object.
  
      my $lxs = Sys::Statistics::Linux::DiskStats->new;
  
  Maybe you want to store/load the initial statistics to/from a file:
  
      my $lxs = Sys::Statistics::Linux::DiskStats->new(initfile => '/tmp/diskstats.yml');
  
  If you set C<initfile> it's not necessary to call sleep before C<get()>.
  
  It's also possible to set the path to the proc filesystem.
  
       Sys::Statistics::Linux::DiskStats->new(
          files => {
              # This is the default
              path       => '/proc',
              diskstats  => 'diskstats',
              partitions => 'partitions',
          }
      );
  
  =head2 init()
  
  Call C<init()> to initialize the statistics.
  
      $lxs->init;
  
  =head2 get()
  
  Call C<get()> to get the statistics. C<get()> returns the statistics as a hash reference.
  
      my $stat = $lxs->get;
  
  =head2 raw()
  
  Get raw values.
  
  =head1 EXPORTS
  
  No exports.
  
  =head1 SEE ALSO
  
  B<proc(5)>
  
  =head1 REPORTING BUGS
  
  Please report all bugs to <jschulz.cpan(at)bloonix.de>.
  
  =head1 AUTHOR
  
  Jonny Schulz <jschulz.cpan(at)bloonix.de>.
  
  =head1 COPYRIGHT
  
  Copyright (c) 2006, 2007 by Jonny Schulz. All rights reserved.
  
  This program is free software; you can redistribute it and/or modify it under the same terms as Perl itself.
  
  =cut
  
  package Sys::Statistics::Linux::DiskStats;
  
  use strict;
  use warnings;
  use Carp qw(croak);
  use Time::HiRes;
  
  our $VERSION = '0.24';
  
  sub new {
      my $class = shift;
      my $opts  = ref($_[0]) ? shift : {@_};
  
      my %self = (
          files => {
              path       => '/proc',
              diskstats  => 'diskstats',
              partitions => 'partitions',
          },
          # --------------------------------------------------------------
          # The sectors are equivalent with blocks and have a size of 512
          # bytes since 2.4 kernels. This value is needed to calculate the
          # amount of disk i/o's in bytes.
          # --------------------------------------------------------------
          blocksize => 512,
      );
  
      if (defined $opts->{initfile}) {
          require YAML::Syck;
          $self{initfile} = $opts->{initfile};
      }
  
      foreach my $file (keys %{ $opts->{files} }) {
          $self{files}{$file} = $opts->{files}->{$file};
      }
  
      if ($opts->{blocksize}) {
          $self{blocksize} = $opts->{blocksize};
      }
  
      return bless \%self, $class;
  }
  
  sub init {
      my $self = shift;
  
      if ($self->{initfile} && -r $self->{initfile}) {
          $self->{init} = YAML::Syck::LoadFile($self->{initfile});
          $self->{time} = delete $self->{init}->{time};
      } else {
          $self->{time} = Time::HiRes::gettimeofday();
          $self->{init} = $self->_load;
      }
  }
  
  sub get {
      my $self  = shift;
      my $class = ref $self;
  
      if (!exists $self->{init}) {
          croak "$class: there are no initial statistics defined";
      }
  
      $self->{stats} = $self->_load;
      $self->_deltas;
  
      if ($self->{initfile}) {
          $self->{init}->{time} = $self->{time};
          YAML::Syck::DumpFile($self->{initfile}, $self->{init});
      }
  
      return $self->{stats};
  }
  
  sub raw {
      my $self = shift;
      my $raw  = $self->_load;
  
      return $raw;
  }
  
  #
  # private stuff
  #
  
  sub _load {
      my $self  = shift;
      my $class = ref $self;
      my $file  = $self->{files};
      my $bksz  = $self->{blocksize};
      my (%stats, $fh);
  
      # -----------------------------------------------------------------------------
      # one of the both must be opened for the disk statistics!
      # if diskstats (2.6) doesn't exists then let's try to read
      # the partitions (2.4)
      #
      # /usr/src/linux/Documentation/iostat.txt shortcut
      #
      # ... the statistics fields are those after the device name.
      #
      # Field  1 -- # of reads issued
      #     This is the total number of reads completed successfully.
      # Field  2 -- # of reads merged, field 6 -- # of writes merged
      #     Reads and writes which are adjacent to each other may be merged for
      #     efficiency.  Thus two 4K reads may become one 8K read before it is
      #     ultimately handed to the disk, and so it will be counted (and queued)
      #     as only one I/O.  This field lets you know how often this was done.
      # Field  3 -- # of sectors read
      #     This is the total number of sectors read successfully.
      # Field  4 -- # of milliseconds spent reading
      #     This is the total number of milliseconds spent by all reads (as
      #     measured from __make_request() to end_that_request_last()).
      # Field  5 -- # of writes completed
      #     This is the total number of writes completed successfully.
      # Field  7 -- # of sectors written
      #     This is the total number of sectors written successfully.
      # Field  8 -- # of milliseconds spent writing
      #     This is the total number of milliseconds spent by all writes (as
      #     measured from __make_request() to end_that_request_last()).
      # Field  9 -- # of I/Os currently in progress
      #     The only field that should go to zero. Incremented as requests are
      #     given to appropriate request_queue_t and decremented as they finish.
      # Field 10 -- # of milliseconds spent doing I/Os
      #     This field is increases so long as field 9 is nonzero.
      # Field 11 -- weighted # of milliseconds spent doing I/Os
      #     This field is incremented at each I/O start, I/O completion, I/O
      #     merge, or read of these stats by the number of I/Os in progress
      #     (field 9) times the number of milliseconds spent doing I/O since the
      #     last update of this field.  This can provide an easy measure of both
      #     I/O completion time and the backlog that may be accumulating.
      # -----------------------------------------------------------------------------
  
      my $file_diskstats  = $file->{path} ? "$file->{path}/$file->{diskstats}"  : $file->{diskstats};
      my $file_partitions = $file->{path} ? "$file->{path}/$file->{partitions}" : $file->{partitions};
  
      if (open $fh, '<', $file_diskstats) {
          while (my $line = <$fh>) {
              #                   --      --      --      F1     F2     F3     F4     F5     F6     F7     F8    F9    F10   F11
              #                   $1      $2      $3      $4     --     $5     --     $6     --     $7     --    --    --    --
              if ($line =~ /^\s+(\d+)\s+(\d+)\s+(.+?)\s+(\d+)\s+\d+\s+(\d+)\s+\d+\s+(\d+)\s+\d+\s+(\d+)\s+\d+\s+\d+\s+\d+\s+\d+$/) {
                  for my $x ($stats{$3}) { # $3 -> the device name
                      $x->{major}   = $1;
                      $x->{minor}   = $2;
                      $x->{rdreq}   = $4;         # Field 1
                      $x->{rdbyt}   = $5 * $bksz; # Field 3
                      $x->{wrtreq}  = $6;         # Field 5
                      $x->{wrtbyt}  = $7 * $bksz; # Field 7
                      $x->{ttreq}  += $x->{rdreq} + $x->{wrtreq};
                      $x->{ttbyt}  += $x->{rdbyt} + $x->{wrtbyt};
                  }
              }
  
              # -----------------------------------------------------------------------------
              # Field  1 -- # of reads issued
              #     This is the total number of reads issued to this partition.
              # Field  2 -- # of sectors read
              #     This is the total number of sectors requested to be read from this
              #     partition.
              # Field  3 -- # of writes issued
              #     This is the total number of writes issued to this partition.
              # Field  4 -- # of sectors written
              #     This is the total number of sectors requested to be written to
              #     this partition.
              # -----------------------------------------------------------------------------
              #                      --      --      --      F1      F2      F3      F4
              #                      $1      $2      $3      $4      $5      $6      $7
              elsif ($line =~ /^\s+(\d+)\s+(\d+)\s+(.+?)\s+(\d+)\s+(\d+)\s+(\d+)\s+(\d+)$/) {
                  for my $x ($stats{$3}) { # $3 -> the device name
                      $x->{major}   = $1;
                      $x->{minor}   = $2;
                      $x->{rdreq}   = $4;         # Field 1
                      $x->{rdbyt}   = $5 * $bksz; # Field 2
                      $x->{wrtreq}  = $6;         # Field 3
                      $x->{wrtbyt}  = $7 * $bksz; # Field 4
                      $x->{ttreq}  += $x->{rdreq} + $x->{wrtreq};
                      $x->{ttbyt}  += $x->{rdbyt} + $x->{wrtbyt};
                  }
              }
          }
          close($fh);
      } elsif (open $fh, '<', $file_partitions) {
          while (my $line = <$fh>) {
              #                           --      --     --     --      F1     F2     F3     F4     F5     F6     F7     F8    F9    F10   F11
              #                           $1      $2     --     $3      $4     --     $5     --     $6     --     $7     --    --    --    --
              next unless $line =~ /^\s+(\d+)\s+(\d+)\s+\d+\s+(.+?)\s+(\d+)\s+\d+\s+(\d+)\s+\d+\s+(\d+)\s+\d+\s+(\d+)\s+\d+\s+\d+\s+\d+\s+\d+$/;
              for my $x ($stats{$3}) { # $3 -> the device name
                  $x->{major}   = $1;
                  $x->{minor}   = $2;
                  $x->{rdreq}   = $4;         # Field 1
                  $x->{rdbyt}   = $5 * $bksz; # Field 3
                  $x->{wrtreq}  = $6;         # Field 5
                  $x->{wrtbyt}  = $7 * $bksz; # Field 7
                  $x->{ttreq}  += $x->{rdreq} + $x->{wrtreq};
                  $x->{ttbyt}  += $x->{rdbyt} + $x->{wrtbyt};
              }
          }
          close($fh);
      } else {
          croak "$class: unable to open $file_diskstats or $file_partitions ($!)";
      }
  
      if (!-e $file_diskstats || !scalar %stats) {
          croak "$class: no diskstats found! your system seems not to be compiled with CONFIG_BLK_STATS=y";
      }
  
      return \%stats;
  }
  
  sub _deltas {
      my $self  = shift;
      my $class = ref $self;
      my $istat = $self->{init};
      my $lstat = $self->{stats};
      my $time  = Time::HiRes::gettimeofday();
      my $delta = sprintf('%.2f', $time - $self->{time});
      $self->{time} = $time;
  
      foreach my $dev (keys %{$lstat}) {
          if (!exists $istat->{$dev}) {
              delete $lstat->{$dev};
              next;
          }
  
          my $idev = $istat->{$dev};
          my $ldev = $lstat->{$dev};
  
          while (my ($k, $v) = each %{$ldev}) {
              next if $k =~ /^major\z|^minor\z/;
  
              if (!defined $idev->{$k}) {
                  croak "$class: not defined key found '$k'";
              }
  
              if ($v !~ /^\d+\z/ || $ldev->{$k} !~ /^\d+\z/) {
                  croak "$class: invalid value for key '$k'";
              }
  
              if ($ldev->{$k} == $idev->{$k} || $idev->{$k} > $ldev->{$k}) {
                  $ldev->{$k} = sprintf('%.2f', 0);
              } elsif ($delta > 0) {
                  $ldev->{$k} = sprintf('%.2f', ($ldev->{$k} - $idev->{$k}) / $delta);
              } else {
                  $ldev->{$k} = sprintf('%.2f', $ldev->{$k} - $idev->{$k});
              }
  
              $idev->{$k}  = $v;
          }
      }
  }
  
  1;
SYS_STATISTICS_LINUX_DISKSTATS

$fatpacked{"Sys/Statistics/Linux/DiskUsage.pm"} = <<'SYS_STATISTICS_LINUX_DISKUSAGE';
  =head1 NAME
  
  Sys::Statistics::Linux::DiskUsage - Collect linux disk usage.
  
  =head1 SYNOPSIS
  
      use Sys::Statistics::Linux::DiskUsage;
  
      my $lxs  = new Sys::Statistics::Linux::DiskUsage;
      my $stat = $lxs->get;
  
  =head1 DESCRIPTION
  
  Sys::Statistics::Linux::DiskUsage gathers the disk usage with the command C<df>.
  
  For more information read the documentation of the front-end module L<Sys::Statistics::Linux>.
  
  =head1 DISK USAGE INFORMATIONS
  
  Generated by F</bin/df -kP>.
  
      total       -  The total size of the disk.
      usage       -  The used disk space in kilobytes.
      free        -  The free disk space in kilobytes.
      usageper    -  The used disk space in percent.
      mountpoint  -  The moint point of the disk.
  
  =head2 GLOBAL VARS
  
  If you want to change the path or arguments for C<df> you can use the following
  variables...
  
      $Sys::Statistics::Linux::DiskUsage::DF_PATH = '/bin';
      $Sys::Statistics::Linux::DiskUsage::DF_CMD  = 'df -akP';
  
  Example:
  
      use Sys::Statistics::Linux;
      use Sys::Statistics::Linux::DiskUsage;
      $Sys::Statistics::Linux::DiskUsage::DF_CMD = 'df -akP';
  
      my $sys  = Sys::Statistics::Linux->new(diskusage => 1);
      my $disk = $sys->get;
  
  =head1 METHODS
  
  =head2 new()
  
  Call C<new()> to create a new object.
  
      my $lxs = Sys::Statistics::Linux::DiskUsage->new;
  
  It's possible to set the path to df.
  
       Sys::Statistics::Linux::DiskUsage->new(
          cmd => {
              # This is the default
              path => '/bin',
              df   => 'df -kP 2>/dev/null',
          }
      );
  
  =head2 get()
  
  Call C<get()> to get the statistics. C<get()> returns the statistics as a hash reference.
  
      my $stat = $lxs->get;
  
  =head1 EXPORTS
  
  No exports.
  
  =head1 SEE ALSO
  
  B<df(1)>
  
  =head1 REPORTING BUGS
  
  Please report all bugs to <jschulz.cpan(at)bloonix.de>.
  
  =head1 AUTHOR
  
  Jonny Schulz <jschulz.cpan(at)bloonix.de>.
  
  =head1 COPYRIGHT
  
  Copyright (c) 2006, 2007 by Jonny Schulz. All rights reserved.
  
  This program is free software; you can redistribute it and/or modify it under the same terms as Perl itself.
  
  =cut
  
  package Sys::Statistics::Linux::DiskUsage;
  
  use strict;
  use warnings;
  use Carp qw(croak);
  
  our $VERSION = '0.14';
  our $DF_PATH = undef;
  our $DF_CMD  = undef;
  
  sub new {
      my $class = shift;
      my $opts  = ref($_[0]) ? shift : {@_};
  
      my %self = (
          cmd => {
              path => '/bin',
              df   => 'df -kP 2>/dev/null',
          }
      );
  
      foreach my $p (keys %{ $opts->{cmd} }) {
          $self{cmd}{$p} = $opts->{cmd}->{$p};
      }
  
      return bless \%self, $class;
  }
  
  sub get {
      my $self   = shift;
      my $class  = ref $self;
      my $cmd    = $self->{cmd};
      my $df_cmd = $DF_CMD || $cmd->{df};
      my (%disk_usage);
  
      local $ENV{PATH} = $DF_PATH || $cmd->{path};
      open my $fh, "$df_cmd|" or croak "$class: unable to execute '$df_cmd' ($!)";
  
      # filter the header
      {my $null = <$fh>;}
  
      while (my $line = <$fh>) {
          next unless $line =~ /^(.+?)\s+(.+)$/;
  
          @{$disk_usage{$1}}{qw(
              total
              usage
              free
              usageper
              mountpoint
          )} = (split /\s+/, $2)[0..4];
  
          $disk_usage{$1}{usageper} =~ s/%//;
      }
  
      close($fh);
      return \%disk_usage;
  }
  
  1;
SYS_STATISTICS_LINUX_DISKUSAGE

$fatpacked{"Sys/Statistics/Linux/FileStats.pm"} = <<'SYS_STATISTICS_LINUX_FILESTATS';
  =head1 NAME
  
  Sys::Statistics::Linux::FileStats - Collect linux file statistics.
  
  =head1 SYNOPSIS
  
      use Sys::Statistics::Linux::FileStats;
  
      my $lxs  = Sys::Statistics::Linux::FileStats->new;
      my $stat = $lxs->get;
  
  =head1 DESCRIPTION
  
  Sys::Statistics::Linux::FileStats gathers file statistics from the virtual F</proc> filesystem (procfs).
  
  For more information read the documentation of the front-end module L<Sys::Statistics::Linux>.
  
  =head1 FILE STATISTICS
  
  Generated by F</proc/sys/fs/file-nr>, F</proc/sys/fs/inode-nr> and F</proc/sys/fs/dentry-state>.
  
      fhalloc    -  Number of allocated file handles.
      fhfree     -  Number of free file handles.
      fhmax      -  Number of maximum file handles.
      inalloc    -  Number of allocated inodes.
      infree     -  Number of free inodes.
      inmax      -  Number of maximum inodes.
      dentries   -  Dirty directory cache entries.
      unused     -  Free diretory cache size.
      agelimit   -  Time in seconds the dirty cache entries can be reclaimed.
      wantpages  -  Pages that are requested by the system when memory is short.
  
  =head1 METHODS
  
  =head2 new()
  
  Call C<new()> to create a new object.
  
      my $lxs = Sys::Statistics::Linux::FileStats->new;
  
  It's possible to set the path to the proc filesystem.
  
       Sys::Statistics::Linux::FileStats->new(
          files => {
              # This is the default
              path     => '/proc',
              file_nr  => 'sys/fs/file-nr',
              inode_nr => 'sys/fs/inode-nr',
              dentries => 'sys/fs/dentry-state',
          }
      );
  
  =head2 get()
  
  Call C<get()> to get the statistics. C<get()> returns the statistics as a hash reference.
  
      my $stat = $lxs->get;
  
  =head1 EXPORTS
  
  No exports.
  
  =head1 SEE ALSO
  
  B<proc(5)>
  
  =head1 REPORTING BUGS
  
  Please report all bugs to <jschulz.cpan(at)bloonix.de>.
  
  =head1 AUTHOR
  
  Jonny Schulz <jschulz.cpan(at)bloonix.de>.
  
  =head1 COPYRIGHT
  
  Copyright (c) 2006, 2007 by Jonny Schulz. All rights reserved.
  
  This program is free software; you can redistribute it and/or modify it under the same terms as Perl itself.
  
  =cut
  
  package Sys::Statistics::Linux::FileStats;
  
  use strict;
  use warnings;
  use Carp qw(croak);
  
  our $VERSION = '0.09';
  
  sub new {
      my $class = shift;
      my $opts  = ref($_[0]) ? shift : {@_};
  
      my %self = (
          files => {
              path     => '/proc',
              file_nr  => 'sys/fs/file-nr',
              inode_nr => 'sys/fs/inode-nr',
              dentries => 'sys/fs/dentry-state',
          }
      );
  
      foreach my $file (keys %{ $opts->{files} }) {
          $self{files}{$file} = $opts->{files}->{$file};
      }
  
      return bless \%self, $class;
  }
  
  sub get {
      my $self  = shift;
      my $class = ref $self;
      my $file  = $self->{files};
      my $stats = { };
  
      $self->{stats} = $stats;
      $self->_get_file_nr;
      $self->_get_inode_nr;
      $self->_get_dentries;
  
      return $stats;
  }
  
  sub _get_file_nr {
      my $self  = shift;
      my $class = ref $self;
      my $file  = $self->{files};
      my $stats = $self->{stats};
  
      my $filename = $file->{path} ? "$file->{path}/$file->{file_nr}" : $file->{file_nr};
      open my $fh, '<', $filename or croak "$class: unable to open $filename ($!)";
      @$stats{qw(fhalloc fhfree fhmax)} = (split /\s+/, <$fh>)[0..2];
      close($fh);
  }
  
  sub _get_inode_nr {
      my $self  = shift;
      my $class = ref $self;
      my $file  = $self->{files};
      my $stats = $self->{stats};
  
      my $filename = $file->{path} ? "$file->{path}/$file->{inode_nr}" : $file->{inode_nr};
      open my $fh, '<', $filename or croak "$class: unable to open $filename ($!)";
      @$stats{qw(inalloc infree)} = (split /\s+/, <$fh>)[0..1];
      $stats->{inmax} = $stats->{inalloc} + $stats->{infree};
      close($fh);
  }
  
  sub _get_dentries {
      my $self  = shift;
      my $class = ref $self;
      my $file  = $self->{files};
      my $stats = $self->{stats};
  
      my $filename = $file->{path} ? "$file->{path}/$file->{dentries}" : $file->{dentries};
      open my $fh, '<', $filename or croak "$class: unable to open $filename ($!)";
      @$stats{qw(dentries unused agelimit wantpages)} = (split /\s+/, <$fh>)[0..3];
      close($fh);
  }
  
  1;
SYS_STATISTICS_LINUX_FILESTATS

$fatpacked{"Sys/Statistics/Linux/LoadAVG.pm"} = <<'SYS_STATISTICS_LINUX_LOADAVG';
  =head1 NAME
  
  Sys::Statistics::Linux::LoadAVG - Collect linux load average statistics.
  
  =head1 SYNOPSIS
  
      use Sys::Statistics::Linux::LoadAVG;
  
      my $lxs  = Sys::Statistics::Linux::LoadAVG->new;
      my $stat = $lxs->get;
  
  =head1 DESCRIPTION
  
  Sys::Statistics::Linux::LoadAVG gathers the load average from the virtual F</proc> filesystem (procfs).
  
  For more information read the documentation of the front-end module L<Sys::Statistics::Linux>.
  
  =head1 LOAD AVERAGE STATISTICS
  
  Generated by F</proc/loadavg>.
  
      avg_1   -  The average processor workload of the last minute.
      avg_5   -  The average processor workload of the last five minutes.
      avg_15  -  The average processor workload of the last fifteen minutes.
  
  =head1 METHODS
  
  =head2 new()
  
  Call C<new()> to create a new object.
  
      my $lxs = Sys::Statistics::Linux::LoadAVG->new;
  
  It's possible to set the path to the proc filesystem.
  
       Sys::Statistics::Linux::LoadAVG->new(
          files => {
              # This is the default
              path    => '/proc',
              loadavg => 'loadavg',
          }
      );
  
  =head2 get()
  
  Call C<get()> to get the statistics. C<get()> returns the statistics as a hash reference.
  
      my $stat = $lxs->get;
  
  =head1 EXPORTS
  
  No exports.
  
  =head1 SEE ALSO
  
  B<proc(5)>
  
  =head1 REPORTING BUGS
  
  Please report all bugs to <jschulz.cpan(at)bloonix.de>.
  
  =head1 AUTHOR
  
  Jonny Schulz <jschulz.cpan(at)bloonix.de>.
  
  =head1 COPYRIGHT
  
  Copyright (c) 2006, 2007 by Jonny Schulz. All rights reserved.
  
  This program is free software; you can redistribute it and/or modify it under the same terms as Perl itself.
  
  =cut
  
  package Sys::Statistics::Linux::LoadAVG;
  
  use strict;
  use warnings;
  use Carp qw(croak);
  
  our $VERSION = '0.08';
  
  sub new {
      my $class = shift;
      my $opts  = ref($_[0]) ? shift : {@_};
  
      my %self = (
          files => {
              path    => '/proc',
              loadavg => 'loadavg',
          }
      );
  
      foreach my $file (keys %{ $opts->{files} }) {
          $self{files}{$file} = $opts->{files}->{$file};
      }
  
      return bless \%self, $class;
  }
  
  sub get {
      my $self  = shift;
      my $class = ref $self;
      my $file  = $self->{files};
      my %lavg  = ();
  
      my $filename = $file->{path} ? "$file->{path}/$file->{loadavg}" : $file->{loadavg};
      open my $fh, '<', $filename or croak "$class: unable to open $filename ($!)";
  
      ( $lavg{avg_1}
      , $lavg{avg_5}
      , $lavg{avg_15}
      ) = (split /\s+/, <$fh>)[0..2];
  
      close($fh);
      return \%lavg;
  }
  
  1;
SYS_STATISTICS_LINUX_LOADAVG

$fatpacked{"Sys/Statistics/Linux/MemStats.pm"} = <<'SYS_STATISTICS_LINUX_MEMSTATS';
  =head1 NAME
  
  Sys::Statistics::Linux::MemStats - Collect linux memory information.
  
  =head1 SYNOPSIS
  
      use Sys::Statistics::Linux::MemStats;
  
      my $lxs  = Sys::Statistics::Linux::MemStats->new;
      my $stat = $lxs->get;
  
  =head1 DESCRIPTION
  
  Sys::Statistics::Linux::MemStats gathers memory statistics from the virtual F</proc> filesystem (procfs).
  
  For more information read the documentation of the front-end module L<Sys::Statistics::Linux>.
  
  =head1 MEMORY INFORMATIONS
  
  Generated by F</proc/meminfo>.
  
      memused         -  Total size of used memory in kilobytes.
      memfree         -  Total size of free memory in kilobytes.
      memusedper      -  Total size of used memory in percent.
      memtotal        -  Total size of memory in kilobytes.
      buffers         -  Total size of buffers used from memory in kilobytes.
      cached          -  Total size of cached memory in kilobytes.
      realfree        -  Total size of memory is real free (memfree + buffers + cached).
      realfreeper     -  Total size of memory is real free in percent of total memory.
      swapused        -  Total size of swap space is used is kilobytes.
      swapfree        -  Total size of swap space is free in kilobytes.
      swapusedper     -  Total size of swap space is used in percent.
      swaptotal       -  Total size of swap space in kilobytes.
      swapcached      -  Memory that once was swapped out, is swapped back in but still also is in the swapfile.
      active          -  Memory that has been used more recently and usually not reclaimed unless absolutely necessary.
      inactive        -  Memory which has been less recently used and is more eligible to be reclaimed for other purposes.
                         On earlier kernels (2.4) Inact_dirty + Inact_laundry + Inact_clean.
  
      The following statistics are only available by kernels from 2.6.
  
      slab            -  Total size of memory in kilobytes that used by kernel for data structure allocations.
      dirty           -  Total size of memory pages in kilobytes that waits to be written back to disk.
      mapped          -  Total size of memory in kilbytes that is mapped by devices or libraries with mmap.
      writeback       -  Total size of memory that was written back to disk.
      committed_as    -  The amount of memory presently allocated on the system.
  
      The following statistic is only available by kernels from 2.6.9.
  
      commitlimit     -  Total amount of memory currently available to be allocated on the system.
  
  =head1 METHODS
  
  =head2 new()
  
  Call C<new()> to create a new object.
  
      my $lxs = Sys::Statistics::Linux::MemStats->new;
  
  It's possible to set the path to the proc filesystem.
  
       Sys::Statistics::Linux::MemStats->new(
          files => {
              # This is the default
              path    => '/proc',
              meminfo => 'meminfo',
          }
      );
  
  =head2 get()
  
  Call C<get()> to get the statistics. C<get()> returns the statistics as a hash reference.
  
      my $stat = $lxs->get;
  
  =head1 EXPORTS
  
  No exports.
  
  =head1 SEE ALSO
  
  B<proc(5)>
  
  =head1 REPORTING BUGS
  
  Please report all bugs to <jschulz.cpan(at)bloonix.de>.
  
  =head1 AUTHOR
  
  Jonny Schulz <jschulz.cpan(at)bloonix.de>.
  
  =head1 COPYRIGHT
  
  Copyright (c) 2006, 2007 by Jonny Schulz. All rights reserved.
  
  This program is free software; you can redistribute it and/or modify it under the same terms as Perl itself.
  
  =cut
  
  package Sys::Statistics::Linux::MemStats;
  
  use strict;
  use warnings;
  use Carp qw(croak);
  
  our $VERSION = '0.16';
  
  sub new {
      my $class = shift;
      my $opts  = ref($_[0]) ? shift : {@_};
  
      my %self = (
          files => {
              path    => '/proc',
              meminfo => 'meminfo',
          }
      );
  
      foreach my $file (keys %{ $opts->{files} }) {
          $self{files}{$file} = $opts->{files}->{$file};
      }
  
      return bless \%self, $class;
  }
  
  sub get {
      my $self    = shift;
      my $class   = ref($self);
      my $file    = $self->{files};
      my %meminfo = ();
  
      my $filename = $file->{path} ? "$file->{path}/$file->{meminfo}" : $file->{meminfo};
      open my $fh, '<', $filename or croak "$class: unable to open $filename ($!)";
  
      # MemTotal:      1035648 kB
      # MemFree:         15220 kB
      # Buffers:          4280 kB
      # Cached:          47664 kB
      # SwapCached:     473988 kB
      # Active:         661992 kB
      # Inactive:       314312 kB
      # HighTotal:      130884 kB
      # HighFree:          264 kB
      # LowTotal:       904764 kB
      # LowFree:         14956 kB
      # SwapTotal:     1951856 kB
      # SwapFree:      1164864 kB
      # Dirty:             520 kB
      # Writeback:           0 kB
      # AnonPages:      908892 kB
      # Mapped:          34308 kB
      # Slab:            19284 kB
      # SReclaimable:     7532 kB
      # SUnreclaim:      11752 kB
      # PageTables:       3056 kB
      # NFS_Unstable:        0 kB
      # Bounce:              0 kB
      # CommitLimit:   2469680 kB
      # Committed_AS:  1699568 kB
      # VmallocTotal:   114680 kB
      # VmallocUsed:     12284 kB
      # VmallocChunk:   100992 kB
  
      # kernel <= 2.4
      # Inact_dirty: 138632 kB
      # Inact_laundry: 35520 kB
      # Inact_clean: 7544 kB
  
      while (my $line = <$fh>) {
          if ($line =~ /^((?:Mem|Swap)(?:Total|Free)|Buffers|Cached|SwapCached|Active|Inactive|
                          Dirty|Writeback|Mapped|Slab|Commit(?:Limit|ted_AS)):\s*(\d+)/x) {
              my ($n, $v) = ($1, $2);
              $n =~ tr/A-Z/a-z/;
              $meminfo{$n} = $v;
          } elsif ($line =~ /^Inact_(?:dirty|laundry|clean):\s*(\d+)/) {
              $meminfo{inactive} += $1;
          }
      }
  
      close($fh);
  
      $meminfo{memused}     = sprintf('%u', $meminfo{memtotal} - $meminfo{memfree});
      $meminfo{memusedper}  = sprintf('%.2f', 100 * $meminfo{memused} / $meminfo{memtotal});
      $meminfo{swapused}    = sprintf('%u', $meminfo{swaptotal} - $meminfo{swapfree});
      $meminfo{realfree}    = sprintf('%u', $meminfo{memfree} + $meminfo{buffers} + $meminfo{cached});
      $meminfo{realfreeper} = sprintf('%.2f', 100 * $meminfo{realfree} / $meminfo{memtotal});
  
      # maybe there is no swap space on the machine
      if (!$meminfo{swaptotal}) {
          $meminfo{swapusedper} = '0.00';
      } else {
          $meminfo{swapusedper} = sprintf('%.2f', 100 * $meminfo{swapused} / $meminfo{swaptotal});
      }
  
      return \%meminfo;
  }
  
  1;
SYS_STATISTICS_LINUX_MEMSTATS

$fatpacked{"Sys/Statistics/Linux/NetStats.pm"} = <<'SYS_STATISTICS_LINUX_NETSTATS';
  =head1 NAME
  
  Sys::Statistics::Linux::NetStats - Collect linux net statistics.
  
  =head1 SYNOPSIS
  
      use Sys::Statistics::Linux::NetStats;
  
      my $lxs = Sys::Statistics::Linux::NetStats->new;
      $lxs->init;
      sleep 1;
      my $stat = $lxs->get;
  
  Or
  
      my $lxs = Sys::Statistics::Linux::NetStats->new(initfile => $file);
      $lxs->init;
      my $stat = $lxs->get;
  
  =head1 DESCRIPTION
  
  Sys::Statistics::Linux::NetStats gathers net statistics from the virtual F</proc> filesystem (procfs).
  
  For more information read the documentation of the front-end module L<Sys::Statistics::Linux>.
  
  =head1 NET STATISTICS
  
  Generated by F</proc/net/dev>.
  
      rxbyt    -  Number of bytes received per second.
      rxpcks   -  Number of packets received per second.
      rxerrs   -  Number of errors that happend while received packets per second.
      rxdrop   -  Number of packets that were dropped per second.
      rxfifo   -  Number of FIFO overruns that happend on received packets per second.
      rxframe  -  Number of carrier errors that happend on received packets per second.
      rxcompr  -  Number of compressed packets received per second.
      rxmulti  -  Number of multicast packets received per second.
      txbyt    -  Number of bytes transmitted per second.
      txpcks   -  Number of packets transmitted per second.
      txerrs   -  Number of errors that happend while transmitting packets per second.
      txdrop   -  Number of packets that were dropped per second.
      txfifo   -  Number of FIFO overruns that happend on transmitted packets per second.
      txcolls  -  Number of collisions that were detected per second.
      txcarr   -  Number of carrier errors that happend on transmitted packets per second.
      txcompr  -  Number of compressed packets transmitted per second.
      ttpcks   -  Number of total packets (received + transmitted) per second.
      ttbyt    -  Number of total bytes (received + transmitted) per second.
  
  =head1 METHODS
  
  =head2 new()
  
  Call C<new()> to create a new object.
  
      my $lxs = Sys::Statistics::Linux::NetStats->new;
  
  Maybe you want to store/load the initial statistics to/from a file:
  
      my $lxs = Sys::Statistics::Linux::NetStats->new(initfile => '/tmp/netstats.yml');
  
  If you set C<initfile> it's not necessary to call sleep before C<get()>.
  
  It's also possible to set the path to the proc filesystem.
  
       Sys::Statistics::Linux::NetStats->new(
          files => {
              # This is the default
              path   => '/proc',
              netdev => 'net/dev',
          }
      );
  
  =head2 init()
  
  Call C<init()> to initialize the statistics.
  
      $lxs->init;
  
  =head2 get()
  
  Call C<get()> to get the statistics. C<get()> returns the statistics as a hash reference.
  
      my $stat = $lxs->get;
  
  =head2 raw()
  
  The same as get_raw() but it's not necessary to call init() first.
  
  =head2 get_raw()
  
  Call C<get_raw()> to get the raw data - no deltas.
  
  =head1 EXPORTS
  
  No exports.
  
  =head1 SEE ALSO
  
  B<proc(5)>
  
  =head1 REPORTING BUGS
  
  Please report all bugs to <jschulz.cpan(at)bloonix.de>.
  
  =head1 AUTHOR
  
  Jonny Schulz <jschulz.cpan(at)bloonix.de>.
  
  =head1 COPYRIGHT
  
  Copyright (c) 2006, 2007 by Jonny Schulz. All rights reserved.
  
  This program is free software; you can redistribute it and/or modify it under the same terms as Perl itself.
  
  =cut
  
  package Sys::Statistics::Linux::NetStats;
  
  use strict;
  use warnings;
  use Carp qw(croak);
  use Time::HiRes;
  
  our $VERSION = '0.20';
  
  sub new {
      my $class = shift;
      my $opts  = ref($_[0]) ? shift : {@_};
  
      my %self = (
          files => {
              path   => '/proc',
              netdev => 'net/dev',
          }
      );
  
      if (defined $opts->{initfile}) {
          require YAML::Syck;
          $self{initfile} = $opts->{initfile};
      }
  
      foreach my $file (keys %{ $opts->{files} }) {
          $self{files}{$file} = $opts->{files}->{$file};
      }
  
      return bless \%self, $class;
  }
  
  sub init {
      my $self = shift;
  
      if ($self->{initfile} && -r $self->{initfile}) {
          $self->{init} = YAML::Syck::LoadFile($self->{initfile});
          $self->{time} = delete $self->{init}->{time};
      } else {
          $self->{time} = Time::HiRes::gettimeofday();
          $self->{init} = $self->_load;
      }
  }
  
  sub get {
      my $self  = shift;
      my $class = ref $self;
  
      if (!exists $self->{init}) {
          croak "$class: there are no initial statistics defined";
      }
  
      $self->{stats} = $self->_load;
      $self->_deltas;
  
      if ($self->{initfile}) {
          $self->{init}->{time} = $self->{time};
          YAML::Syck::DumpFile($self->{initfile}, $self->{init});
      }
  
      return $self->{stats};
  }
  
  sub raw {
      my $self = shift;
      my $stat = $self->_load;
  
      return $stat;
  }
  
  sub get_raw {
      my $self = shift;
      my %raw  = %{$self->{init}};
      delete $raw{time};
      return \%raw;
  }
  
  #
  # private stuff
  #
  
  sub _load {
      my $self  = shift;
      my $class = ref $self;
      my $file  = $self->{files};
      my %stats = ();
  
      my $filename = $file->{path} ? "$file->{path}/$file->{netdev}" : $file->{netdev};
      open my $fh, '<', $filename or croak "$class: unable to open $filename ($!)";
  
      while (my $line = <$fh>) {
          next unless $line =~ /^\s*(\w+):\s*(.*)/;
          @{$stats{$1}}{qw(
              rxbyt rxpcks rxerrs rxdrop rxfifo rxframe rxcompr rxmulti
              txbyt txpcks txerrs txdrop txfifo txcolls txcarr txcompr
          )} = split /\s+/, $2;
          $stats{$1}{ttbyt} = $stats{$1}{rxbyt} + $stats{$1}{txbyt};
          $stats{$1}{ttpcks} = $stats{$1}{rxpcks} + $stats{$1}{txpcks};
      }
  
      close($fh);
      return \%stats;
  }
  
  sub _deltas {
      my $self  = shift;
      my $class = ref $self;
      my $istat = $self->{init};
      my $lstat = $self->{stats};
      my $time  = Time::HiRes::gettimeofday();
      my $delta = sprintf('%.2f', $time - $self->{time});
      $self->{time} = $time;
  
      foreach my $dev (keys %{$lstat}) {
          if (!exists $istat->{$dev}) {
              delete $lstat->{$dev};
              next;
          }
  
          my $idev = $istat->{$dev};
          my $ldev = $lstat->{$dev};
  
          while (my ($k, $v) = each %{$ldev}) {
              if (!defined $idev->{$k}) {
                  croak "$class: not defined key found '$k'";
              }
  
              if ($v !~ /^\d+\z/ || $ldev->{$k} !~ /^\d+\z/) {
                  croak "$class: invalid value for key '$k'";
              }
  
              if ($ldev->{$k} == $idev->{$k} || $idev->{$k} > $ldev->{$k}) {
                  $ldev->{$k} = sprintf('%.2f', 0);
              } elsif ($delta > 0) {
                  $ldev->{$k} = sprintf('%.2f', ($ldev->{$k} - $idev->{$k}) / $delta);
              } else {
                  $ldev->{$k} = sprintf('%.2f', $ldev->{$k} - $idev->{$k});
              }
  
              $idev->{$k} = $v;
          }
      }
  }
  
  1;
SYS_STATISTICS_LINUX_NETSTATS

$fatpacked{"Sys/Statistics/Linux/PgSwStats.pm"} = <<'SYS_STATISTICS_LINUX_PGSWSTATS';
  =head1 NAME
  
  Sys::Statistics::Linux::PgSwStats - Collect linux paging and swapping statistics.
  
  =head1 SYNOPSIS
  
      use Sys::Statistics::Linux::PgSwStats;
  
      my $lxs = Sys::Statistics::Linux::PgSwStats->new;
      $lxs->init;
      sleep 1;
      my $stat = $lxs->get;
  
  Or
  
      my $lxs = Sys::Statistics::Linux::PgSwStats->new(initfile => $file);
      $lxs->init;
      my $stat = $lxs->get;
  
  =head1 DESCRIPTION
  
  Sys::Statistics::Linux::PgSwStats gathers paging and swapping statistics from the virtual F</proc> filesystem (procfs).
  
  For more information read the documentation of the front-end module L<Sys::Statistics::Linux>.
  
  =head1 PAGING AND SWAPPING STATISTICS
  
  Generated by F</proc/stat> or F</proc/vmstat>.
  
      pgpgin      -  Number of pages the system has paged in from disk per second.
      pgpgout     -  Number of pages the system has paged out to disk per second.
      pswpin      -  Number of pages the system has swapped in from disk per second.
      pswpout     -  Number of pages the system has swapped out to disk per second.
  
      The following statistics are only available by kernels from 2.6.
  
      pgfault     -  Number of page faults the system has made per second (minor + major).
      pgmajfault  -  Number of major faults per second the system required loading a memory page from disk.
  
  =head1 METHODS
  
  =head2 new()
  
  Call C<new()> to create a new object.
  
      my $lxs = Sys::Statistics::Linux::PgSwStats->new;
  
  Maybe you want to store/load the initial statistics to/from a file:
  
      my $lxs = Sys::Statistics::Linux::PgSwStats->new(initfile => '/tmp/pgswstats.yml');
  
  If you set C<initfile> it's not necessary to call sleep before C<get()>.
  
  It's also possible to set the path to the proc filesystem.
  
       Sys::Statistics::Linux::PgSwStats->new(
          files => {
              # This is the default
              path   => '/proc',
              stat   => 'stat',
              vmstat => 'vmstat',
          }
      );
  
  =head2 init()
  
  Call C<init()> to initialize the statistics.
  
      $lxs->init;
  
  =head2 get()
  
  Call C<get()> to get the statistics. C<get()> returns the statistics as a hash reference.
  
      my $stat = $lxs->get;
  
  =head2 raw()
  
  Get raw values.
  
  =head1 EXPORTS
  
  No exports.
  
  =head1 SEE ALSO
  
  B<proc(5)>
  
  =head1 REPORTING BUGS
  
  Please report all bugs to <jschulz.cpan(at)bloonix.de>.
  
  =head1 AUTHOR
  
  Jonny Schulz <jschulz.cpan(at)bloonix.de>.
  
  =head1 COPYRIGHT
  
  Copyright (c) 2006, 2007 by Jonny Schulz. All rights reserved.
  
  This program is free software; you can redistribute it and/or modify it under the same terms as Perl itself.
  
  =cut
  
  package Sys::Statistics::Linux::PgSwStats;
  
  use strict;
  use warnings;
  use Carp qw(croak);
  use Time::HiRes;
  
  our $VERSION = '0.18';
  
  sub new {
      my $class = shift;
      my $opts  = ref($_[0]) ? shift : {@_};
  
      my %self = (
          files => {
              path   => '/proc',
              stat   => 'stat',
              vmstat => 'vmstat',
          }
      );
  
      if (defined $opts->{initfile}) {
          require YAML::Syck;
          $self{initfile} = $opts->{initfile};
      }
  
      foreach my $file (keys %{ $opts->{files} }) {
          $self{files}{$file} = $opts->{files}->{$file};
      }
  
      return bless \%self, $class;
  }
  
  sub init {
      my $self = shift;
  
      if ($self->{initfile} && -r $self->{initfile}) {
          $self->{init} = YAML::Syck::LoadFile($self->{initfile});
          $self->{time} = delete $self->{init}->{time};
      } else {
          $self->{time} = Time::HiRes::gettimeofday();
          $self->{init} = $self->_load;
      }
  }
  
  sub get {
      my $self  = shift;
      my $class = ref $self;
  
      if (!exists $self->{init}) {
          croak "$class: there are no initial statistics defined";
      }
  
      $self->{stats} = $self->_load;
      $self->_deltas;
  
      if ($self->{initfile}) {
          $self->{init}->{time} = $self->{time};
          YAML::Syck::DumpFile($self->{initfile}, $self->{init});
      }
  
      return $self->{stats};
  }
  
  sub raw {
      my $self = shift;
      my $stat = $self->_load;
  
      return $stat;
  }
  
  #
  # private stuff
  #
  
  sub _load {
      my $self  = shift;
      my $class = ref $self;
      my $file  = $self->{files};
      my %stats = ();
  
      my $filename = $file->{path} ? "$file->{path}/$file->{stat}" : $file->{stat};
      open my $fh, '<', $filename or croak "$class: unable to open $filename ($!)";
  
      while (my $line = <$fh>) {
          if ($line =~ /^page\s+(\d+)\s+(\d+)$/) {
              @stats{qw(pgpgin pgpgout)} = ($1, $2);
          } elsif ($line =~ /^swap\s+(\d+)\s+(\d+)$/) {
              @stats{qw(pswpin pswpout)} = ($1, $2);
          }
      }
  
      close($fh);
  
      # if paging and swapping are not found in /proc/stat
      # then let's try a look into /proc/vmstat (since 2.6)
  
      if (!defined $stats{pswpout}) {
          my $filename = $file->{path} ? "$file->{path}/$file->{vmstat}" : $file->{vmstat};
          open my $fh, '<', $filename or croak "$class: unable to open $filename ($!)";
          while (my $line = <$fh>) {
              next unless $line =~ /^(pgpgin|pgpgout|pswpin|pswpout|pgfault|pgmajfault)\s+(\d+)/;
              $stats{$1} = $2;
          }
          close($fh);
      }
  
      return \%stats;
  }
  
  sub _deltas {
      my $self  = shift;
      my $class = ref $self;
      my $istat = $self->{init};
      my $lstat = $self->{stats};
      my $time  = Time::HiRes::gettimeofday();
      my $delta = sprintf('%.2f', $time - $self->{time});
      $self->{time} = $time;
  
      while (my ($k, $v) = each %{$lstat}) {
          if (!defined $istat->{$k} || !defined $lstat->{$k}) {
              croak "$class: not defined key found '$k'";
          }
  
          if ($v !~ /^\d+\z/ || $istat->{$k} !~ /^\d+\z/) {
              croak "$class: invalid value for key '$k'";
          }
  
          if ($lstat->{$k} == $istat->{$k} || $istat->{$k} > $lstat->{$k}) {
              $lstat->{$k} = sprintf('%.2f', 0);
          } elsif ($delta > 0) {
              $lstat->{$k} = sprintf('%.2f', ($lstat->{$k} - $istat->{$k}) / $delta);
          } else {
              $lstat->{$k} = sprintf('%.2f', $lstat->{$k} - $istat->{$k});
          }
  
          $istat->{$k}  = $v;
      }
  }
  
  1;
SYS_STATISTICS_LINUX_PGSWSTATS

$fatpacked{"Sys/Statistics/Linux/ProcStats.pm"} = <<'SYS_STATISTICS_LINUX_PROCSTATS';
  =head1 NAME
  
  Sys::Statistics::Linux::ProcStats - Collect linux process statistics.
  
  =head1 SYNOPSIS
  
      use Sys::Statistics::Linux::ProcStats;
  
      my $lxs = Sys::Statistics::Linux::ProcStats->new;
      $lxs->init;
      sleep 1;
      my $stat = $lxs->get;
  
  Or
  
      my $lxs = Sys::Statistics::Linux::ProcStats->new(initfile => $file);
      $lxs->init;
      my $stat = $lxs->get;
  
  =head1 DESCRIPTION
  
  Sys::Statistics::Linux::ProcStats gathers process statistics from the virtual F</proc> filesystem (procfs).
  
  For more information read the documentation of the front-end module L<Sys::Statistics::Linux>.
  
  =head1 IMPORTANT
  
  I renamed key C<procs_blocked> to C<blocked>!
  
  =head1 LOAD AVERAGE STATISTICS
  
  Generated by F</proc/stat> and F</proc/loadavg>.
  
      new       -  Number of new processes that were produced per second.
      runqueue  -  The number of currently executing kernel scheduling entities (processes, threads).
      count     -  The number of kernel scheduling entities that currently exist on the system (processes, threads).
      blocked   -  Number of processes blocked waiting for I/O to complete (Linux 2.5.45 onwards).
      running   -  Number of processes in runnable state (Linux 2.5.45 onwards).
  
  =head1 METHODS
  
  =head2 new()
  
  Call C<new()> to create a new object.
  
      my $lxs = Sys::Statistics::Linux::ProcStats->new;
  
  Maybe you want to store/load the initial statistics to/from a file:
  
      my $lxs = Sys::Statistics::Linux::ProcStats->new(initfile => '/tmp/procstats.yml');
  
  If you set C<initfile> it's not necessary to call sleep before C<get()>.
  
  It's also possible to set the path to the proc filesystem.
  
       Sys::Statistics::Linux::ProcStats->new(
          files => {
              # This is the default
              path    => '/proc',
              loadavg => 'loadavg',
              stat    => 'stat',
          }
      );
  
  =head2 init()
  
  Call C<init()> to initialize the statistics.
  
      $lxs->init;
  
  =head2 get()
  
  Call C<get()> to get the statistics. C<get()> returns the statistics as a hash reference.
  
      my $stat = $lxs->get;
  
  =head2 raw()
  
  Get raw values.
  
  =head1 EXPORTS
  
  No exports.
  
  =head1 SEE ALSO
  
  B<proc(5)>
  
  =head1 REPORTING BUGS
  
  Please report all bugs to <jschulz.cpan(at)bloonix.de>.
  
  =head1 AUTHOR
  
  Jonny Schulz <jschulz.cpan(at)bloonix.de>.
  
  =head1 COPYRIGHT
  
  Copyright (c) 2006, 2007 by Jonny Schulz. All rights reserved.
  
  This program is free software; you can redistribute it and/or modify it under the same terms as Perl itself.
  
  =cut
  
  package Sys::Statistics::Linux::ProcStats;
  
  use strict;
  use warnings;
  use Carp qw(croak);
  use Time::HiRes;
  
  our $VERSION = '0.20';
  
  sub new {
      my $class = shift;
      my $opts  = ref($_[0]) ? shift : {@_};
  
      my %self = (
          files => {
              path    => '/proc',
              loadavg => 'loadavg',
              stat    => 'stat',
          }
      );
  
      if (defined $opts->{initfile}) {
          require YAML::Syck;
          $self{initfile} = $opts->{initfile};
      }
  
      foreach my $file (keys %{ $opts->{files} }) {
          $self{files}{$file} = $opts->{files}->{$file};
      }
  
      return bless \%self, $class;
  }
  
  sub init {
      my $self = shift;
  
      if ($self->{initfile} && -r $self->{initfile}) {
          $self->{init} = YAML::Syck::LoadFile($self->{initfile});
          $self->{time} = delete $self->{init}->{time};
      } else {
          $self->{time} = Time::HiRes::gettimeofday();
          $self->{init} = $self->_load;
      }
  }
  
  sub get {
      my $self  = shift;
      my $class = ref $self;
  
      if (!exists $self->{init}) {
          croak "$class: there are no initial statistics defined";
      }
  
      $self->{stats} = $self->_load;
      $self->_deltas;
  
      if ($self->{initfile}) {
          $self->{init}->{time} = $self->{time};
          YAML::Syck::DumpFile($self->{initfile}, $self->{init});
      }
  
      return $self->{stats};
  }
  
  sub raw {
      my $self = shift;
      my $stat = $self->_load;
  
      return $stat;
  }
  
  #
  # private stuff
  #
  
  sub _load {
      my $self  = shift;
      my $class = ref $self;
      my $file  = $self->{files};
      my $lavg  = $self->_procs;
  
      my $filename = $file->{path} ? "$file->{path}/$file->{loadavg}" : $file->{loadavg};
      open my $fh, '<', $filename or croak "$class: unable to open $filename ($!)";
      ($lavg->{runqueue}, $lavg->{count}) = (split m@/@, (split /\s+/, <$fh>)[3]);
      close($fh);
  
      return $lavg;
  }
  
  sub _procs {
      my $self  = shift;
      my $class = ref $self;
      my $file  = $self->{files};
      my %stat  = ();
  
      my $filename = $file->{path} ? "$file->{path}/$file->{stat}" : $file->{stat};
      open my $fh, '<', $filename or croak "$class: unable to open $filename ($!)";
  
      while (my $line = <$fh>) {
          if ($line =~ /^processes\s+(\d+)/) {
              $stat{new} = $1;
          } elsif ($line =~ /^procs_(blocked|running)\s+(\d+)/) {
              $stat{$1} = $2;
          }
      }
  
      close($fh);
      return \%stat;
  }
  
  sub _deltas {
      my $self  = shift;
      my $class = ref $self;
      my $istat = $self->{init};
      my $lstat = $self->{stats};
      my $time  = Time::HiRes::gettimeofday();
      my $delta = sprintf('%.2f', $time - $self->{time});
      $self->{time} = $time;
  
      if (!defined $istat->{new} || !defined $lstat->{new}) {
          croak "$class: not defined key found 'new'";
      }
      if ($istat->{new} !~ /^\d+\z/ || $lstat->{new} !~ /^\d+\z/) {
          croak "$class: invalid value for key 'new'";
      }
  
      my $new_init = $lstat->{new};
  
      if ($lstat->{new} == $istat->{new} || $istat->{new} > $lstat->{new}) {
          $lstat->{new} = sprintf('%.2f', 0);
      } elsif ($delta > 0) {
          $lstat->{new} = sprintf('%.2f', ($new_init - $istat->{new}) / $delta );
      } else {
          $lstat->{new} = sprintf('%.2f', $new_init - $istat->{new});
      }
  
      $istat->{new} = $new_init;
  }
  
  1;
SYS_STATISTICS_LINUX_PROCSTATS

$fatpacked{"Sys/Statistics/Linux/Processes.pm"} = <<'SYS_STATISTICS_LINUX_PROCESSES';
  =head1 NAME
  
  Sys::Statistics::Linux::Processes - Collect linux process statistics.
  
  =head1 SYNOPSIS
  
      use Sys::Statistics::Linux::Processes;
  
      my $lxs = Sys::Statistics::Linux::Processes->new;
      # or Sys::Statistics::Linux::Processes->new(pids => \@pids)
  
      $lxs->init;
      sleep 1;
      my $stat = $lxs->get;
  
  =head1 DESCRIPTION
  
  Sys::Statistics::Linux::Processes gathers process information from the virtual
  F</proc> filesystem (procfs).
  
  For more information read the documentation of the front-end module
  L<Sys::Statistics::Linux>.
  
  =head1 PROCESS STATISTICS
  
  Generated by F</proc/E<lt>pidE<gt>/stat>, F</proc/E<lt>pidE<gt>/status>,
  F</proc/E<lt>pidE<gt>/cmdline> and F<getpwuid()>.
  
  Note that if F</etc/passwd> isn't readable, the key owner is set to F<N/a>.
  
      ppid      -  The parent process ID of the process.
      nlwp      -  The number of light weight processes that runs by this process.
      owner     -  The owner name of the process.
      pgrp      -  The group ID of the process.
      state     -  The status of the process.
      session   -  The session ID of the process.
      ttynr     -  The tty the process use.
      minflt    -  The number of minor faults the process made.
      cminflt   -  The number of minor faults the child process made.
      mayflt    -  The number of mayor faults the process made.
      cmayflt   -  The number of mayor faults the child process made.
      stime     -  The number of jiffies the process have beed scheduled in kernel mode.
      utime     -  The number of jiffies the process have beed scheduled in user mode.
      ttime     -  The number of jiffies the process have beed scheduled (user + kernel).
      cstime    -  The number of jiffies the process waited for childrens have been scheduled in kernel mode.
      cutime    -  The number of jiffies the process waited for childrens have been scheduled in user mode.
      prior     -  The priority of the process (+15).
      nice      -  The nice level of the process.
      sttime    -  The time in jiffies the process started after system boot.
      actime    -  The time in D:H:M:S (days, hours, minutes, seconds) the process is active.
      vsize     -  The size of virtual memory of the process.
      nswap     -  The size of swap space of the process.
      cnswap    -  The size of swap space of the childrens of the process.
      cpu       -  The CPU number the process was last executed on.
      wchan     -  The "channel" in which the process is waiting.
      fd        -  This is a subhash containing each file which the process has open, named by its file descriptor.
                   0 is standard input, 1 standard output, 2 standard error, etc. Because only the owner or root
                   can read /proc/<pid>/fd this hash could be empty.
      cmd       -  Command of the process.
      cmdline   -  Command line of the process.
  
  Generated by F</proc/E<lt>pidE<gt>/statm>. All statistics provides information
  about memory in pages:
  
      size      -  The total program size of the process.
      resident  -  Number of resident set size, this includes the text, data and stack space.
      share     -  Total size of shared pages of the process.
      trs       -  Total text size of the process.
      drs       -  Total data/stack size of the process.
      lrs       -  Total library size of the process.
      dtp       -  Total size of dirty pages of the process (unused since kernel 2.6).
  
  It's possible to convert pages to bytes or kilobytes. Example - if the pagesize of your
  system is 4kb:
  
      $Sys::Statistics::Linux::Processes::PAGES_TO_BYTES =    0; # pages (default)
      $Sys::Statistics::Linux::Processes::PAGES_TO_BYTES =    4; # convert to kilobytes
      $Sys::Statistics::Linux::Processes::PAGES_TO_BYTES = 4096; # convert to bytes
  
      # or with
      Sys::Statistics::Linux::Processes->new(pages_to_bytes => 4096);
  
  =head1 METHODS
  
  =head2 new()
  
  Call C<new()> to create a new object.
  
      my $lxs = Sys::Statistics::Linux::Processes->new;
  
  It's possible to handoff an array reference with a PID list.
  
      my $lxs = Sys::Statistics::Linux::Processes->new(pids => [ 1, 2, 3 ]);
  
  It's also possible to set the path to the proc filesystem.
  
       Sys::Statistics::Linux::Processes->new(
          files => {
              # This is the default
              path    => '/proc',
              uptime  => 'uptime',
              stat    => 'stat',
              statm   => 'statm',
              status  => 'status',
              cmdline => 'cmdline',
              wchan   => 'wchan',
              fd      => 'fd',
          }
      );
  
  =head2 init()
  
  Call C<init()> to initialize the statistics.
  
      $lxs->init;
  
  =head2 get()
  
  Call C<get()> to get the statistics. C<get()> returns the statistics as a hash reference.
  
      my $stat = $lxs->get;
  
  Note:
  
  Processes that were created between the call of init() and get() are returned as well,
  but the keys minflt, cminflt, mayflt, cmayflt, utime, stime, cutime, and cstime are set
  to the value 0.00 because there are no inititial values to calculate the deltas.
  
  =head2 raw()
  
  Get raw values.
  
  =head1 EXPORTS
  
  No exports.
  
  =head1 SEE ALSO
  
  B<proc(5)>
  
  B<perldoc -f getpwuid>
  
  =head1 REPORTING BUGS
  
  Please report all bugs to <jschulz.cpan(at)bloonix.de>.
  
  =head1 AUTHOR
  
  Jonny Schulz <jschulz.cpan(at)bloonix.de>.
  
  =head1 COPYRIGHT
  
  Copyright (c) 2006, 2007 by Jonny Schulz. All rights reserved.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =cut
  
  package Sys::Statistics::Linux::Processes;
  
  use strict;
  use warnings;
  use Carp qw(croak);
  use Time::HiRes;
  use constant NUMBER => qr/^-{0,1}\d+(?:\.\d+){0,1}\z/;
  
  our $VERSION = '0.32';
  our $PAGES_TO_BYTES = 0;
  
  sub new {
      my $class = shift;
      my $opts  = ref($_[0]) ? shift : {@_};
  
      my %self = (
          files => {
              path    => '/proc',
              uptime  => 'uptime',
              stat    => 'stat',
              statm   => 'statm',
              status  => 'status',
              cmdline => 'cmdline',
              wchan   => 'wchan',
              fd      => 'fd',
          },
      );
  
      if (defined $opts->{pids}) {
          if (ref($opts->{pids}) ne 'ARRAY') {
              croak "$class: not a array reference";
          }
  
          foreach my $pid (@{$opts->{pids}}) {
              if ($pid !~ /^\d+\z/) {
                  croak "$class: pid '$pid' is not a number";
              }
          }
  
          $self{pids} = $opts->{pids};
      }
  
      foreach my $file (keys %{ $opts->{files} }) {
          $self{files}{$file} = $opts->{files}->{$file};
      }
  
      if ($opts->{pages_to_bytes}) {
          $self{pages_to_bytes} = $opts->{pages_to_bytes};
      }
  
      return bless \%self, $class;
  }
  
  sub init {
      my $self = shift;
      $self->{init} = $self->_init;
  }
  
  sub get {
      my $self  = shift;
      my $class = ref $self;
  
      if (!exists $self->{init}) {
          croak "$class: there are no initial statistics defined";
      }
  
      $self->{stats} = $self->_load;
      $self->_deltas;
      return $self->{stats};
  }
  
  sub raw {
      my $self = shift;
      my $stat = $self->_load;
  
      return $stat;
  }
  
  #
  # private stuff
  #
  
  sub _init {
      my $self  = shift;
      my $class = ref $self;
      my $file  = $self->{files};
      my ($pids, %stats);
  
      $stats{time} = Time::HiRes::gettimeofday();
  
      if ($self->{pids}) {
          $pids = $self->{pids};
      } else {
          opendir my $pdir, $file->{path}
              or croak "$class: unable to open directory $file->{path} ($!)";
          $pids = [(grep /^\d+\z/, readdir $pdir)];
          closedir $pdir;
      }
  
      foreach my $pid (@$pids) {
          if (open my $fh, '<', "$file->{path}/$pid/$file->{stat}") {
              @{$stats{$pid}}{qw(
                  minflt cminflt mayflt cmayflt utime
                  stime cutime cstime sttime
              )} = (split /\s+/, <$fh>)[9..16,21];
              close($fh);
          } else {
              delete $stats{$pid};
              next;
          }
      }
  
      return \%stats;
  }
  
  sub _load {
      my $self   = shift;
      my $class  = ref $self;
      my $file   = $self->{files};
      my $uptime = $self->_uptime();
      my ($pids, %stats, %userids);
  
      $stats{time} = Time::HiRes::gettimeofday();
  
      # All PIDs are fetched from the /proc filesystem. If a file cannot be opened
      # of a process, then it can be that the process doesn't exist any more and
      # the hash key will be deleted.
  
      if ($self->{pids}) {
          $pids = $self->{pids};
      } else {
          opendir my $pdir, $file->{path}
              or croak "$class: unable to open directory $file->{path} ($!)";
          $pids = [(grep /^\d+\z/, readdir $pdir)];
          closedir $pdir;
      }
  
      PID: foreach my $pid (@$pids) {
  
          # memory usage for each process
          if (open my $fh, '<', "$file->{path}/$pid/$file->{statm}") {
              #   size       total program size
              #   resident   resident set size
              #   share      shared pages
              #   text       text (code)
              #   lib        library
              #   data       data/stack
              #   dt         dirty pages (unused in Linux 2.6)
              if ($self->{pages_to_bytes}) {
                  @{$stats{$pid}}{qw(size resident share trs lrs drs dtp)}
                      = map { $_ * $self->{pages_to_bytes} } split /\s+/, <$fh>;
              } elsif ($PAGES_TO_BYTES) {
                  @{$stats{$pid}}{qw(size resident share trs lrs drs dtp)}
                      = map { $_ * $PAGES_TO_BYTES } split /\s+/, <$fh>;
              } else {
                  @{$stats{$pid}}{qw(size resident share trs lrs drs dtp)} = split /\s+/, <$fh>;
              }
  
              close($fh);
          } else {
              next PID;
          }
  
          # different other information for each process
          if (open my $fh, '<', "$file->{path}/$pid/$file->{stat}") {
              @{$stats{$pid}}{qw(
                  cmd     state   ppid    pgrp    session ttynr   minflt
                  cminflt mayflt  cmayflt utime   stime   cutime  cstime
                  prior   nice    nlwp    sttime  vsize   nswap   cnswap
                  cpu
              )} = (split /\s+/, <$fh>)[1..6,9..19,21..22,35..36,38];
              close($fh);
          } else {
              delete $stats{$pid};
              next PID;
          }
  
          # calculate the active time of each process
          my ($d, $h, $m, $s) = $self->_calsec(sprintf('%li', $uptime - $stats{$pid}{sttime} / 100));
          $stats{$pid}{actime} = "$d:".sprintf('%02d:%02d:%02d', $h, $m, $s);
  
          # determine the owner of the process
          if (open my $fh, '<', "$file->{path}/$pid/$file->{status}") {
              while (my $line = <$fh>) {
                  next unless $line =~ /^Uid:(?:\s+|\t+)(\d+)/;
                  $stats{$pid}{owner} = getpwuid($1) || 'N/a';
                  last;
              }
              close($fh);
          } else {
              delete $stats{$pid};
              next PID;
          }
  
          # command line for each process
          if (open my $fh, '<', "$file->{path}/$pid/$file->{cmdline}") {
              $stats{$pid}{cmdline} = <$fh>;
              if ($stats{$pid}{cmdline}) {
                  $stats{$pid}{cmdline} =~ s/\0/ /g;
                  $stats{$pid}{cmdline} =~ s/^\s+//;
                  $stats{$pid}{cmdline} =~ s/\s+$//;
                  chomp $stats{$pid}{cmdline};
              }
              $stats{$pid}{cmdline} = 'N/a' unless $stats{$pid}{cmdline};
              close($fh);
          } else {
              delete $stats{$pid};
              next PID;
          }
  
          if (open my $fh, '<', "$file->{path}/$pid/$file->{wchan}") {
              $stats{$pid}{wchan} = <$fh>;
  
              if (defined $stats{$pid}{wchan}) {
                  chomp($stats{$pid}{wchan});
              } else {
                  $stats{$pid}{wchan} = defined;
              }
          } else {
              delete $stats{$pid};
              next PID;
          }
  
          $stats{$pid}{fd} = { };
  
          if (opendir my $dh, "$file->{path}/$pid/$file->{fd}") {
              foreach my $link (grep !/^\.+\z/, readdir($dh)) {
                  if (my $target = readlink("$file->{path}/$pid/$file->{fd}/$link")) {
                      $stats{$pid}{fd}{$link} = $target;
                  }
              }
          }
      }
  
      return \%stats;
  }
  
  sub _deltas {
      my $self   = shift;
      my $class  = ref $self;
      my $istat  = $self->{init};
      my $lstat  = $self->{stats};
      my $uptime = $self->_uptime;
  
      if (!defined $istat->{time} || !defined $lstat->{time}) {
          croak "$class: not defined key found 'time'";
      }
  
      if ($istat->{time} !~ NUMBER || $lstat->{time} !~ NUMBER) {
          croak "$class: invalid value for key 'time'";
      }
  
      my $time = $lstat->{time} - $istat->{time};
      $istat->{time} = $lstat->{time};
      delete $lstat->{time};
  
      for my $pid (keys %{$lstat}) {
          my $ipid = $istat->{$pid};
          my $lpid = $lstat->{$pid};
  
          # yeah, what happends if the start time is different... it seems that a new
          # process with the same process-id were created... for this reason I have to
          # check if the start time is equal!
          if ($ipid && $ipid->{sttime} == $lpid->{sttime}) {
              for my $k (qw(minflt cminflt mayflt cmayflt utime stime cutime cstime)) {
                  if (!defined $ipid->{$k}) {
                      croak "$class: not defined key found '$k'";
                  }
                  if ($ipid->{$k} !~ NUMBER || $lpid->{$k} !~ NUMBER) {
                      croak "$class: invalid value for key '$k'";
                  }
  
                  $lpid->{$k} -= $ipid->{$k};
                  $ipid->{$k} += $lpid->{$k};
  
                  if ($lpid->{$k} > 0 && $time > 0) {
                      $lpid->{$k} = sprintf('%.2f', $lpid->{$k} / $time);
                  } else {
                      $lpid->{$k} = sprintf('%.2f', $lpid->{$k});
                  }
              }
              $lpid->{ttime} = sprintf('%.2f', $lpid->{stime} + $lpid->{utime});
          } else {
              # calculate the statistics since process creation
              for my $k (qw(minflt cminflt mayflt cmayflt utime stime cutime cstime)) {
                  my $p_uptime = $uptime - $lpid->{sttime} / 100;
                  $istat->{$pid}->{$k} = $lpid->{$k};
  
                  if ($p_uptime > 0) {
                      $lpid->{$k} = sprintf('%.2f', $lpid->{$k} / $p_uptime);
                  } else {
                      $lpid->{$k} = sprintf('%.2f', $lpid->{$k});
                  }
              }
              $lpid->{ttime} = sprintf('%.2f', $lpid->{stime} + $lpid->{utime});
              $istat->{$pid}->{sttime} = $lpid->{sttime};
          }
      }
  }
  
  sub _uptime {
      my $self  = shift;
      my $class = ref $self;
      my $file  = $self->{files};
  
      my $filename = $file->{path} ? "$file->{path}/$file->{uptime}" : $file->{uptime};
      open my $fh, '<', $filename or croak "$class: unable to open $filename ($!)";
      my ($up, $idle) = split /\s+/, <$fh>;
      close($fh);
      return $up;
  }
  
  sub _calsec {
      my $self = shift;
      my ($s, $m, $h, $d) = (shift, 0, 0, 0);
      $s >= 86400 and $d = sprintf('%i', $s / 86400) and $s = $s % 86400;
      $s >= 3600  and $h = sprintf('%i', $s / 3600)  and $s = $s % 3600;
      $s >= 60    and $m = sprintf('%i', $s / 60)    and $s = $s % 60;
      return ($d, $h, $m, $s);
  }
  
  1;
SYS_STATISTICS_LINUX_PROCESSES

$fatpacked{"Sys/Statistics/Linux/SockStats.pm"} = <<'SYS_STATISTICS_LINUX_SOCKSTATS';
  =head1 NAME
  
  Sys::Statistics::Linux::SockStats - Collect linux socket statistics.
  
  =head1 SYNOPSIS
  
      use Sys::Statistics::Linux::SockStats;
  
      my $lxs  = Sys::Statistics::Linux::SockStats->new;
      my $stat = $lxs->get;
  
  =head1 DESCRIPTION
  
  Sys::Statistics::Linux::SockStats gathers socket statistics from the virtual F</proc> filesystem (procfs).
  
  For more information read the documentation of the front-end module L<Sys::Statistics::Linux>.
  
  =head1 SOCKET STATISTICS
  
  Generated by F</proc/net/sockstat>.
  
      used    -  Total number of used sockets.
      tcp     -  Number of tcp sockets in use.
      udp     -  Number of udp sockets in use.
      raw     -  Number of raw sockets in use.
      ipfrag  -  Number of ip fragments in use (only available by kernels > 2.2).
  
  =head1 METHODS
  
  =head2 new()
  
  Call C<new()> to create a new object.
  
      my $lxs = Sys::Statistics::Linux::SockStats->new;
  
  It's possible to set the path to the proc filesystem.
  
       Sys::Statistics::Linux::SockStats->new(
          files => {
              # This is the default
              path => '/proc',
              sockstat => 'net/sockstat',
          }
      );
  
  =head2 get()
  
  Call C<get()> to get the statistics. C<get()> returns the statistics as a hash reference.
  
      my $stat = $lxs->get;
  
  =head1 EXPORTS
  
  No exports.
  
  =head1 SEE ALSO
  
  B<proc(5)>
  
  =head1 REPORTING BUGS
  
  Please report all bugs to <jschulz.cpan(at)bloonix.de>.
  
  =head1 AUTHOR
  
  Jonny Schulz <jschulz.cpan(at)bloonix.de>.
  
  =head1 COPYRIGHT
  
  Copyright (c) 2006, 2007 by Jonny Schulz. All rights reserved.
  
  This program is free software; you can redistribute it and/or modify it under the same terms as Perl itself.
  
  =cut
  
  package Sys::Statistics::Linux::SockStats;
  
  use strict;
  use warnings;
  use Carp qw(croak);
  
  our $VERSION = '0.09';
  
  sub new {
      my $class = shift;
      my $opts  = ref($_[0]) ? shift : {@_};
  
      my %self = (
          files => {
              path => '/proc',
              sockstat => 'net/sockstat',
          }
      );
  
      foreach my $file (keys %{ $opts->{files} }) {
          $self{files}{$file} = $opts->{files}->{$file};
      }
  
      return bless \%self, $class;
  }
  
  sub get {
      my $self = shift;
      my $class = ref $self;
      my $file  = $self->{files};
      my %socks = ();
  
      my $filename = $file->{path} ? "$file->{path}/$file->{sockstat}" : $file->{sockstat};
      open my $fh, '<', $filename or croak "$class: unable to open $filename ($!)";
  
      while (my $line = <$fh>) {
          if ($line =~ /sockets: used (\d+)/) {
              $socks{used} = $1;
          } elsif ($line =~ /TCP: inuse (\d+)/) {
              $socks{tcp} = $1;
          } elsif ($line =~ /UDP: inuse (\d+)/) {
              $socks{udp} = $1;
          } elsif ($line =~ /RAW: inuse (\d+)/) {
              $socks{raw} = $1;
          } elsif ($line =~ /FRAG: inuse (\d+)/) {
              $socks{ipfrag} = $1;
          }
      }
  
      close($fh);
      return \%socks;
  }
  
  1;
SYS_STATISTICS_LINUX_SOCKSTATS

$fatpacked{"Sys/Statistics/Linux/SysInfo.pm"} = <<'SYS_STATISTICS_LINUX_SYSINFO';
  =head1 NAME
  
  Sys::Statistics::Linux::SysInfo - Collect linux system information.
  
  =head1 SYNOPSIS
  
      use Sys::Statistics::Linux::SysInfo;
  
      my $lxs  = Sys::Statistics::Linux::SysInfo->new;
      my $info = $lxs->get;
  
  =head1 DESCRIPTION
  
  Sys::Statistics::Linux::SysInfo gathers system information from the virtual F</proc> filesystem (procfs).
  
  For more information read the documentation of the front-end module L<Sys::Statistics::Linux>.
  
  =head1 SYSTEM INFOMATIONS
  
  Generated by F</proc/sys/kernel/{hostname,domainname,ostype,osrelease,version}>
  and F</proc/cpuinfo>, F</proc/meminfo>, F</proc/uptime>, F</proc/net/dev>.
  
      hostname   -  The host name.
      domain     -  The host domain name.
      kernel     -  The kernel name.
      release    -  The kernel release.
      version    -  The kernel version.
      memtotal   -  The total size of memory.
      swaptotal  -  The total size of swap space.
      uptime     -  The uptime of the system.
      idletime   -  The idle time of the system.
      pcpucount  -  The total number of physical CPUs.
      tcpucount  -  The total number of CPUs (cores, hyper threading).
      interfaces -  The interfaces of the system.
      arch       -  The machine hardware name (uname -m).
  
      # countcpus is the same like tcpucount
      countcpus  -  The total (maybe logical) number of CPUs.
  
  C<pcpucount> and C<tcpucount> are really easy to understand. Both values
  are collected from C</proc/cpuinfo>. C<pcpucount> is the number of physical
  CPUs, counted by C<physical id>. C<tcpucount> is just the total number 
  counted by C<processor>.
  
  If you want to get C<uptime> and C<idletime> as raw value you can set
  
      $Sys::Statistics::Linux::SysInfo::RAWTIME = 1;
      # or with
      Sys::Statistics::Linux::SysInfo->new(rawtime => 1)
  
  =head1 METHODS
  
  =head2 new()
  
  Call C<new()> to create a new object.
  
      my $lxs = Sys::Statistics::Linux::SysInfo->new;
  
  =head2 get()
  
  Call C<get()> to get the statistics. C<get()> returns the statistics as a hash reference.
  
      my $info = $lxs->get;
  
  =head1 EXPORTS
  
  No exports.
  
  =head1 SEE ALSO
  
  B<proc(5)>
  
  =head1 REPORTING BUGS
  
  Please report all bugs to <jschulz.cpan(at)bloonix.de>.
  
  =head1 AUTHOR
  
  Jonny Schulz <jschulz.cpan(at)bloonix.de>.
  
  =head1 COPYRIGHT
  
  Copyright (c) 2006, 2007 by Jonny Schulz. All rights reserved.
  
  This program is free software; you can redistribute it and/or modify it under the same terms as Perl itself.
  
  =cut
  
  package Sys::Statistics::Linux::SysInfo;
  
  use strict;
  use warnings;
  use Carp qw(croak);
  
  our $VERSION = '0.13';
  our $RAWTIME = 0;
  
  sub new {
      my $class = shift;
      my $opts  = ref($_[0]) ? shift : {@_};
  
      my %self = (
          files => {
              path     => "/proc",
              meminfo  => "meminfo",
              sysinfo  => "sysinfo",
              cpuinfo  => "cpuinfo",
              uptime   => "uptime",
              hostname => "sys/kernel/hostname",
              domain   => "sys/kernel/domainname",
              kernel   => "sys/kernel/ostype",
              release  => "sys/kernel/osrelease",
              version  => "sys/kernel/version",
              netdev   => "net/dev",
              arch     => [ "/bin/uname", "-m" ],
          }
      );
  
      foreach my $file (keys %{ $opts->{files} }) {
          $self{files}{$file} = $opts->{files}->{$file};
      }
  
      foreach my $param (qw(rawtime cpuinfo)) {
          if ($opts->{$param}) {
              $self{$param} = $opts->{$param};
          }
      }
  
      return bless \%self, $class;
  }
  
  sub get {
      my $self  = shift;
      my $class = ref $self;
      my $file  = $self->{files};
      my $stats = { };
  
      $self->{stats} = $stats;
  
      $self->_get_common;
      $self->_get_meminfo;
      $self->_get_uptime;
      $self->_get_interfaces;
      $self->_get_cpuinfo;
  
      foreach my $key (keys %$stats) {
          chomp $stats->{$key};
          $stats->{$key} =~ s/\t+/ /g;
          $stats->{$key} =~ s/\s+/ /g;
      }
  
     return $stats;
  }
  
  sub _get_common {
      my $self  = shift;
      my $class = ref($self);
      my $file  = $self->{files};
      my $stats = $self->{stats};
  
      for my $x (qw(hostname domain kernel release version)) {
          my $filename = $file->{path} ? "$file->{path}/$file->{$x}" : $file->{$x};
          open my $fh, '<', $filename or croak "$class: unable to open $filename ($!)";
          $stats->{$x} = <$fh>;
          close($fh);
      }
  
      if (-x $file->{arch}->[0] ) {
          my $cmd = join(" ", @{$file->{arch}});
          $stats->{arch} = `$cmd`;
      }
  }
  
  sub _get_meminfo {
      my $self  = shift;
      my $class = ref($self);
      my $file  = $self->{files};
      my $stats = $self->{stats};
  
      my $filename = $file->{path} ? "$file->{path}/$file->{meminfo}" : $file->{meminfo};
      open my $fh, '<', $filename or croak "$class: unable to open $filename ($!)";
  
      while (my $line = <$fh>) {
          if ($line =~ /^MemTotal:\s+(\d+ \w+)/) {
              $stats->{memtotal} = $1;
          } elsif ($line =~ /^SwapTotal:\s+(\d+ \w+)/) {
              $stats->{swaptotal} = $1;
          }
      }
  
      close($fh);
  }
  
  sub _get_cpuinfo {
      my $self  = shift;
      my $class = ref($self);
      my $file  = $self->{files};
      my $stats = $self->{stats};
      my (%cpu, $phyid);
  
      $stats->{countcpus} = 0;
  
      my $filename = $file->{path} ? "$file->{path}/$file->{cpuinfo}" : $file->{cpuinfo};
      open my $fh, '<', $filename or croak "$class: unable to open $filename ($!)";
  
      while (my $line = <$fh>) {
          if ($line =~ /^physical\s+id\s*:\s*(\d+)/) {
              $phyid = $1;
              $cpu{$phyid}{count}++;
          } elsif ($line =~ /^core\s+id\s*:\s*(\d+)/) {
              $cpu{$phyid}{cores}{$1}++;
          } elsif ($line =~ /^processor\s*:\s*\d+/) {       # x86
              $stats->{countcpus}++;
          } elsif ($line =~ /^# processors\s*:\s*(\d+)/) {  # s390
              $stats->{countcpus} = $1;
              last;
          }
      }
  
      close($fh);
  
      $stats->{countcpus} ||= 1; # if it was not possible to match
      $stats->{tcpucount} = $stats->{countcpus};
      $stats->{pcpucount} = scalar keys %cpu || $stats->{countcpus};
  }
  
  sub _get_interfaces {
      my $self  = shift;
      my $class = ref($self);
      my $file  = $self->{files};
      my $stats = $self->{stats};
      my @iface = ();
  
      my $filename = $file->{path} ? "$file->{path}/$file->{netdev}" : $file->{netdev};
      open my $fh, '<', $filename or croak "$class: unable to open $filename ($!)";
      { my $head = <$fh>; }
  
      while (my $line = <$fh>) {
          if ($line =~ /^\s*(\w+):/) {
              push @iface, $1;
          }
      }
  
      close $fh;
  
      $stats->{interfaces} = join(", ", @iface);
      $stats->{interfaces} ||= "";
  }
  
  sub _get_uptime {
      my $self  = shift;
      my $class = ref($self);
      my $file  = $self->{files};
      my $stats = $self->{stats};
  
      my $filename = $file->{path} ? "$file->{path}/$file->{uptime}" : $file->{uptime};
      open my $fh, '<', $filename or croak "$class: unable to open $filename ($!)";
      ($stats->{uptime}, $stats->{idletime}) = split /\s+/, <$fh>;
      close $fh;
  
      if (!$RAWTIME && !$self->{rawtime}) {
          foreach my $x (qw/uptime idletime/) {
              my ($d, $h, $m, $s) = $self->_calsec(sprintf('%li', $stats->{$x}));
              $stats->{$x} = "${d}d ${h}h ${m}m ${s}s";
          }
      }
  }
  
  sub _calsec {
      my $self = shift;
      my ($s, $m, $h, $d) = (shift, 0, 0, 0);
      $s >= 86400 and $d = sprintf('%i',$s / 86400) and $s = $s % 86400;
      $s >= 3600  and $h = sprintf('%i',$s / 3600)  and $s = $s % 3600;
      $s >= 60    and $m = sprintf('%i',$s / 60)    and $s = $s % 60;
      return ($d, $h, $m, $s);
  }
  
  1;
SYS_STATISTICS_LINUX_SYSINFO

$fatpacked{"Time/Zone.pm"} = <<'TIME_ZONE';
  
  package Time::Zone;
  
  =head1 NAME
  
  Time::Zone -- miscellaneous timezone manipulations routines
  
  =head1 SYNOPSIS
  
  	use Time::Zone;
  	print tz2zone();
  	print tz2zone($ENV{'TZ'});
  	print tz2zone($ENV{'TZ'}, time());
  	print tz2zone($ENV{'TZ'}, undef, $isdst);
  	$offset = tz_local_offset();
  	$offset = tz_offset($TZ);
  
  =head1 DESCRIPTION
  
  This is a collection of miscellaneous timezone manipulation routines.
  
  C<tz2zone()> parses the TZ environment variable and returns a timezone
  string suitable for inclusion in L<date(1)>-like output.  It opionally takes
  a timezone string, a time, and a is-dst flag.
  
  C<tz_local_offset()> determins the offset from GMT time in seconds.  It
  only does the calculation once.
  
  C<tz_offset()> determines the offset from GMT in seconds of a specified
  timezone.  
  
  C<tz_name()> determines the name of the timezone based on its offset
  
  =head1 AUTHORS
  
  Graham Barr <gbarr@pobox.com>
  David Muir Sharnoff <muir@idiom.com>
  Paul Foley <paul@ascent.com>
  
  =cut
  
  require 5.002;
  
  require Exporter;
  use Carp;
  use strict;
  use vars qw(@ISA @EXPORT $VERSION @tz_local);
  
  @ISA = qw(Exporter);
  @EXPORT = qw(tz2zone tz_local_offset tz_offset tz_name);
  $VERSION = "2.24";
  
  # Parts stolen from code by Paul Foley <paul@ascent.com>
  
  sub tz2zone (;$$$)
  {
  	my($TZ, $time, $isdst) = @_;
  
  	use vars qw(%tzn_cache);
  
  	$TZ = defined($ENV{'TZ'}) ? ( $ENV{'TZ'} ? $ENV{'TZ'} : 'GMT' ) : ''
  	    unless $TZ;
  
  	# Hack to deal with 'PST8PDT' format of TZ
  	# Note that this can't deal with all the esoteric forms, but it
  	# does recognize the most common: [:]STDoff[DST[off][,rule]]
  
  	if (! defined $isdst) {
  		my $j;
  		$time = time() unless $time;
  		($j, $j, $j, $j, $j, $j, $j, $j, $isdst) = localtime($time);
  	}
  
  	if (defined $tzn_cache{$TZ}->[$isdst]) {
  		return $tzn_cache{$TZ}->[$isdst];
  	}
        
  	if ($TZ =~ /^
  		    ( [^:\d+\-,] {3,} )
  		    ( [+-] ?
  		      \d {1,2}
  		      ( : \d {1,2} ) {0,2} 
  		    )
  		    ( [^\d+\-,] {3,} )?
  		    /x
  	    ) {
  		my $dsttz = defined($4) ? $4 : $1;
  		$TZ = $isdst ? $dsttz : $1;
  		$tzn_cache{$TZ} = [ $1, $dsttz ];
  	} else {
  		$tzn_cache{$TZ} = [ $TZ, $TZ ];
  	}
  	return $TZ;
  }
  
  sub tz_local_offset (;$)
  {
  	my ($time) = @_;
  
  	$time = time() unless $time;
  	my (@l) = localtime($time);
  	my $isdst = $l[8];
  
  	if (defined($tz_local[$isdst])) {
  		return $tz_local[$isdst];
  	}
  
  	$tz_local[$isdst] = &calc_off($time);
  
  	return $tz_local[$isdst];
  }
  
  sub calc_off
  {
  	my ($time) = @_;
  
  	my (@l) = localtime($time);
  	my (@g) = gmtime($time);
  
  	my $off;
  
  	$off =     $l[0] - $g[0]
  		+ ($l[1] - $g[1]) * 60
  		+ ($l[2] - $g[2]) * 3600;
  
  	# subscript 7 is yday.
  
  	if ($l[7] == $g[7]) {
  		# done
  	} elsif ($l[7] == $g[7] + 1) {
  		$off += 86400;
  	} elsif ($l[7] == $g[7] - 1) {
  		$off -= 86400;
  	} elsif ($l[7] < $g[7]) {
  		# crossed over a year boundry!
  		# localtime is beginning of year, gmt is end
  		# therefore local is ahead
  		$off += 86400;
  	} else {
  		$off -= 86400;
  	}
  
  	return $off;
  }
  
  # constants
  
  CONFIG: {
  	use vars qw(%dstZone %zoneOff %dstZoneOff %Zone);
  
  	my @dstZone = (
  	#   "ndt"  =>   -2*3600-1800,	 # Newfoundland Daylight   
  	    "brst" =>   -2*3600,         # Brazil Summer Time (East Daylight)
  	    "adt"  =>   -3*3600,  	 # Atlantic Daylight   
  	    "edt"  =>   -4*3600,  	 # Eastern Daylight
  	    "cdt"  =>   -5*3600,  	 # Central Daylight
  	    "mdt"  =>   -6*3600,  	 # Mountain Daylight
  	    "pdt"  =>   -7*3600,  	 # Pacific Daylight
  	    "akdt" =>   -8*3600,         # Alaska Daylight
  	    "ydt"  =>   -8*3600,  	 # Yukon Daylight
  	    "hdt"  =>   -9*3600,  	 # Hawaii Daylight
  	    "bst"  =>   +1*3600,  	 # British Summer   
  	    "mest" =>   +2*3600,  	 # Middle European Summer   
  	    "metdst" => +2*3600, 	 # Middle European DST
  	    "sst"  =>   +2*3600,  	 # Swedish Summer
  	    "fst"  =>   +2*3600,  	 # French Summer
              "cest" =>   +2*3600,         # Central European Daylight
              "eest" =>   +3*3600,         # Eastern European Summer
              "msd"  =>   +4*3600,         # Moscow Daylight
  	    "wadt" =>   +8*3600,  	 # West Australian Daylight
  	    "kdt"  =>  +10*3600,	 # Korean Daylight
  	#   "cadt" =>  +10*3600+1800,	 # Central Australian Daylight
  	    "aedt" =>  +11*3600,  	 # Eastern Australian Daylight
  	    "eadt" =>  +11*3600,  	 # Eastern Australian Daylight
  	    "nzd"  =>  +13*3600,  	 # New Zealand Daylight   
  	    "nzdt" =>  +13*3600,  	 # New Zealand Daylight   
  	);
  
  	my @Zone = (
  	    "gmt"	=>   0,  	 # Greenwich Mean
  	    "ut"        =>   0,  	 # Universal (Coordinated)
  	    "utc"       =>   0,
  	    "wet"       =>   0,  	 # Western European
  	    "wat"       =>  -1*3600,	 # West Africa
  	    "at"        =>  -2*3600,	 # Azores
  	    "fnt"	=>  -2*3600,	 # Brazil Time (Extreme East - Fernando Noronha)
  	    "brt"	=>  -3*3600,	 # Brazil Time (East Standard - Brasilia)
  	# For completeness.  BST is also British Summer, and GST is also Guam Standard.
  	#   "bst"       =>  -3*3600,	 # Brazil Standard
  	#   "gst"       =>  -3*3600,	 # Greenland Standard
  	#   "nft"       =>  -3*3600-1800,# Newfoundland
  	#   "nst"       =>  -3*3600-1800,# Newfoundland Standard
  	    "mnt"	=>  -4*3600,	 # Brazil Time (West Standard - Manaus)
  	    "ewt"       =>  -4*3600,	 # U.S. Eastern War Time
  	    "ast"       =>  -4*3600,	 # Atlantic Standard
  	    "est"       =>  -5*3600,	 # Eastern Standard
  	    "act"	=>  -5*3600,	 # Brazil Time (Extreme West - Acre)
  	    "cst"       =>  -6*3600,	 # Central Standard
  	    "mst"       =>  -7*3600,	 # Mountain Standard
  	    "pst"       =>  -8*3600,	 # Pacific Standard
  	    "akst"      =>  -9*3600,     # Alaska Standard
  	    "yst"	=>  -9*3600,	 # Yukon Standard
  	    "hst"	=> -10*3600,	 # Hawaii Standard
  	    "cat"	=> -10*3600,	 # Central Alaska
  	    "ahst"	=> -10*3600,	 # Alaska-Hawaii Standard
  	    "nt"	=> -11*3600,	 # Nome
  	    "idlw"	=> -12*3600,	 # International Date Line West
  	    "cet"	=>  +1*3600, 	 # Central European
  	    "mez"	=>  +1*3600, 	 # Central European (German)
  	    "ect"	=>  +1*3600, 	 # Central European (French)
  	    "met"	=>  +1*3600, 	 # Middle European
  	    "mewt"	=>  +1*3600, 	 # Middle European Winter
  	    "swt"	=>  +1*3600, 	 # Swedish Winter
  	    "set"	=>  +1*3600, 	 # Seychelles
  	    "fwt"	=>  +1*3600, 	 # French Winter
  	    "eet"	=>  +2*3600, 	 # Eastern Europe, USSR Zone 1
  	    "ukr"	=>  +2*3600, 	 # Ukraine
  	    "bt"	=>  +3*3600, 	 # Baghdad, USSR Zone 2
              "msk"       =>  +3*3600,     # Moscow
  	#   "it"	=>  +3*3600+1800,# Iran
  	    "zp4"	=>  +4*3600, 	 # USSR Zone 3
  	    "zp5"	=>  +5*3600, 	 # USSR Zone 4
  	#   "ist"	=>  +5*3600+1800,# Indian Standard
  	    "zp6"	=>  +6*3600, 	 # USSR Zone 5
  	# For completeness.  NST is also Newfoundland Stanard, and SST is also Swedish Summer.
  	#   "nst"	=>  +6*3600+1800,# North Sumatra
  	#   "sst"	=>  +7*3600, 	 # South Sumatra, USSR Zone 6
  	#   "jt"	=>  +7*3600+1800,# Java (3pm in Cronusland!)
  	    "wst"	=>  +8*3600, 	 # West Australian Standard
  	    "hkt"	=>  +8*3600, 	 # Hong Kong
  	    "cct"	=>  +8*3600, 	 # China Coast, USSR Zone 7
  	    "jst"	=>  +9*3600,	 # Japan Standard, USSR Zone 8
  	    "kst"	=>  +9*3600,	 # Korean Standard
  	#   "cast"	=>  +9*3600+1800,# Central Australian Standard
  	    "aest"	=> +10*3600,	 # Eastern Australian Standard
  	    "east"	=> +10*3600,	 # Eastern Australian Standard
  	    "gst"	=> +10*3600,	 # Guam Standard, USSR Zone 9
  	    "nzt"	=> +12*3600,	 # New Zealand
  	    "nzst"	=> +12*3600,	 # New Zealand Standard
  	    "idle"	=> +12*3600,	 # International Date Line East
  	);
  
  	%Zone = @Zone;
  	%dstZone = @dstZone;
  	%zoneOff = reverse(@Zone);
  	%dstZoneOff = reverse(@dstZone);
  
  }
  
  sub tz_offset (;$$)
  {
  	my ($zone, $time) = @_;
  
  	return &tz_local_offset($time) unless($zone);
  
  	$time = time() unless $time;
  	my(@l) = localtime($time);
  	my $dst = $l[8];
  
  	$zone = lc $zone;
  
  	if($zone =~ /^(([\-\+])\d\d?)(\d\d)$/) {
  		my $v = $2 . $3;
  		return $1 * 3600 + $v * 60;
  	} elsif (exists $dstZone{$zone} && ($dst || !exists $Zone{$zone})) {
  		return $dstZone{$zone};
  	} elsif(exists $Zone{$zone}) {
  		return $Zone{$zone};
  	}
  	undef;
  }
  
  sub tz_name (;$$)
  {
  	my ($off, $dst) = @_;
  
  	$off = tz_offset()
  		unless(defined $off);
  
  	$dst = (localtime(time))[8]
  		unless(defined $dst);
  
  	if (exists $dstZoneOff{$off} && ($dst || !exists $zoneOff{$off})) {
  		return $dstZoneOff{$off};
  	} elsif (exists $zoneOff{$off}) {
  		return $zoneOff{$off};
  	}
  	sprintf("%+05d", int($off / 60) * 100 + $off % 60);
  }
  
  1;
TIME_ZONE

$fatpacked{"Try/Tiny.pm"} = <<'TRY_TINY';
  package Try::Tiny;
  
  use strict;
  #use warnings;
  
  use vars qw(@EXPORT @EXPORT_OK $VERSION @ISA);
  
  BEGIN {
  	require Exporter;
  	@ISA = qw(Exporter);
  }
  
  $VERSION = "0.07";
  
  $VERSION = eval $VERSION;
  
  @EXPORT = @EXPORT_OK = qw(try catch finally);
  
  $Carp::Internal{+__PACKAGE__}++;
  
  # Need to prototype as @ not $$ because of the way Perl evaluates the prototype.
  # Keeping it at $$ means you only ever get 1 sub because we need to eval in a list
  # context & not a scalar one
  
  sub try (&;@) {
  	my ( $try, @code_refs ) = @_;
  
  	# we need to save this here, the eval block will be in scalar context due
  	# to $failed
  	my $wantarray = wantarray;
  
  	my ( $catch, @finally );
  
  	# find labeled blocks in the argument list.
  	# catch and finally tag the blocks by blessing a scalar reference to them.
  	foreach my $code_ref (@code_refs) {
  		next unless $code_ref;
  
  		my $ref = ref($code_ref);
  
  		if ( $ref eq 'Try::Tiny::Catch' ) {
  			$catch = ${$code_ref};
  		} elsif ( $ref eq 'Try::Tiny::Finally' ) {
  			push @finally, ${$code_ref};
  		} else {
  			use Carp;
  			confess("Unknown code ref type given '${ref}'. Check your usage & try again");
  		}
  	}
  
  	# save the value of $@ so we can set $@ back to it in the beginning of the eval
  	my $prev_error = $@;
  
  	my ( @ret, $error, $failed );
  
  	# FIXME consider using local $SIG{__DIE__} to accumulate all errors. It's
  	# not perfect, but we could provide a list of additional errors for
  	# $catch->();
  
  	{
  		# localize $@ to prevent clobbering of previous value by a successful
  		# eval.
  		local $@;
  
  		# failed will be true if the eval dies, because 1 will not be returned
  		# from the eval body
  		$failed = not eval {
  			$@ = $prev_error;
  
  			# evaluate the try block in the correct context
  			if ( $wantarray ) {
  				@ret = $try->();
  			} elsif ( defined $wantarray ) {
  				$ret[0] = $try->();
  			} else {
  				$try->();
  			};
  
  			return 1; # properly set $fail to false
  		};
  
  		# copy $@ to $error; when we leave this scope, local $@ will revert $@
  		# back to its previous value
  		$error = $@;
  	}
  
  	# set up a scope guard to invoke the finally block at the end
  	my @guards =
      map { Try::Tiny::ScopeGuard->_new($_, $failed ? $error : ()) }
      @finally;
  
  	# at this point $failed contains a true value if the eval died, even if some
  	# destructor overwrote $@ as the eval was unwinding.
  	if ( $failed ) {
  		# if we got an error, invoke the catch block.
  		if ( $catch ) {
  			# This works like given($error), but is backwards compatible and
  			# sets $_ in the dynamic scope for the body of C<$catch>
  			for ($error) {
  				return $catch->($error);
  			}
  
  			# in case when() was used without an explicit return, the C<for>
  			# loop will be aborted and there's no useful return value
  		}
  
  		return;
  	} else {
  		# no failure, $@ is back to what it was, everything is fine
  		return $wantarray ? @ret : $ret[0];
  	}
  }
  
  sub catch (&;@) {
  	my ( $block, @rest ) = @_;
  
  	return (
  		bless(\$block, 'Try::Tiny::Catch'),
  		@rest,
  	);
  }
  
  sub finally (&;@) {
  	my ( $block, @rest ) = @_;
  
  	return (
  		bless(\$block, 'Try::Tiny::Finally'),
  		@rest,
  	);
  }
  
  {
    package Try::Tiny::ScopeGuard;
  
    sub _new {
      shift;
      bless [ @_ ];
    }
  
    sub DESTROY {
      my @guts = @{ shift() };
      my $code = shift @guts;
      $code->(@guts);
    }
  }
  
  __PACKAGE__
  
  __END__
  
  =pod
  
  =head1 NAME
  
  Try::Tiny - minimal try/catch with proper localization of $@
  
  =head1 SYNOPSIS
  
  	# handle errors with a catch handler
  	try {
  		die "foo";
  	} catch {
  		warn "caught error: $_"; # not $@
  	};
  
  	# just silence errors
  	try {
  		die "foo";
  	};
  
  =head1 DESCRIPTION
  
  This module provides bare bones C<try>/C<catch>/C<finally> statements that are designed to
  minimize common mistakes with eval blocks, and NOTHING else.
  
  This is unlike L<TryCatch> which provides a nice syntax and avoids adding
  another call stack layer, and supports calling C<return> from the try block to
  return from the parent subroutine. These extra features come at a cost of a few
  dependencies, namely L<Devel::Declare> and L<Scope::Upper> which are
  occasionally problematic, and the additional catch filtering uses L<Moose>
  type constraints which may not be desirable either.
  
  The main focus of this module is to provide simple and reliable error handling
  for those having a hard time installing L<TryCatch>, but who still want to
  write correct C<eval> blocks without 5 lines of boilerplate each time.
  
  It's designed to work as correctly as possible in light of the various
  pathological edge cases (see L<BACKGROUND>) and to be compatible with any style
  of error values (simple strings, references, objects, overloaded objects, etc).
  
  If the try block dies, it returns the value of the last statement executed in
  the catch block, if there is one. Otherwise, it returns C<undef> in scalar
  context or the empty list in list context. The following two examples both
  assign C<"bar"> to C<$x>.
  
  	my $x = try { die "foo" } catch { "bar" };
  
  	my $x = eval { die "foo" } || "bar";
  
  You can add finally blocks making the following true.
  
  	my $x;
  	try { die 'foo' } finally { $x = 'bar' };
  	try { die 'foo' } catch { warn "Got a die: $_" } finally { $x = 'bar' };
  
  Finally blocks are always executed making them suitable for cleanup code
  which cannot be handled using local.  You can add as many finally blocks to a
  given try block as you like.
  
  =head1 EXPORTS
  
  All functions are exported by default using L<Exporter>.
  
  If you need to rename the C<try>, C<catch> or C<finally> keyword consider using
  L<Sub::Import> to get L<Sub::Exporter>'s flexibility.
  
  =over 4
  
  =item try (&;@)
  
  Takes one mandatory try subroutine, an optional catch subroutine & finally
  subroutine.
  
  The mandatory subroutine is evaluated in the context of an C<eval> block.
  
  If no error occurred the value from the first block is returned, preserving
  list/scalar context.
  
  If there was an error and the second subroutine was given it will be invoked
  with the error in C<$_> (localized) and as that block's first and only
  argument.
  
  C<$@> does B<not> contain the error. Inside the C<catch> block it has the same
  value it had before the C<try> block was executed.
  
  Note that the error may be false, but if that happens the C<catch> block will
  still be invoked.
  
  Once all execution is finished then the finally block if given will execute.
  
  =item catch (&;$)
  
  Intended to be used in the second argument position of C<try>.
  
  Returns a reference to the subroutine it was given but blessed as
  C<Try::Tiny::Catch> which allows try to decode correctly what to do
  with this code reference.
  
  	catch { ... }
  
  Inside the catch block the caught error is stored in C<$_>, while previous
  value of C<$@> is still available for use.  This value may or may not be
  meaningful depending on what happened before the C<try>, but it might be a good
  idea to preserve it in an error stack.
  
  For code that captures C<$@> when throwing new errors (i.e.
  L<Class::Throwable>), you'll need to do:
  
  	local $@ = $_;
  
  =item finally (&;$)
  
    try     { ... }
    catch   { ... }
    finally { ... };
  
  Or
  
    try     { ... }
    finally { ... };
  
  Or even
  
    try     { ... }
    finally { ... }
    catch   { ... };
  
  Intended to be the second or third element of C<try>. Finally blocks are always
  executed in the event of a successful C<try> or if C<catch> is run. This allows
  you to locate cleanup code which cannot be done via C<local()> e.g. closing a file
  handle.
  
  When invoked, the finally block is passed the error that was caught.  If no
  error was caught, it is passed nothing.  In other words, the following code
  does just what you would expect:
  
    try {
      die_sometimes();
    } catch {
      # ...code run in case of error
    } finally {
      if (@_) {
        print "The try block died with: @_\n";
      } else {
        print "The try block ran without error.\n";
      }
    };
  
  B<You must always do your own error handling in the finally block>. C<Try::Tiny> will
  not do anything about handling possible errors coming from code located in these
  blocks.
  
  In the same way C<catch()> blesses the code reference this subroutine does the same
  except it bless them as C<Try::Tiny::Finally>.
  
  =back
  
  =head1 BACKGROUND
  
  There are a number of issues with C<eval>.
  
  =head2 Clobbering $@
  
  When you run an eval block and it succeeds, C<$@> will be cleared, potentially
  clobbering an error that is currently being caught.
  
  This causes action at a distance, clearing previous errors your caller may have
  not yet handled.
  
  C<$@> must be properly localized before invoking C<eval> in order to avoid this
  issue.
  
  More specifically, C<$@> is clobbered at the beginning of the C<eval>, which
  also makes it impossible to capture the previous error before you die (for
  instance when making exception objects with error stacks).
  
  For this reason C<try> will actually set C<$@> to its previous value (before
  the localization) in the beginning of the C<eval> block.
  
  =head2 Localizing $@ silently masks errors
  
  Inside an eval block C<die> behaves sort of like:
  
  	sub die {
  		$@ = $_[0];
  		return_undef_from_eval();
  	}
  
  This means that if you were polite and localized C<$@> you can't die in that
  scope, or your error will be discarded (printing "Something's wrong" instead).
  
  The workaround is very ugly:
  
  	my $error = do {
  		local $@;
  		eval { ... };
  		$@;
  	};
  
  	...
  	die $error;
  
  =head2 $@ might not be a true value
  
  This code is wrong:
  
  	if ( $@ ) {
  		...
  	}
  
  because due to the previous caveats it may have been unset.
  
  C<$@> could also be an overloaded error object that evaluates to false, but
  that's asking for trouble anyway.
  
  The classic failure mode is:
  
  	sub Object::DESTROY {
  		eval { ... }
  	}
  
  	eval {
  		my $obj = Object->new;
  
  		die "foo";
  	};
  
  	if ( $@ ) {
  
  	}
  
  In this case since C<Object::DESTROY> is not localizing C<$@> but still uses
  C<eval>, it will set C<$@> to C<"">.
  
  The destructor is called when the stack is unwound, after C<die> sets C<$@> to
  C<"foo at Foo.pm line 42\n">, so by the time C<if ( $@ )> is evaluated it has
  been cleared by C<eval> in the destructor.
  
  The workaround for this is even uglier than the previous ones. Even though we
  can't save the value of C<$@> from code that doesn't localize, we can at least
  be sure the eval was aborted due to an error:
  
  	my $failed = not eval {
  		...
  
  		return 1;
  	};
  
  This is because an C<eval> that caught a C<die> will always return a false
  value.
  
  =head1 SHINY SYNTAX
  
  Using Perl 5.10 you can use L<perlsyn/"Switch statements">.
  
  The C<catch> block is invoked in a topicalizer context (like a C<given> block),
  but note that you can't return a useful value from C<catch> using the C<when>
  blocks without an explicit C<return>.
  
  This is somewhat similar to Perl 6's C<CATCH> blocks. You can use it to
  concisely match errors:
  
  	try {
  		require Foo;
  	} catch {
  		when (/^Can't locate .*?\.pm in \@INC/) { } # ignore
  		default { die $_ }
  	};
  
  =head1 CAVEATS
  
  =over 4
  
  =item *
  
  C<@_> is not available within the C<try> block, so you need to copy your
  arglist. In case you want to work with argument values directly via C<@_>
  aliasing (i.e. allow C<$_[1] = "foo">), you need to pass C<@_> by reference:
  
  	sub foo {
  		my ( $self, @args ) = @_;
  		try { $self->bar(@args) }
  	}
  
  or
  
  	sub bar_in_place {
  		my $self = shift;
  		my $args = \@_;
  		try { $_ = $self->bar($_) for @$args }
  	}
  
  =item *
  
  C<return> returns from the C<try> block, not from the parent sub (note that
  this is also how C<eval> works, but not how L<TryCatch> works):
  
  	sub bar {
  		try { return "foo" };
  		return "baz";
  	}
  
  	say bar(); # "baz"
  
  =item *
  
  C<try> introduces another caller stack frame. L<Sub::Uplevel> is not used. L<Carp>
  will not report this when using full stack traces, though, because
  C<%Carp::Internal> is used. This lack of magic is considered a feature.
  
  =item *
  
  The value of C<$_> in the C<catch> block is not guaranteed to be the value of
  the exception thrown (C<$@>) in the C<try> block.  There is no safe way to
  ensure this, since C<eval> may be used unhygenically in destructors.  The only
  guarantee is that the C<catch> will be called if an exception is thrown.
  
  =item *
  
  The return value of the C<catch> block is not ignored, so if testing the result
  of the expression for truth on success, be sure to return a false value from
  the C<catch> block:
  
  	my $obj = try {
  		MightFail->new;
  	} catch {
  		...
  
  		return; # avoid returning a true value;
  	};
  
  	return unless $obj;
  
  =item *
  
  C<$SIG{__DIE__}> is still in effect.
  
  Though it can be argued that C<$SIG{__DIE__}> should be disabled inside of
  C<eval> blocks, since it isn't people have grown to rely on it. Therefore in
  the interests of compatibility, C<try> does not disable C<$SIG{__DIE__}> for
  the scope of the error throwing code.
  
  =item *
  
  Lexical C<$_> may override the one set by C<catch>.
  
  For example Perl 5.10's C<given> form uses a lexical C<$_>, creating some
  confusing behavior:
  
  	given ($foo) {
  		when (...) {
  			try {
  				...
  			} catch {
  				warn $_; # will print $foo, not the error
  				warn $_[0]; # instead, get the error like this
  			}
  		}
  	}
  
  =back
  
  =head1 SEE ALSO
  
  =over 4
  
  =item L<TryCatch>
  
  Much more feature complete, more convenient semantics, but at the cost of
  implementation complexity.
  
  =item L<autodie>
  
  Automatic error throwing for builtin functions and more. Also designed to
  work well with C<given>/C<when>.
  
  =item L<Throwable>
  
  A lightweight role for rolling your own exception classes.
  
  =item L<Error>
  
  Exception object implementation with a C<try> statement. Does not localize
  C<$@>.
  
  =item L<Exception::Class::TryCatch>
  
  Provides a C<catch> statement, but properly calling C<eval> is your
  responsibility.
  
  The C<try> keyword pushes C<$@> onto an error stack, avoiding some of the
  issues with C<$@>, but you still need to localize to prevent clobbering.
  
  =back
  
  =head1 LIGHTNING TALK
  
  I gave a lightning talk about this module, you can see the slides (Firefox
  only):
  
  L<http://nothingmuch.woobling.org/talks/takahashi.xul?data=yapc_asia_2009/try_tiny.txt>
  
  Or read the source:
  
  L<http://nothingmuch.woobling.org/talks/yapc_asia_2009/try_tiny.yml>
  
  =head1 VERSION CONTROL
  
  L<http://github.com/nothingmuch/try-tiny/>
  
  =head1 AUTHOR
  
  Yuval Kogman E<lt>nothingmuch@woobling.orgE<gt>
  
  =head1 COPYRIGHT
  
  	Copyright (c) 2009 Yuval Kogman. All rights reserved.
  	This program is free software; you can redistribute
  	it and/or modify it under the terms of the MIT license.
  
  =cut
  
TRY_TINY

$fatpacked{"i386-linux-thread-multi/Cwd.pm"} = <<'I386-LINUX-THREAD-MULTI_CWD';
  package Cwd;
  
  =head1 NAME
  
  Cwd - get pathname of current working directory
  
  =head1 SYNOPSIS
  
      use Cwd;
      my $dir = getcwd;
  
      use Cwd 'abs_path';
      my $abs_path = abs_path($file);
  
  =head1 DESCRIPTION
  
  This module provides functions for determining the pathname of the
  current working directory.  It is recommended that getcwd (or another
  *cwd() function) be used in I<all> code to ensure portability.
  
  By default, it exports the functions cwd(), getcwd(), fastcwd(), and
  fastgetcwd() (and, on Win32, getdcwd()) into the caller's namespace.  
  
  
  =head2 getcwd and friends
  
  Each of these functions are called without arguments and return the
  absolute path of the current working directory.
  
  =over 4
  
  =item getcwd
  
      my $cwd = getcwd();
  
  Returns the current working directory.
  
  Re-implements the getcwd(3) (or getwd(3)) functions in Perl.
  
  =item cwd
  
      my $cwd = cwd();
  
  The cwd() is the most natural form for the current architecture. For
  most systems it is identical to `pwd` (but without the trailing line
  terminator).
  
  =item fastcwd
  
      my $cwd = fastcwd();
  
  A more dangerous version of getcwd(), but potentially faster.
  
  It might conceivably chdir() you out of a directory that it can't
  chdir() you back into.  If fastcwd encounters a problem it will return
  undef but will probably leave you in a different directory.  For a
  measure of extra security, if everything appears to have worked, the
  fastcwd() function will check that it leaves you in the same directory
  that it started in. If it has changed it will C<die> with the message
  "Unstable directory path, current directory changed
  unexpectedly". That should never happen.
  
  =item fastgetcwd
  
    my $cwd = fastgetcwd();
  
  The fastgetcwd() function is provided as a synonym for cwd().
  
  =item getdcwd
  
      my $cwd = getdcwd();
      my $cwd = getdcwd('C:');
  
  The getdcwd() function is also provided on Win32 to get the current working
  directory on the specified drive, since Windows maintains a separate current
  working directory for each drive.  If no drive is specified then the current
  drive is assumed.
  
  This function simply calls the Microsoft C library _getdcwd() function.
  
  =back
  
  
  =head2 abs_path and friends
  
  These functions are exported only on request.  They each take a single
  argument and return the absolute pathname for it.  If no argument is
  given they'll use the current working directory.
  
  =over 4
  
  =item abs_path
  
    my $abs_path = abs_path($file);
  
  Uses the same algorithm as getcwd().  Symbolic links and relative-path
  components ("." and "..") are resolved to return the canonical
  pathname, just like realpath(3).
  
  =item realpath
  
    my $abs_path = realpath($file);
  
  A synonym for abs_path().
  
  =item fast_abs_path
  
    my $abs_path = fast_abs_path($file);
  
  A more dangerous, but potentially faster version of abs_path.
  
  =back
  
  =head2 $ENV{PWD}
  
  If you ask to override your chdir() built-in function, 
  
    use Cwd qw(chdir);
  
  then your PWD environment variable will be kept up to date.  Note that
  it will only be kept up to date if all packages which use chdir import
  it from Cwd.
  
  
  =head1 NOTES
  
  =over 4
  
  =item *
  
  Since the path seperators are different on some operating systems ('/'
  on Unix, ':' on MacPerl, etc...) we recommend you use the File::Spec
  modules wherever portability is a concern.
  
  =item *
  
  Actually, on Mac OS, the C<getcwd()>, C<fastgetcwd()> and C<fastcwd()>
  functions  are all aliases for the C<cwd()> function, which, on Mac OS,
  calls `pwd`. Likewise, the C<abs_path()> function is an alias for
  C<fast_abs_path()>.
  
  =back
  
  =head1 AUTHOR
  
  Originally by the perl5-porters.
  
  Maintained by Ken Williams <KWILLIAMS@cpan.org>
  
  =head1 COPYRIGHT
  
  Copyright (c) 2004 by the Perl 5 Porters.  All rights reserved.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  Portions of the C code in this library are copyright (c) 1994 by the
  Regents of the University of California.  All rights reserved.  The
  license on this code is compatible with the licensing of the rest of
  the distribution - please see the source code in F<Cwd.xs> for the
  details.
  
  =head1 SEE ALSO
  
  L<File::chdir>
  
  =cut
  
  use strict;
  use Exporter;
  use vars qw(@ISA @EXPORT @EXPORT_OK $VERSION);
  
  $VERSION = '3.12';
  
  @ISA = qw/ Exporter /;
  @EXPORT = qw(cwd getcwd fastcwd fastgetcwd);
  push @EXPORT, qw(getdcwd) if $^O eq 'MSWin32';
  @EXPORT_OK = qw(chdir abs_path fast_abs_path realpath fast_realpath);
  
  # sys_cwd may keep the builtin command
  
  # All the functionality of this module may provided by builtins,
  # there is no sense to process the rest of the file.
  # The best choice may be to have this in BEGIN, but how to return from BEGIN?
  
  if ($^O eq 'os2') {
      local $^W = 0;
  
      *cwd                = defined &sys_cwd ? \&sys_cwd : \&_os2_cwd;
      *getcwd             = \&cwd;
      *fastgetcwd         = \&cwd;
      *fastcwd            = \&cwd;
  
      *fast_abs_path      = \&sys_abspath if defined &sys_abspath;
      *abs_path           = \&fast_abs_path;
      *realpath           = \&fast_abs_path;
      *fast_realpath      = \&fast_abs_path;
  
      return 1;
  }
  
  # If loading the XS stuff doesn't work, we can fall back to pure perl
  eval {
    if ( $] >= 5.006 ) {
      require XSLoader;
      XSLoader::load( __PACKAGE__, $VERSION );
    } else {
      require DynaLoader;
      push @ISA, 'DynaLoader';
      __PACKAGE__->bootstrap( $VERSION );
    }
  };
  
  # Must be after the DynaLoader stuff:
  $VERSION = eval $VERSION;
  
  # Big nasty table of function aliases
  my %METHOD_MAP =
    (
     VMS =>
     {
      cwd			=> '_vms_cwd',
      getcwd		=> '_vms_cwd',
      fastcwd		=> '_vms_cwd',
      fastgetcwd		=> '_vms_cwd',
      abs_path		=> '_vms_abs_path',
      fast_abs_path	=> '_vms_abs_path',
     },
  
     MSWin32 =>
     {
      # We assume that &_NT_cwd is defined as an XSUB or in the core.
      cwd			=> '_NT_cwd',
      getcwd		=> '_NT_cwd',
      fastcwd		=> '_NT_cwd',
      fastgetcwd		=> '_NT_cwd',
      abs_path		=> 'fast_abs_path',
      realpath		=> 'fast_abs_path',
     },
  
     dos => 
     {
      cwd			=> '_dos_cwd',
      getcwd		=> '_dos_cwd',
      fastgetcwd		=> '_dos_cwd',
      fastcwd		=> '_dos_cwd',
      abs_path		=> 'fast_abs_path',
     },
  
     qnx =>
     {
      cwd			=> '_qnx_cwd',
      getcwd		=> '_qnx_cwd',
      fastgetcwd		=> '_qnx_cwd',
      fastcwd		=> '_qnx_cwd',
      abs_path		=> '_qnx_abs_path',
      fast_abs_path	=> '_qnx_abs_path',
     },
  
     cygwin =>
     {
      getcwd		=> 'cwd',
      fastgetcwd		=> 'cwd',
      fastcwd		=> 'cwd',
      abs_path		=> 'fast_abs_path',
      realpath		=> 'fast_abs_path',
     },
  
     epoc =>
     {
      cwd			=> '_epoc_cwd',
      getcwd	        => '_epoc_cwd',
      fastgetcwd		=> '_epoc_cwd',
      fastcwd		=> '_epoc_cwd',
      abs_path		=> 'fast_abs_path',
     },
  
     MacOS =>
     {
      getcwd		=> 'cwd',
      fastgetcwd		=> 'cwd',
      fastcwd		=> 'cwd',
      abs_path		=> 'fast_abs_path',
     },
    );
  
  $METHOD_MAP{NT} = $METHOD_MAP{MSWin32};
  $METHOD_MAP{nto} = $METHOD_MAP{qnx};
  
  
  # Find the pwd command in the expected locations.  We assume these
  # are safe.  This prevents _backtick_pwd() consulting $ENV{PATH}
  # so everything works under taint mode.
  my $pwd_cmd;
  foreach my $try ('/bin/pwd',
  		 '/usr/bin/pwd',
  		 '/QOpenSys/bin/pwd', # OS/400 PASE.
  		) {
  
      if( -x $try ) {
          $pwd_cmd = $try;
          last;
      }
  }
  unless ($pwd_cmd) {
      # Isn't this wrong?  _backtick_pwd() will fail if somenone has
      # pwd in their path but it is not /bin/pwd or /usr/bin/pwd?
      # See [perl #16774]. --jhi
      $pwd_cmd = 'pwd';
  }
  
  # Lazy-load Carp
  sub _carp  { require Carp; Carp::carp(@_)  }
  sub _croak { require Carp; Carp::croak(@_) }
  
  # The 'natural and safe form' for UNIX (pwd may be setuid root)
  sub _backtick_pwd {
      # Localize %ENV entries in a way that won't create new hash keys
      my @localize = grep exists $ENV{$_}, qw(PATH IFS CDPATH ENV BASH_ENV);
      local @ENV{@localize};
      
      my $cwd = `$pwd_cmd`;
      # Belt-and-suspenders in case someone said "undef $/".
      local $/ = "\n";
      # `pwd` may fail e.g. if the disk is full
      chomp($cwd) if defined $cwd;
      $cwd;
  }
  
  # Since some ports may predefine cwd internally (e.g., NT)
  # we take care not to override an existing definition for cwd().
  
  unless ($METHOD_MAP{$^O}{cwd} or defined &cwd) {
      # The pwd command is not available in some chroot(2)'ed environments
      my $sep = $Config::Config{path_sep} || ':';
      my $os = $^O;  # Protect $^O from tainting
      if( $os eq 'MacOS' || (defined $ENV{PATH} &&
  			   $os ne 'MSWin32' &&  # no pwd on Windows
  			   grep { -x "$_/pwd" } split($sep, $ENV{PATH})) )
      {
  	*cwd = \&_backtick_pwd;
      }
      else {
  	*cwd = \&getcwd;
      }
  }
  
  # set a reasonable (and very safe) default for fastgetcwd, in case it
  # isn't redefined later (20001212 rspier)
  *fastgetcwd = \&cwd;
  
  # By Brandon S. Allbery
  #
  # Usage: $cwd = getcwd();
  
  sub getcwd
  {
      abs_path('.');
  }
  
  
  # By John Bazik
  #
  # Usage: $cwd = &fastcwd;
  #
  # This is a faster version of getcwd.  It's also more dangerous because
  # you might chdir out of a directory that you can't chdir back into.
      
  sub fastcwd_ {
      my($odev, $oino, $cdev, $cino, $tdev, $tino);
      my(@path, $path);
      local(*DIR);
  
      my($orig_cdev, $orig_cino) = stat('.');
      ($cdev, $cino) = ($orig_cdev, $orig_cino);
      for (;;) {
  	my $direntry;
  	($odev, $oino) = ($cdev, $cino);
  	CORE::chdir('..') || return undef;
  	($cdev, $cino) = stat('.');
  	last if $odev == $cdev && $oino == $cino;
  	opendir(DIR, '.') || return undef;
  	for (;;) {
  	    $direntry = readdir(DIR);
  	    last unless defined $direntry;
  	    next if $direntry eq '.';
  	    next if $direntry eq '..';
  
  	    ($tdev, $tino) = lstat($direntry);
  	    last unless $tdev != $odev || $tino != $oino;
  	}
  	closedir(DIR);
  	return undef unless defined $direntry; # should never happen
  	unshift(@path, $direntry);
      }
      $path = '/' . join('/', @path);
      if ($^O eq 'apollo') { $path = "/".$path; }
      # At this point $path may be tainted (if tainting) and chdir would fail.
      # Untaint it then check that we landed where we started.
      $path =~ /^(.*)\z/s		# untaint
  	&& CORE::chdir($1) or return undef;
      ($cdev, $cino) = stat('.');
      die "Unstable directory path, current directory changed unexpectedly"
  	if $cdev != $orig_cdev || $cino != $orig_cino;
      $path;
  }
  if (not defined &fastcwd) { *fastcwd = \&fastcwd_ }
  
  
  # Keeps track of current working directory in PWD environment var
  # Usage:
  #	use Cwd 'chdir';
  #	chdir $newdir;
  
  my $chdir_init = 0;
  
  sub chdir_init {
      if ($ENV{'PWD'} and $^O ne 'os2' and $^O ne 'dos' and $^O ne 'MSWin32') {
  	my($dd,$di) = stat('.');
  	my($pd,$pi) = stat($ENV{'PWD'});
  	if (!defined $dd or !defined $pd or $di != $pi or $dd != $pd) {
  	    $ENV{'PWD'} = cwd();
  	}
      }
      else {
  	my $wd = cwd();
  	$wd = Win32::GetFullPathName($wd) if $^O eq 'MSWin32';
  	$ENV{'PWD'} = $wd;
      }
      # Strip an automounter prefix (where /tmp_mnt/foo/bar == /foo/bar)
      if ($^O ne 'MSWin32' and $ENV{'PWD'} =~ m|(/[^/]+(/[^/]+/[^/]+))(.*)|s) {
  	my($pd,$pi) = stat($2);
  	my($dd,$di) = stat($1);
  	if (defined $pd and defined $dd and $di == $pi and $dd == $pd) {
  	    $ENV{'PWD'}="$2$3";
  	}
      }
      $chdir_init = 1;
  }
  
  sub chdir {
      my $newdir = @_ ? shift : '';	# allow for no arg (chdir to HOME dir)
      $newdir =~ s|///*|/|g unless $^O eq 'MSWin32';
      chdir_init() unless $chdir_init;
      my $newpwd;
      if ($^O eq 'MSWin32') {
  	# get the full path name *before* the chdir()
  	$newpwd = Win32::GetFullPathName($newdir);
      }
  
      return 0 unless CORE::chdir $newdir;
  
      if ($^O eq 'VMS') {
  	return $ENV{'PWD'} = $ENV{'DEFAULT'}
      }
      elsif ($^O eq 'MacOS') {
  	return $ENV{'PWD'} = cwd();
      }
      elsif ($^O eq 'MSWin32') {
  	$ENV{'PWD'} = $newpwd;
  	return 1;
      }
  
      if ($newdir =~ m#^/#s) {
  	$ENV{'PWD'} = $newdir;
      } else {
  	my @curdir = split(m#/#,$ENV{'PWD'});
  	@curdir = ('') unless @curdir;
  	my $component;
  	foreach $component (split(m#/#, $newdir)) {
  	    next if $component eq '.';
  	    pop(@curdir),next if $component eq '..';
  	    push(@curdir,$component);
  	}
  	$ENV{'PWD'} = join('/',@curdir) || '/';
      }
      1;
  }
  
  
  sub _perl_abs_path
  {
      my $start = @_ ? shift : '.';
      my($dotdots, $cwd, @pst, @cst, $dir, @tst);
  
      unless (@cst = stat( $start ))
      {
  	_carp("stat($start): $!");
  	return '';
      }
  
      unless (-d _) {
          # Make sure we can be invoked on plain files, not just directories.
          # NOTE that this routine assumes that '/' is the only directory separator.
  	
          my ($dir, $file) = $start =~ m{^(.*)/(.+)$}
  	    or return cwd() . '/' . $start;
  	
  	# Can't use "-l _" here, because the previous stat was a stat(), not an lstat().
  	if (-l $start) {
  	    my $link_target = readlink($start);
  	    die "Can't resolve link $start: $!" unless defined $link_target;
  	    
  	    require File::Spec;
              $link_target = $dir . '/' . $link_target
                  unless File::Spec->file_name_is_absolute($link_target);
  	    
  	    return abs_path($link_target);
  	}
  	
  	return $dir ? abs_path($dir) . "/$file" : "/$file";
      }
  
      $cwd = '';
      $dotdots = $start;
      do
      {
  	$dotdots .= '/..';
  	@pst = @cst;
  	local *PARENT;
  	unless (opendir(PARENT, $dotdots))
  	{
  	    _carp("opendir($dotdots): $!");
  	    return '';
  	}
  	unless (@cst = stat($dotdots))
  	{
  	    _carp("stat($dotdots): $!");
  	    closedir(PARENT);
  	    return '';
  	}
  	if ($pst[0] == $cst[0] && $pst[1] == $cst[1])
  	{
  	    $dir = undef;
  	}
  	else
  	{
  	    do
  	    {
  		unless (defined ($dir = readdir(PARENT)))
  	        {
  		    _carp("readdir($dotdots): $!");
  		    closedir(PARENT);
  		    return '';
  		}
  		$tst[0] = $pst[0]+1 unless (@tst = lstat("$dotdots/$dir"))
  	    }
  	    while ($dir eq '.' || $dir eq '..' || $tst[0] != $pst[0] ||
  		   $tst[1] != $pst[1]);
  	}
  	$cwd = (defined $dir ? "$dir" : "" ) . "/$cwd" ;
  	closedir(PARENT);
      } while (defined $dir);
      chop($cwd) unless $cwd eq '/'; # drop the trailing /
      $cwd;
  }
  
  
  my $Curdir;
  sub fast_abs_path {
      local $ENV{PWD} = $ENV{PWD} || ''; # Guard against clobberage
      my $cwd = getcwd();
      require File::Spec;
      my $path = @_ ? shift : ($Curdir ||= File::Spec->curdir);
  
      # Detaint else we'll explode in taint mode.  This is safe because
      # we're not doing anything dangerous with it.
      ($path) = $path =~ /(.*)/;
      ($cwd)  = $cwd  =~ /(.*)/;
  
      unless (-e $path) {
   	_croak("$path: No such file or directory");
      }
  
      unless (-d _) {
          # Make sure we can be invoked on plain files, not just directories.
  	
  	my ($vol, $dir, $file) = File::Spec->splitpath($path);
  	return File::Spec->catfile($cwd, $path) unless length $dir;
  
  	if (-l $path) {
  	    my $link_target = readlink($path);
  	    die "Can't resolve link $path: $!" unless defined $link_target;
  	    
  	    $link_target = File::Spec->catpath($vol, $dir, $link_target)
                  unless File::Spec->file_name_is_absolute($link_target);
  	    
  	    return fast_abs_path($link_target);
  	}
  	
  	return $dir eq File::Spec->rootdir
  	  ? File::Spec->catpath($vol, $dir, $file)
  	  : fast_abs_path(File::Spec->catpath($vol, $dir, '')) . '/' . $file;
      }
  
      if (!CORE::chdir($path)) {
   	_croak("Cannot chdir to $path: $!");
      }
      my $realpath = getcwd();
      if (! ((-d $cwd) && (CORE::chdir($cwd)))) {
   	_croak("Cannot chdir back to $cwd: $!");
      }
      $realpath;
  }
  
  # added function alias to follow principle of least surprise
  # based on previous aliasing.  --tchrist 27-Jan-00
  *fast_realpath = \&fast_abs_path;
  
  
  # --- PORTING SECTION ---
  
  # VMS: $ENV{'DEFAULT'} points to default directory at all times
  # 06-Mar-1996  Charles Bailey  bailey@newman.upenn.edu
  # Note: Use of Cwd::chdir() causes the logical name PWD to be defined
  #   in the process logical name table as the default device and directory
  #   seen by Perl. This may not be the same as the default device
  #   and directory seen by DCL after Perl exits, since the effects
  #   the CRTL chdir() function persist only until Perl exits.
  
  sub _vms_cwd {
      return $ENV{'DEFAULT'};
  }
  
  sub _vms_abs_path {
      return $ENV{'DEFAULT'} unless @_;
  
      # may need to turn foo.dir into [.foo]
      my $path = VMS::Filespec::pathify($_[0]);
      $path = $_[0] unless defined $path;
  
      return VMS::Filespec::rmsexpand($path);
  }
  
  sub _os2_cwd {
      $ENV{'PWD'} = `cmd /c cd`;
      chomp $ENV{'PWD'};
      $ENV{'PWD'} =~ s:\\:/:g ;
      return $ENV{'PWD'};
  }
  
  sub _win32_cwd {
      $ENV{'PWD'} = Win32::GetCwd();
      $ENV{'PWD'} =~ s:\\:/:g ;
      return $ENV{'PWD'};
  }
  
  *_NT_cwd = defined &Win32::GetCwd ? \&_win32_cwd : \&_os2_cwd;
  
  sub _dos_cwd {
      if (!defined &Dos::GetCwd) {
          $ENV{'PWD'} = `command /c cd`;
          chomp $ENV{'PWD'};
          $ENV{'PWD'} =~ s:\\:/:g ;
      } else {
          $ENV{'PWD'} = Dos::GetCwd();
      }
      return $ENV{'PWD'};
  }
  
  sub _qnx_cwd {
  	local $ENV{PATH} = '';
  	local $ENV{CDPATH} = '';
  	local $ENV{ENV} = '';
      $ENV{'PWD'} = `/usr/bin/fullpath -t`;
      chomp $ENV{'PWD'};
      return $ENV{'PWD'};
  }
  
  sub _qnx_abs_path {
  	local $ENV{PATH} = '';
  	local $ENV{CDPATH} = '';
  	local $ENV{ENV} = '';
      my $path = @_ ? shift : '.';
      local *REALPATH;
  
      defined( open(REALPATH, '-|') || exec '/usr/bin/fullpath', '-t', $path ) or
        die "Can't open /usr/bin/fullpath: $!";
      my $realpath = <REALPATH>;
      close REALPATH;
      chomp $realpath;
      return $realpath;
  }
  
  sub _epoc_cwd {
      $ENV{'PWD'} = EPOC::getcwd();
      return $ENV{'PWD'};
  }
  
  
  # Now that all the base-level functions are set up, alias the
  # user-level functions to the right places
  
  if (exists $METHOD_MAP{$^O}) {
    my $map = $METHOD_MAP{$^O};
    foreach my $name (keys %$map) {
      local $^W = 0;  # assignments trigger 'subroutine redefined' warning
      no strict 'refs';
      *{$name} = \&{$map->{$name}};
    }
  }
  
  # In case the XS version doesn't load.
  *abs_path = \&_perl_abs_path unless defined &abs_path;
  
  # added function alias for those of us more
  # used to the libc function.  --tchrist 27-Jan-00
  *realpath = \&abs_path;
  
  1;
I386-LINUX-THREAD-MULTI_CWD

$fatpacked{"i386-linux-thread-multi/Data/Dumper.pm"} = <<'I386-LINUX-THREAD-MULTI_DATA_DUMPER';
  #
  # Data/Dumper.pm
  #
  # convert perl data structures into perl syntax suitable for both printing
  # and eval
  #
  # Documentation at the __END__
  #
  
  package Data::Dumper;
  
  $VERSION = '2.125'; # Don't forget to set version and release date in POD!
  
  #$| = 1;
  
  use 5.006_001;
  require Exporter;
  require overload;
  
  use Carp;
  
  BEGIN {
      @ISA = qw(Exporter);
      @EXPORT = qw(Dumper);
      @EXPORT_OK = qw(DumperX);
  
      # if run under miniperl, or otherwise lacking dynamic loading,
      # XSLoader should be attempted to load, or the pure perl flag
      # toggled on load failure.
      eval {
  	require XSLoader;
      };
      $Useperl = 1 if $@;
  }
  
  XSLoader::load( 'Data::Dumper' ) unless $Useperl;
  
  # module vars and their defaults
  $Indent     = 2         unless defined $Indent;
  $Purity     = 0         unless defined $Purity;
  $Pad        = ""        unless defined $Pad;
  $Varname    = "VAR"     unless defined $Varname;
  $Useqq      = 0         unless defined $Useqq;
  $Terse      = 0         unless defined $Terse;
  $Freezer    = ""        unless defined $Freezer;
  $Toaster    = ""        unless defined $Toaster;
  $Deepcopy   = 0         unless defined $Deepcopy;
  $Quotekeys  = 1         unless defined $Quotekeys;
  $Bless      = "bless"   unless defined $Bless;
  #$Expdepth   = 0         unless defined $Expdepth;
  $Maxdepth   = 0         unless defined $Maxdepth;
  $Pair       = ' => '    unless defined $Pair;
  $Useperl    = 0         unless defined $Useperl;
  $Sortkeys   = 0         unless defined $Sortkeys;
  $Deparse    = 0         unless defined $Deparse;
  
  #
  # expects an arrayref of values to be dumped.
  # can optionally pass an arrayref of names for the values.
  # names must have leading $ sign stripped. begin the name with *
  # to cause output of arrays and hashes rather than refs.
  #
  sub new {
    my($c, $v, $n) = @_;
  
    croak "Usage:  PACKAGE->new(ARRAYREF, [ARRAYREF])" 
      unless (defined($v) && (ref($v) eq 'ARRAY'));
    $n = [] unless (defined($n) && (ref($n) eq 'ARRAY'));
  
    my($s) = { 
               level      => 0,           # current recursive depth
  	     indent     => $Indent,     # various styles of indenting
  	     pad	=> $Pad,        # all lines prefixed by this string
  	     xpad       => "",          # padding-per-level
  	     apad       => "",          # added padding for hash keys n such
  	     sep        => "",          # list separator
  	     pair	=> $Pair,	# hash key/value separator: defaults to ' => '
  	     seen       => {},          # local (nested) refs (id => [name, val])
  	     todump     => $v,          # values to dump []
  	     names      => $n,          # optional names for values []
  	     varname    => $Varname,    # prefix to use for tagging nameless ones
               purity     => $Purity,     # degree to which output is evalable
               useqq 	=> $Useqq,      # use "" for strings (backslashitis ensues)
               terse 	=> $Terse,      # avoid name output (where feasible)
               freezer	=> $Freezer,    # name of Freezer method for objects
               toaster	=> $Toaster,    # name of method to revive objects
               deepcopy	=> $Deepcopy,   # dont cross-ref, except to stop recursion
               quotekeys	=> $Quotekeys,  # quote hash keys
               'bless'	=> $Bless,	# keyword to use for "bless"
  #	     expdepth   => $Expdepth,   # cutoff depth for explicit dumping
  	     maxdepth	=> $Maxdepth,   # depth beyond which we give up
  	     useperl    => $Useperl,    # use the pure Perl implementation
  	     sortkeys   => $Sortkeys,   # flag or filter for sorting hash keys
  	     deparse	=> $Deparse,	# use B::Deparse for coderefs
  	   };
  
    if ($Indent > 0) {
      $s->{xpad} = "  ";
      $s->{sep} = "\n";
    }
    return bless($s, $c);
  }
  
  if ($] >= 5.008) {
    # Packed numeric addresses take less memory. Plus pack is faster than sprintf
    *init_refaddr_format = sub {};
  
    *format_refaddr  = sub {
      require Scalar::Util;
      pack "J", Scalar::Util::refaddr(shift);
    };
  } else {
    *init_refaddr_format = sub {
      require Config;
      my $f = $Config::Config{uvxformat};
      $f =~ tr/"//d;
      our $refaddr_format = "0x%" . $f;
    };
  
    *format_refaddr = sub {
      require Scalar::Util;
      sprintf our $refaddr_format, Scalar::Util::refaddr(shift);
    }
  }
  
  #
  # add-to or query the table of already seen references
  #
  sub Seen {
    my($s, $g) = @_;
    if (defined($g) && (ref($g) eq 'HASH'))  {
      init_refaddr_format();
      my($k, $v, $id);
      while (($k, $v) = each %$g) {
        if (defined $v and ref $v) {
  	$id = format_refaddr($v);
  	if ($k =~ /^[*](.*)$/) {
  	  $k = (ref $v eq 'ARRAY') ? ( "\\\@" . $1 ) :
  	       (ref $v eq 'HASH')  ? ( "\\\%" . $1 ) :
  	       (ref $v eq 'CODE')  ? ( "\\\&" . $1 ) :
  				     (   "\$" . $1 ) ;
  	}
  	elsif ($k !~ /^\$/) {
  	  $k = "\$" . $k;
  	}
  	$s->{seen}{$id} = [$k, $v];
        }
        else {
  	carp "Only refs supported, ignoring non-ref item \$$k";
        }
      }
      return $s;
    }
    else {
      return map { @$_ } values %{$s->{seen}};
    }
  }
  
  #
  # set or query the values to be dumped
  #
  sub Values {
    my($s, $v) = @_;
    if (defined($v) && (ref($v) eq 'ARRAY'))  {
      $s->{todump} = [@$v];        # make a copy
      return $s;
    }
    else {
      return @{$s->{todump}};
    }
  }
  
  #
  # set or query the names of the values to be dumped
  #
  sub Names {
    my($s, $n) = @_;
    if (defined($n) && (ref($n) eq 'ARRAY'))  {
      $s->{names} = [@$n];         # make a copy
      return $s;
    }
    else {
      return @{$s->{names}};
    }
  }
  
  sub DESTROY {}
  
  sub Dump {
      return &Dumpxs
  	unless $Data::Dumper::Useperl || (ref($_[0]) && $_[0]->{useperl}) ||
  	       $Data::Dumper::Useqq   || (ref($_[0]) && $_[0]->{useqq}) ||
  	       $Data::Dumper::Deparse || (ref($_[0]) && $_[0]->{deparse});
      return &Dumpperl;
  }
  
  #
  # dump the refs in the current dumper object.
  # expects same args as new() if called via package name.
  #
  sub Dumpperl {
    my($s) = shift;
    my(@out, $val, $name);
    my($i) = 0;
    local(@post);
    init_refaddr_format();
  
    $s = $s->new(@_) unless ref $s;
  
    for $val (@{$s->{todump}}) {
      my $out = "";
      @post = ();
      $name = $s->{names}[$i++];
      if (defined $name) {
        if ($name =~ /^[*](.*)$/) {
  	if (defined $val) {
  	  $name = (ref $val eq 'ARRAY') ? ( "\@" . $1 ) :
  		  (ref $val eq 'HASH')  ? ( "\%" . $1 ) :
  		  (ref $val eq 'CODE')  ? ( "\*" . $1 ) :
  					  ( "\$" . $1 ) ;
  	}
  	else {
  	  $name = "\$" . $1;
  	}
        }
        elsif ($name !~ /^\$/) {
  	$name = "\$" . $name;
        }
      }
      else {
        $name = "\$" . $s->{varname} . $i;
      }
  
      my $valstr;
      {
        local($s->{apad}) = $s->{apad};
        $s->{apad} .= ' ' x (length($name) + 3) if $s->{indent} >= 2;
        $valstr = $s->_dump($val, $name);
      }
  
      $valstr = "$name = " . $valstr . ';' if @post or !$s->{terse};
      $out .= $s->{pad} . $valstr . $s->{sep};
      $out .= $s->{pad} . join(';' . $s->{sep} . $s->{pad}, @post) 
        . ';' . $s->{sep} if @post;
  
      push @out, $out;
    }
    return wantarray ? @out : join('', @out);
  }
  
  # wrap string in single quotes (escaping if needed)
  sub _quote {
      my $val = shift;
      $val =~ s/([\\\'])/\\$1/g;
      return  "'" . $val .  "'";
  }
  
  #
  # twist, toil and turn;
  # and recurse, of course.
  # sometimes sordidly;
  # and curse if no recourse.
  #
  sub _dump {
    my($s, $val, $name) = @_;
    my($sname);
    my($out, $realpack, $realtype, $type, $ipad, $id, $blesspad);
  
    $type = ref $val;
    $out = "";
  
    if ($type) {
  
      # Call the freezer method if it's specified and the object has the
      # method.  Trap errors and warn() instead of die()ing, like the XS
      # implementation.
      my $freezer = $s->{freezer};
      if ($freezer and UNIVERSAL::can($val, $freezer)) {
        eval { $val->$freezer() };
        warn "WARNING(Freezer method call failed): $@" if $@;
      }
  
      require Scalar::Util;
      $realpack = Scalar::Util::blessed($val);
      $realtype = $realpack ? Scalar::Util::reftype($val) : ref $val;
      $id = format_refaddr($val);
  
      # if it has a name, we need to either look it up, or keep a tab
      # on it so we know when we hit it later
      if (defined($name) and length($name)) {
        # keep a tab on it so that we dont fall into recursive pit
        if (exists $s->{seen}{$id}) {
  #	if ($s->{expdepth} < $s->{level}) {
  	  if ($s->{purity} and $s->{level} > 0) {
  	    $out = ($realtype eq 'HASH')  ? '{}' :
  	      ($realtype eq 'ARRAY') ? '[]' :
  		'do{my $o}' ;
  	    push @post, $name . " = " . $s->{seen}{$id}[0];
  	  }
  	  else {
  	    $out = $s->{seen}{$id}[0];
  	    if ($name =~ /^([\@\%])/) {
  	      my $start = $1;
  	      if ($out =~ /^\\$start/) {
  		$out = substr($out, 1);
  	      }
  	      else {
  		$out = $start . '{' . $out . '}';
  	      }
  	    }
            }
  	  return $out;
  #        }
        }
        else {
          # store our name
          $s->{seen}{$id} = [ (($name =~ /^[@%]/)     ? ('\\' . $name ) :
  			     ($realtype eq 'CODE' and
  			      $name =~ /^[*](.*)$/) ? ('\\&' . $1 )   :
  			     $name          ),
  			    $val ];
        }
      }
      my $no_bless = 0; 
      my $is_regex = 0;
      if ( $realpack and ($] >= 5.009005 ? re::is_regexp($val) : $realpack eq 'Regexp') ) {
          $is_regex = 1;
          $no_bless = $realpack eq 'Regexp';
      }
  
      # If purity is not set and maxdepth is set, then check depth: 
      # if we have reached maximum depth, return the string
      # representation of the thing we are currently examining
      # at this depth (i.e., 'Foo=ARRAY(0xdeadbeef)'). 
      if (!$s->{purity}
  	and $s->{maxdepth} > 0
  	and $s->{level} >= $s->{maxdepth})
      {
        return qq['$val'];
      }
  
      # we have a blessed ref
      if ($realpack and !$no_bless) {
        $out = $s->{'bless'} . '( ';
        $blesspad = $s->{apad};
        $s->{apad} .= '       ' if ($s->{indent} >= 2);
      }
  
      $s->{level}++;
      $ipad = $s->{xpad} x $s->{level};
  
      if ($is_regex) {
          my $pat;
          # This really sucks, re:regexp_pattern is in ext/re/re.xs and not in 
          # universal.c, and even worse we cant just require that re to be loaded
          # we *have* to use() it. 
          # We should probably move it to universal.c for 5.10.1 and fix this.
          # Currently we only use re::regexp_pattern when the re is blessed into another
          # package. This has the disadvantage of meaning that a DD dump won't round trip
          # as the pattern will be repeatedly wrapped with the same modifiers.
          # This is an aesthetic issue so we will leave it for now, but we could use
          # regexp_pattern() in list context to get the modifiers separately.
          # But since this means loading the full debugging engine in process we wont
          # bother unless its necessary for accuracy.
          if (($realpack ne 'Regexp') && defined(*re::regexp_pattern{CODE})) {
              $pat = re::regexp_pattern($val);
          } else {
              $pat = "$val";
          }
          $pat =~ s,/,\\/,g;
          $out .= "qr/$pat/";
      }
      elsif ($realtype eq 'SCALAR' || $realtype eq 'REF') {
        if ($realpack) {
  	$out .= 'do{\\(my $o = ' . $s->_dump($$val, "\${$name}") . ')}';
        }
        else {
  	$out .= '\\' . $s->_dump($$val, "\${$name}");
        }
      }
      elsif ($realtype eq 'GLOB') {
  	$out .= '\\' . $s->_dump($$val, "*{$name}");
      }
      elsif ($realtype eq 'ARRAY') {
        my($pad, $mname);
        my($i) = 0;
        $out .= ($name =~ /^\@/) ? '(' : '[';
        $pad = $s->{sep} . $s->{pad} . $s->{apad};
        ($name =~ /^\@(.*)$/) ? ($mname = "\$" . $1) : 
  	# omit -> if $foo->[0]->{bar}, but not ${$foo->[0]}->{bar}
  	($name =~ /^\\?[\%\@\*\$][^{].*[]}]$/) ? ($mname = $name) :
  	  ($mname = $name . '->');
        $mname .= '->' if $mname =~ /^\*.+\{[A-Z]+\}$/;
        for my $v (@$val) {
  	$sname = $mname . '[' . $i . ']';
  	$out .= $pad . $ipad . '#' . $i if $s->{indent} >= 3;
  	$out .= $pad . $ipad . $s->_dump($v, $sname);
  	$out .= "," if $i++ < $#$val;
        }
        $out .= $pad . ($s->{xpad} x ($s->{level} - 1)) if $i;
        $out .= ($name =~ /^\@/) ? ')' : ']';
      }
      elsif ($realtype eq 'HASH') {
        my($k, $v, $pad, $lpad, $mname, $pair);
        $out .= ($name =~ /^\%/) ? '(' : '{';
        $pad = $s->{sep} . $s->{pad} . $s->{apad};
        $lpad = $s->{apad};
        $pair = $s->{pair};
        ($name =~ /^\%(.*)$/) ? ($mname = "\$" . $1) :
  	# omit -> if $foo->[0]->{bar}, but not ${$foo->[0]}->{bar}
  	($name =~ /^\\?[\%\@\*\$][^{].*[]}]$/) ? ($mname = $name) :
  	  ($mname = $name . '->');
        $mname .= '->' if $mname =~ /^\*.+\{[A-Z]+\}$/;
        my ($sortkeys, $keys, $key) = ("$s->{sortkeys}");
        if ($sortkeys) {
  	if (ref($s->{sortkeys}) eq 'CODE') {
  	  $keys = $s->{sortkeys}($val);
  	  unless (ref($keys) eq 'ARRAY') {
  	    carp "Sortkeys subroutine did not return ARRAYREF";
  	    $keys = [];
  	  }
  	}
  	else {
  	  $keys = [ sort keys %$val ];
  	}
        }
  
        # Ensure hash iterator is reset
        keys(%$val);
  
        while (($k, $v) = ! $sortkeys ? (each %$val) :
  	     @$keys ? ($key = shift(@$keys), $val->{$key}) :
  	     () ) 
        {
  	my $nk = $s->_dump($k, "");
  	$nk = $1 if !$s->{quotekeys} and $nk =~ /^[\"\']([A-Za-z_]\w*)[\"\']$/;
  	$sname = $mname . '{' . $nk . '}';
  	$out .= $pad . $ipad . $nk . $pair;
  
  	# temporarily alter apad
  	$s->{apad} .= (" " x (length($nk) + 4)) if $s->{indent} >= 2;
  	$out .= $s->_dump($val->{$k}, $sname) . ",";
  	$s->{apad} = $lpad if $s->{indent} >= 2;
        }
        if (substr($out, -1) eq ',') {
  	chop $out;
  	$out .= $pad . ($s->{xpad} x ($s->{level} - 1));
        }
        $out .= ($name =~ /^\%/) ? ')' : '}';
      }
      elsif ($realtype eq 'CODE') {
        if ($s->{deparse}) {
  	require B::Deparse;
  	my $sub =  'sub ' . (B::Deparse->new)->coderef2text($val);
  	$pad    =  $s->{sep} . $s->{pad} . $s->{apad} . $s->{xpad} x ($s->{level} - 1);
  	$sub    =~ s/\n/$pad/gse;
  	$out   .=  $sub;
        } else {
          $out .= 'sub { "DUMMY" }';
          carp "Encountered CODE ref, using dummy placeholder" if $s->{purity};
        }
      }
      else {
        croak "Can\'t handle $realtype type.";
      }
      
      if ($realpack and !$no_bless) { # we have a blessed ref
        $out .= ', ' . _quote($realpack) . ' )';
        $out .= '->' . $s->{toaster} . '()'  if $s->{toaster} ne '';
        $s->{apad} = $blesspad;
      }
      $s->{level}--;
  
    }
    else {                                 # simple scalar
  
      my $ref = \$_[1];
      # first, catalog the scalar
      if ($name ne '') {
        $id = format_refaddr($ref);
        if (exists $s->{seen}{$id}) {
          if ($s->{seen}{$id}[2]) {
  	  $out = $s->{seen}{$id}[0];
  	  #warn "[<$out]\n";
  	  return "\${$out}";
  	}
        }
        else {
  	#warn "[>\\$name]\n";
  	$s->{seen}{$id} = ["\\$name", $ref];
        }
      }
      if (ref($ref) eq 'GLOB' or "$ref" =~ /=GLOB\([^()]+\)$/) {  # glob
        my $name = substr($val, 1);
        if ($name =~ /^[A-Za-z_][\w:]*$/) {
  	$name =~ s/^main::/::/;
  	$sname = $name;
        }
        else {
  	$sname = $s->_dump($name, "");
  	$sname = '{' . $sname . '}';
        }
        if ($s->{purity}) {
  	my $k;
  	local ($s->{level}) = 0;
  	for $k (qw(SCALAR ARRAY HASH)) {
  	  my $gval = *$val{$k};
  	  next unless defined $gval;
  	  next if $k eq "SCALAR" && ! defined $$gval;  # always there
  
  	  # _dump can push into @post, so we hold our place using $postlen
  	  my $postlen = scalar @post;
  	  $post[$postlen] = "\*$sname = ";
  	  local ($s->{apad}) = " " x length($post[$postlen]) if $s->{indent} >= 2;
  	  $post[$postlen] .= $s->_dump($gval, "\*$sname\{$k\}");
  	}
        }
        $out .= '*' . $sname;
      }
      elsif (!defined($val)) {
        $out .= "undef";
      }
      elsif ($val =~ /^(?:0|-?[1-9]\d{0,8})\z/) { # safe decimal number
        $out .= $val;
      }
      else {				 # string
        if ($s->{useqq} or $val =~ tr/\0-\377//c) {
          # Fall back to qq if there's Unicode
  	$out .= qquote($val, $s->{useqq});
        }
        else {
          $out .= _quote($val);
        }
      }
    }
    if ($id) {
      # if we made it this far, $id was added to seen list at current
      # level, so remove it to get deep copies
      if ($s->{deepcopy}) {
        delete($s->{seen}{$id});
      }
      elsif ($name) {
        $s->{seen}{$id}[2] = 1;
      }
    }
    return $out;
  }
    
  #
  # non-OO style of earlier version
  #
  sub Dumper {
    return Data::Dumper->Dump([@_]);
  }
  
  # compat stub
  sub DumperX {
    return Data::Dumper->Dumpxs([@_], []);
  }
  
  sub Dumpf { return Data::Dumper->Dump(@_) }
  
  sub Dumpp { print Data::Dumper->Dump(@_) }
  
  #
  # reset the "seen" cache 
  #
  sub Reset {
    my($s) = shift;
    $s->{seen} = {};
    return $s;
  }
  
  sub Indent {
    my($s, $v) = @_;
    if (defined($v)) {
      if ($v == 0) {
        $s->{xpad} = "";
        $s->{sep} = "";
      }
      else {
        $s->{xpad} = "  ";
        $s->{sep} = "\n";
      }
      $s->{indent} = $v;
      return $s;
    }
    else {
      return $s->{indent};
    }
  }
  
  sub Pair {
      my($s, $v) = @_;
      defined($v) ? (($s->{pair} = $v), return $s) : $s->{pair};
  }
  
  sub Pad {
    my($s, $v) = @_;
    defined($v) ? (($s->{pad} = $v), return $s) : $s->{pad};
  }
  
  sub Varname {
    my($s, $v) = @_;
    defined($v) ? (($s->{varname} = $v), return $s) : $s->{varname};
  }
  
  sub Purity {
    my($s, $v) = @_;
    defined($v) ? (($s->{purity} = $v), return $s) : $s->{purity};
  }
  
  sub Useqq {
    my($s, $v) = @_;
    defined($v) ? (($s->{useqq} = $v), return $s) : $s->{useqq};
  }
  
  sub Terse {
    my($s, $v) = @_;
    defined($v) ? (($s->{terse} = $v), return $s) : $s->{terse};
  }
  
  sub Freezer {
    my($s, $v) = @_;
    defined($v) ? (($s->{freezer} = $v), return $s) : $s->{freezer};
  }
  
  sub Toaster {
    my($s, $v) = @_;
    defined($v) ? (($s->{toaster} = $v), return $s) : $s->{toaster};
  }
  
  sub Deepcopy {
    my($s, $v) = @_;
    defined($v) ? (($s->{deepcopy} = $v), return $s) : $s->{deepcopy};
  }
  
  sub Quotekeys {
    my($s, $v) = @_;
    defined($v) ? (($s->{quotekeys} = $v), return $s) : $s->{quotekeys};
  }
  
  sub Bless {
    my($s, $v) = @_;
    defined($v) ? (($s->{'bless'} = $v), return $s) : $s->{'bless'};
  }
  
  sub Maxdepth {
    my($s, $v) = @_;
    defined($v) ? (($s->{'maxdepth'} = $v), return $s) : $s->{'maxdepth'};
  }
  
  sub Useperl {
    my($s, $v) = @_;
    defined($v) ? (($s->{'useperl'} = $v), return $s) : $s->{'useperl'};
  }
  
  sub Sortkeys {
    my($s, $v) = @_;
    defined($v) ? (($s->{'sortkeys'} = $v), return $s) : $s->{'sortkeys'};
  }
  
  sub Deparse {
    my($s, $v) = @_;
    defined($v) ? (($s->{'deparse'} = $v), return $s) : $s->{'deparse'};
  }
  
  # used by qquote below
  my %esc = (  
      "\a" => "\\a",
      "\b" => "\\b",
      "\t" => "\\t",
      "\n" => "\\n",
      "\f" => "\\f",
      "\r" => "\\r",
      "\e" => "\\e",
  );
  
  # put a string value in double quotes
  sub qquote {
    local($_) = shift;
    s/([\\\"\@\$])/\\$1/g;
    my $bytes; { use bytes; $bytes = length }
    s/([^\x00-\x7f])/'\x{'.sprintf("%x",ord($1)).'}'/ge if $bytes > length;
    return qq("$_") unless 
      /[^ !"\#\$%&'()*+,\-.\/0-9:;<=>?\@A-Z[\\\]^_`a-z{|}~]/;  # fast exit
  
    my $high = shift || "";
    s/([\a\b\t\n\f\r\e])/$esc{$1}/g;
  
    if (ord('^')==94)  { # ascii
      # no need for 3 digits in escape for these
      s/([\0-\037])(?!\d)/'\\'.sprintf('%o',ord($1))/eg;
      s/([\0-\037\177])/'\\'.sprintf('%03o',ord($1))/eg;
      # all but last branch below not supported --BEHAVIOR SUBJECT TO CHANGE--
      if ($high eq "iso8859") {
        s/([\200-\240])/'\\'.sprintf('%o',ord($1))/eg;
      } elsif ($high eq "utf8") {
  #     use utf8;
  #     $str =~ s/([^\040-\176])/sprintf "\\x{%04x}", ord($1)/ge;
      } elsif ($high eq "8bit") {
          # leave it as it is
      } else {
        s/([\200-\377])/'\\'.sprintf('%03o',ord($1))/eg;
        s/([^\040-\176])/sprintf "\\x{%04x}", ord($1)/ge;
      }
    }
    else { # ebcdic
        s{([^ !"\#\$%&'()*+,\-.\/0-9:;<=>?\@A-Z[\\\]^_`a-z{|}~])(?!\d)}
         {my $v = ord($1); '\\'.sprintf(($v <= 037 ? '%o' : '%03o'), $v)}eg;
        s{([^ !"\#\$%&'()*+,\-.\/0-9:;<=>?\@A-Z[\\\]^_`a-z{|}~])}
         {'\\'.sprintf('%03o',ord($1))}eg;
    }
  
    return qq("$_");
  }
  
  # helper sub to sort hash keys in Perl < 5.8.0 where we don't have
  # access to sortsv() from XS
  sub _sortkeys { [ sort keys %{$_[0]} ] }
  
  1;
  __END__
  
  =head1 NAME
  
  Data::Dumper - stringified perl data structures, suitable for both printing and C<eval>
  
  =head1 SYNOPSIS
  
      use Data::Dumper;
  
      # simple procedural interface
      print Dumper($foo, $bar);
  
      # extended usage with names
      print Data::Dumper->Dump([$foo, $bar], [qw(foo *ary)]);
  
      # configuration variables
      {
        local $Data::Dumper::Purity = 1;
        eval Data::Dumper->Dump([$foo, $bar], [qw(foo *ary)]);
      }
  
      # OO usage
      $d = Data::Dumper->new([$foo, $bar], [qw(foo *ary)]);
         ...
      print $d->Dump;
         ...
      $d->Purity(1)->Terse(1)->Deepcopy(1);
      eval $d->Dump;
  
  
  =head1 DESCRIPTION
  
  Given a list of scalars or reference variables, writes out their contents in
  perl syntax. The references can also be objects.  The content of each
  variable is output in a single Perl statement.  Handles self-referential
  structures correctly.
  
  The return value can be C<eval>ed to get back an identical copy of the
  original reference structure.
  
  Any references that are the same as one of those passed in will be named
  C<$VAR>I<n> (where I<n> is a numeric suffix), and other duplicate references
  to substructures within C<$VAR>I<n> will be appropriately labeled using arrow
  notation.  You can specify names for individual values to be dumped if you
  use the C<Dump()> method, or you can change the default C<$VAR> prefix to
  something else.  See C<$Data::Dumper::Varname> and C<$Data::Dumper::Terse>
  below.
  
  The default output of self-referential structures can be C<eval>ed, but the
  nested references to C<$VAR>I<n> will be undefined, since a recursive
  structure cannot be constructed using one Perl statement.  You should set the
  C<Purity> flag to 1 to get additional statements that will correctly fill in
  these references.  Moreover, if C<eval>ed when strictures are in effect,
  you need to ensure that any variables it accesses are previously declared.
  
  In the extended usage form, the references to be dumped can be given
  user-specified names.  If a name begins with a C<*>, the output will 
  describe the dereferenced type of the supplied reference for hashes and
  arrays, and coderefs.  Output of names will be avoided where possible if
  the C<Terse> flag is set.
  
  In many cases, methods that are used to set the internal state of the
  object will return the object itself, so method calls can be conveniently
  chained together.
  
  Several styles of output are possible, all controlled by setting
  the C<Indent> flag.  See L<Configuration Variables or Methods> below 
  for details.
  
  
  =head2 Methods
  
  =over 4
  
  =item I<PACKAGE>->new(I<ARRAYREF [>, I<ARRAYREF]>)
  
  Returns a newly created C<Data::Dumper> object.  The first argument is an
  anonymous array of values to be dumped.  The optional second argument is an
  anonymous array of names for the values.  The names need not have a leading
  C<$> sign, and must be comprised of alphanumeric characters.  You can begin
  a name with a C<*> to specify that the dereferenced type must be dumped
  instead of the reference itself, for ARRAY and HASH references.
  
  The prefix specified by C<$Data::Dumper::Varname> will be used with a
  numeric suffix if the name for a value is undefined.
  
  Data::Dumper will catalog all references encountered while dumping the
  values. Cross-references (in the form of names of substructures in perl
  syntax) will be inserted at all possible points, preserving any structural
  interdependencies in the original set of values.  Structure traversal is
  depth-first,  and proceeds in order from the first supplied value to
  the last.
  
  =item I<$OBJ>->Dump  I<or>  I<PACKAGE>->Dump(I<ARRAYREF [>, I<ARRAYREF]>)
  
  Returns the stringified form of the values stored in the object (preserving
  the order in which they were supplied to C<new>), subject to the
  configuration options below.  In a list context, it returns a list
  of strings corresponding to the supplied values.
  
  The second form, for convenience, simply calls the C<new> method on its
  arguments before dumping the object immediately.
  
  =item I<$OBJ>->Seen(I<[HASHREF]>)
  
  Queries or adds to the internal table of already encountered references.
  You must use C<Reset> to explicitly clear the table if needed.  Such
  references are not dumped; instead, their names are inserted wherever they
  are encountered subsequently.  This is useful especially for properly
  dumping subroutine references.
  
  Expects an anonymous hash of name => value pairs.  Same rules apply for names
  as in C<new>.  If no argument is supplied, will return the "seen" list of
  name => value pairs, in a list context.  Otherwise, returns the object
  itself.
  
  =item I<$OBJ>->Values(I<[ARRAYREF]>)
  
  Queries or replaces the internal array of values that will be dumped.
  When called without arguments, returns the values.  Otherwise, returns the
  object itself.
  
  =item I<$OBJ>->Names(I<[ARRAYREF]>)
  
  Queries or replaces the internal array of user supplied names for the values
  that will be dumped.  When called without arguments, returns the names.
  Otherwise, returns the object itself.
  
  =item I<$OBJ>->Reset
  
  Clears the internal table of "seen" references and returns the object
  itself.
  
  =back
  
  =head2 Functions
  
  =over 4
  
  =item Dumper(I<LIST>)
  
  Returns the stringified form of the values in the list, subject to the
  configuration options below.  The values will be named C<$VAR>I<n> in the
  output, where I<n> is a numeric suffix.  Will return a list of strings
  in a list context.
  
  =back
  
  =head2 Configuration Variables or Methods
  
  Several configuration variables can be used to control the kind of output
  generated when using the procedural interface.  These variables are usually
  C<local>ized in a block so that other parts of the code are not affected by
  the change.  
  
  These variables determine the default state of the object created by calling
  the C<new> method, but cannot be used to alter the state of the object
  thereafter.  The equivalent method names should be used instead to query
  or set the internal state of the object.
  
  The method forms return the object itself when called with arguments,
  so that they can be chained together nicely.
  
  =over 4
  
  =item *
  
  $Data::Dumper::Indent  I<or>  I<$OBJ>->Indent(I<[NEWVAL]>)
  
  Controls the style of indentation.  It can be set to 0, 1, 2 or 3.  Style 0
  spews output without any newlines, indentation, or spaces between list
  items.  It is the most compact format possible that can still be called
  valid perl.  Style 1 outputs a readable form with newlines but no fancy
  indentation (each level in the structure is simply indented by a fixed
  amount of whitespace).  Style 2 (the default) outputs a very readable form
  which takes into account the length of hash keys (so the hash value lines
  up).  Style 3 is like style 2, but also annotates the elements of arrays
  with their index (but the comment is on its own line, so array output
  consumes twice the number of lines).  Style 2 is the default.
  
  =item *
  
  $Data::Dumper::Purity  I<or>  I<$OBJ>->Purity(I<[NEWVAL]>)
  
  Controls the degree to which the output can be C<eval>ed to recreate the
  supplied reference structures.  Setting it to 1 will output additional perl
  statements that will correctly recreate nested references.  The default is
  0.
  
  =item *
  
  $Data::Dumper::Pad  I<or>  I<$OBJ>->Pad(I<[NEWVAL]>)
  
  Specifies the string that will be prefixed to every line of the output.
  Empty string by default.
  
  =item *
  
  $Data::Dumper::Varname  I<or>  I<$OBJ>->Varname(I<[NEWVAL]>)
  
  Contains the prefix to use for tagging variable names in the output. The
  default is "VAR".
  
  =item *
  
  $Data::Dumper::Useqq  I<or>  I<$OBJ>->Useqq(I<[NEWVAL]>)
  
  When set, enables the use of double quotes for representing string values.
  Whitespace other than space will be represented as C<[\n\t\r]>, "unsafe"
  characters will be backslashed, and unprintable characters will be output as
  quoted octal integers.  Since setting this variable imposes a performance
  penalty, the default is 0.  C<Dump()> will run slower if this flag is set,
  since the fast XSUB implementation doesn't support it yet.
  
  =item *
  
  $Data::Dumper::Terse  I<or>  I<$OBJ>->Terse(I<[NEWVAL]>)
  
  When set, Data::Dumper will emit single, non-self-referential values as
  atoms/terms rather than statements.  This means that the C<$VAR>I<n> names
  will be avoided where possible, but be advised that such output may not
  always be parseable by C<eval>.
  
  =item *
  
  $Data::Dumper::Freezer  I<or>  $I<OBJ>->Freezer(I<[NEWVAL]>)
  
  Can be set to a method name, or to an empty string to disable the feature.
  Data::Dumper will invoke that method via the object before attempting to
  stringify it.  This method can alter the contents of the object (if, for
  instance, it contains data allocated from C), and even rebless it in a
  different package.  The client is responsible for making sure the specified
  method can be called via the object, and that the object ends up containing
  only perl data types after the method has been called.  Defaults to an empty
  string.
  
  If an object does not support the method specified (determined using
  UNIVERSAL::can()) then the call will be skipped.  If the method dies a
  warning will be generated.
  
  =item *
  
  $Data::Dumper::Toaster  I<or>  $I<OBJ>->Toaster(I<[NEWVAL]>)
  
  Can be set to a method name, or to an empty string to disable the feature.
  Data::Dumper will emit a method call for any objects that are to be dumped
  using the syntax C<bless(DATA, CLASS)-E<gt>METHOD()>.  Note that this means that
  the method specified will have to perform any modifications required on the
  object (like creating new state within it, and/or reblessing it in a
  different package) and then return it.  The client is responsible for making
  sure the method can be called via the object, and that it returns a valid
  object.  Defaults to an empty string.
  
  =item *
  
  $Data::Dumper::Deepcopy  I<or>  $I<OBJ>->Deepcopy(I<[NEWVAL]>)
  
  Can be set to a boolean value to enable deep copies of structures.
  Cross-referencing will then only be done when absolutely essential
  (i.e., to break reference cycles).  Default is 0.
  
  =item *
  
  $Data::Dumper::Quotekeys  I<or>  $I<OBJ>->Quotekeys(I<[NEWVAL]>)
  
  Can be set to a boolean value to control whether hash keys are quoted.
  A false value will avoid quoting hash keys when it looks like a simple
  string.  Default is 1, which will always enclose hash keys in quotes.
  
  =item *
  
  $Data::Dumper::Bless  I<or>  $I<OBJ>->Bless(I<[NEWVAL]>)
  
  Can be set to a string that specifies an alternative to the C<bless>
  builtin operator used to create objects.  A function with the specified
  name should exist, and should accept the same arguments as the builtin.
  Default is C<bless>.
  
  =item *
  
  $Data::Dumper::Pair  I<or>  $I<OBJ>->Pair(I<[NEWVAL]>)
  
  Can be set to a string that specifies the separator between hash keys
  and values. To dump nested hash, array and scalar values to JavaScript,
  use: C<$Data::Dumper::Pair = ' : ';>. Implementing C<bless> in JavaScript
  is left as an exercise for the reader.
  A function with the specified name exists, and accepts the same arguments
  as the builtin.
  
  Default is: C< =E<gt> >.
  
  =item *
  
  $Data::Dumper::Maxdepth  I<or>  $I<OBJ>->Maxdepth(I<[NEWVAL]>)
  
  Can be set to a positive integer that specifies the depth beyond which
  we don't venture into a structure.  Has no effect when
  C<Data::Dumper::Purity> is set.  (Useful in debugger when we often don't
  want to see more than enough).  Default is 0, which means there is 
  no maximum depth. 
  
  =item *
  
  $Data::Dumper::Useperl  I<or>  $I<OBJ>->Useperl(I<[NEWVAL]>)
  
  Can be set to a boolean value which controls whether the pure Perl
  implementation of C<Data::Dumper> is used. The C<Data::Dumper> module is
  a dual implementation, with almost all functionality written in both
  pure Perl and also in XS ('C'). Since the XS version is much faster, it
  will always be used if possible. This option lets you override the
  default behavior, usually for testing purposes only. Default is 0, which
  means the XS implementation will be used if possible.
  
  =item *
  
  $Data::Dumper::Sortkeys  I<or>  $I<OBJ>->Sortkeys(I<[NEWVAL]>)
  
  Can be set to a boolean value to control whether hash keys are dumped in
  sorted order. A true value will cause the keys of all hashes to be
  dumped in Perl's default sort order. Can also be set to a subroutine
  reference which will be called for each hash that is dumped. In this
  case C<Data::Dumper> will call the subroutine once for each hash,
  passing it the reference of the hash. The purpose of the subroutine is
  to return a reference to an array of the keys that will be dumped, in
  the order that they should be dumped. Using this feature, you can
  control both the order of the keys, and which keys are actually used. In
  other words, this subroutine acts as a filter by which you can exclude
  certain keys from being dumped. Default is 0, which means that hash keys
  are not sorted.
  
  =item *
  
  $Data::Dumper::Deparse  I<or>  $I<OBJ>->Deparse(I<[NEWVAL]>)
  
  Can be set to a boolean value to control whether code references are
  turned into perl source code. If set to a true value, C<B::Deparse>
  will be used to get the source of the code reference. Using this option
  will force using the Perl implementation of the dumper, since the fast
  XSUB implementation doesn't support it.
  
  Caution : use this option only if you know that your coderefs will be
  properly reconstructed by C<B::Deparse>.
  
  =back
  
  =head2 Exports
  
  =over 4
  
  =item Dumper
  
  =back
  
  =head1 EXAMPLES
  
  Run these code snippets to get a quick feel for the behavior of this
  module.  When you are through with these examples, you may want to
  add or change the various configuration variables described above,
  to see their behavior.  (See the testsuite in the Data::Dumper
  distribution for more examples.)
  
  
      use Data::Dumper;
  
      package Foo;
      sub new {bless {'a' => 1, 'b' => sub { return "foo" }}, $_[0]};
  
      package Fuz;                       # a weird REF-REF-SCALAR object
      sub new {bless \($_ = \ 'fu\'z'), $_[0]};
  
      package main;
      $foo = Foo->new;
      $fuz = Fuz->new;
      $boo = [ 1, [], "abcd", \*foo,
               {1 => 'a', 023 => 'b', 0x45 => 'c'}, 
               \\"p\q\'r", $foo, $fuz];
  
      ########
      # simple usage
      ########
  
      $bar = eval(Dumper($boo));
      print($@) if $@;
      print Dumper($boo), Dumper($bar);  # pretty print (no array indices)
  
      $Data::Dumper::Terse = 1;          # don't output names where feasible
      $Data::Dumper::Indent = 0;         # turn off all pretty print
      print Dumper($boo), "\n";
  
      $Data::Dumper::Indent = 1;         # mild pretty print
      print Dumper($boo);
  
      $Data::Dumper::Indent = 3;         # pretty print with array indices
      print Dumper($boo);
  
      $Data::Dumper::Useqq = 1;          # print strings in double quotes
      print Dumper($boo);
  
      $Data::Dumper::Pair = " : ";       # specify hash key/value separator
      print Dumper($boo);
  
  
      ########
      # recursive structures
      ########
  
      @c = ('c');
      $c = \@c;
      $b = {};
      $a = [1, $b, $c];
      $b->{a} = $a;
      $b->{b} = $a->[1];
      $b->{c} = $a->[2];
      print Data::Dumper->Dump([$a,$b,$c], [qw(a b c)]);
  
  
      $Data::Dumper::Purity = 1;         # fill in the holes for eval
      print Data::Dumper->Dump([$a, $b], [qw(*a b)]); # print as @a
      print Data::Dumper->Dump([$b, $a], [qw(*b a)]); # print as %b
  
  
      $Data::Dumper::Deepcopy = 1;       # avoid cross-refs
      print Data::Dumper->Dump([$b, $a], [qw(*b a)]);
  
  
      $Data::Dumper::Purity = 0;         # avoid cross-refs
      print Data::Dumper->Dump([$b, $a], [qw(*b a)]);
  
      ########
      # deep structures
      ########
  
      $a = "pearl";
      $b = [ $a ];
      $c = { 'b' => $b };
      $d = [ $c ];
      $e = { 'd' => $d };
      $f = { 'e' => $e };
      print Data::Dumper->Dump([$f], [qw(f)]);
  
      $Data::Dumper::Maxdepth = 3;       # no deeper than 3 refs down
      print Data::Dumper->Dump([$f], [qw(f)]);
  
  
      ########
      # object-oriented usage
      ########
  
      $d = Data::Dumper->new([$a,$b], [qw(a b)]);
      $d->Seen({'*c' => $c});            # stash a ref without printing it
      $d->Indent(3);
      print $d->Dump;
      $d->Reset->Purity(0);              # empty the seen cache
      print join "----\n", $d->Dump;
  
  
      ########
      # persistence
      ########
  
      package Foo;
      sub new { bless { state => 'awake' }, shift }
      sub Freeze {
          my $s = shift;
  	print STDERR "preparing to sleep\n";
  	$s->{state} = 'asleep';
  	return bless $s, 'Foo::ZZZ';
      }
  
      package Foo::ZZZ;
      sub Thaw {
          my $s = shift;
  	print STDERR "waking up\n";
  	$s->{state} = 'awake';
  	return bless $s, 'Foo';
      }
  
      package Foo;
      use Data::Dumper;
      $a = Foo->new;
      $b = Data::Dumper->new([$a], ['c']);
      $b->Freezer('Freeze');
      $b->Toaster('Thaw');
      $c = $b->Dump;
      print $c;
      $d = eval $c;
      print Data::Dumper->Dump([$d], ['d']);
  
  
      ########
      # symbol substitution (useful for recreating CODE refs)
      ########
  
      sub foo { print "foo speaking\n" }
      *other = \&foo;
      $bar = [ \&other ];
      $d = Data::Dumper->new([\&other,$bar],['*other','bar']);
      $d->Seen({ '*foo' => \&foo });
      print $d->Dump;
  
  
      ########
      # sorting and filtering hash keys
      ########
  
      $Data::Dumper::Sortkeys = \&my_filter;
      my $foo = { map { (ord, "$_$_$_") } 'I'..'Q' };
      my $bar = { %$foo };
      my $baz = { reverse %$foo };
      print Dumper [ $foo, $bar, $baz ];
  
      sub my_filter {
          my ($hash) = @_;
          # return an array ref containing the hash keys to dump
          # in the order that you want them to be dumped
          return [
            # Sort the keys of %$foo in reverse numeric order
              $hash eq $foo ? (sort {$b <=> $a} keys %$hash) :
            # Only dump the odd number keys of %$bar
              $hash eq $bar ? (grep {$_ % 2} keys %$hash) :
            # Sort keys in default order for all other hashes
              (sort keys %$hash)
          ];
      }
  
  =head1 BUGS
  
  Due to limitations of Perl subroutine call semantics, you cannot pass an
  array or hash.  Prepend it with a C<\> to pass its reference instead.  This
  will be remedied in time, now that Perl has subroutine prototypes.
  For now, you need to use the extended usage form, and prepend the
  name with a C<*> to output it as a hash or array.
  
  C<Data::Dumper> cheats with CODE references.  If a code reference is
  encountered in the structure being processed (and if you haven't set
  the C<Deparse> flag), an anonymous subroutine that
  contains the string '"DUMMY"' will be inserted in its place, and a warning
  will be printed if C<Purity> is set.  You can C<eval> the result, but bear
  in mind that the anonymous sub that gets created is just a placeholder.
  Someday, perl will have a switch to cache-on-demand the string
  representation of a compiled piece of code, I hope.  If you have prior
  knowledge of all the code refs that your data structures are likely
  to have, you can use the C<Seen> method to pre-seed the internal reference
  table and make the dumped output point to them, instead.  See L</EXAMPLES>
  above.
  
  The C<Useqq> and C<Deparse> flags makes Dump() run slower, since the
  XSUB implementation does not support them.
  
  SCALAR objects have the weirdest looking C<bless> workaround.
  
  Pure Perl version of C<Data::Dumper> escapes UTF-8 strings correctly
  only in Perl 5.8.0 and later.
  
  =head2 NOTE
  
  Starting from Perl 5.8.1 different runs of Perl will have different
  ordering of hash keys.  The change was done for greater security,
  see L<perlsec/"Algorithmic Complexity Attacks">.  This means that
  different runs of Perl will have different Data::Dumper outputs if
  the data contains hashes.  If you need to have identical Data::Dumper
  outputs from different runs of Perl, use the environment variable
  PERL_HASH_SEED, see L<perlrun/PERL_HASH_SEED>.  Using this restores
  the old (platform-specific) ordering: an even prettier solution might
  be to use the C<Sortkeys> filter of Data::Dumper.
  
  =head1 AUTHOR
  
  Gurusamy Sarathy        gsar@activestate.com
  
  Copyright (c) 1996-98 Gurusamy Sarathy. All rights reserved.
  This program is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  =head1 VERSION
  
  Version 2.125  (Aug  8 2009)
  
  =head1 SEE ALSO
  
  perl(1)
  
  =cut
I386-LINUX-THREAD-MULTI_DATA_DUMPER

$fatpacked{"i386-linux-thread-multi/File/Spec.pm"} = <<'I386-LINUX-THREAD-MULTI_FILE_SPEC';
  package File::Spec;
  
  use strict;
  use vars qw(@ISA $VERSION);
  
  $VERSION = '3.31';
  $VERSION = eval $VERSION;
  
  my %module = (MacOS   => 'Mac',
  	      MSWin32 => 'Win32',
  	      os2     => 'OS2',
  	      VMS     => 'VMS',
  	      epoc    => 'Epoc',
  	      NetWare => 'Win32', # Yes, File::Spec::Win32 works on NetWare.
  	      symbian => 'Win32', # Yes, File::Spec::Win32 works on symbian.
  	      dos     => 'OS2',   # Yes, File::Spec::OS2 works on DJGPP.
  	      cygwin  => 'Cygwin');
  
  
  my $module = $module{$^O} || 'Unix';
  
  require "File/Spec/$module.pm";
  @ISA = ("File::Spec::$module");
  
  1;
  
  __END__
  
  =head1 NAME
  
  File::Spec - portably perform operations on file names
  
  =head1 SYNOPSIS
  
  	use File::Spec;
  
  	$x=File::Spec->catfile('a', 'b', 'c');
  
  which returns 'a/b/c' under Unix. Or:
  
  	use File::Spec::Functions;
  
  	$x = catfile('a', 'b', 'c');
  
  =head1 DESCRIPTION
  
  This module is designed to support operations commonly performed on file
  specifications (usually called "file names", but not to be confused with the
  contents of a file, or Perl's file handles), such as concatenating several
  directory and file names into a single path, or determining whether a path
  is rooted. It is based on code directly taken from MakeMaker 5.17, code
  written by Andreas KE<ouml>nig, Andy Dougherty, Charles Bailey, Ilya
  Zakharevich, Paul Schinder, and others.
  
  Since these functions are different for most operating systems, each set of
  OS specific routines is available in a separate module, including:
  
  	File::Spec::Unix
  	File::Spec::Mac
  	File::Spec::OS2
  	File::Spec::Win32
  	File::Spec::VMS
  
  The module appropriate for the current OS is automatically loaded by
  File::Spec. Since some modules (like VMS) make use of facilities available
  only under that OS, it may not be possible to load all modules under all
  operating systems.
  
  Since File::Spec is object oriented, subroutines should not be called directly,
  as in:
  
  	File::Spec::catfile('a','b');
  
  but rather as class methods:
  
  	File::Spec->catfile('a','b');
  
  For simple uses, L<File::Spec::Functions> provides convenient functional
  forms of these methods.
  
  =head1 METHODS
  
  =over 2
  
  =item canonpath
  X<canonpath>
  
  No physical check on the filesystem, but a logical cleanup of a
  path.
  
      $cpath = File::Spec->canonpath( $path ) ;
  
  Note that this does *not* collapse F<x/../y> sections into F<y>.  This
  is by design.  If F</foo> on your system is a symlink to F</bar/baz>,
  then F</foo/../quux> is actually F</bar/quux>, not F</quux> as a naive
  F<../>-removal would give you.  If you want to do this kind of
  processing, you probably want C<Cwd>'s C<realpath()> function to
  actually traverse the filesystem cleaning up paths like this.
  
  =item catdir
  X<catdir>
  
  Concatenate two or more directory names to form a complete path ending
  with a directory. But remove the trailing slash from the resulting
  string, because it doesn't look good, isn't necessary and confuses
  OS/2. Of course, if this is the root directory, don't cut off the
  trailing slash :-)
  
      $path = File::Spec->catdir( @directories );
  
  =item catfile
  X<catfile>
  
  Concatenate one or more directory names and a filename to form a
  complete path ending with a filename
  
      $path = File::Spec->catfile( @directories, $filename );
  
  =item curdir
  X<curdir>
  
  Returns a string representation of the current directory.
  
      $curdir = File::Spec->curdir();
  
  =item devnull
  X<devnull>
  
  Returns a string representation of the null device.
  
      $devnull = File::Spec->devnull();
  
  =item rootdir
  X<rootdir>
  
  Returns a string representation of the root directory.
  
      $rootdir = File::Spec->rootdir();
  
  =item tmpdir
  X<tmpdir>
  
  Returns a string representation of the first writable directory from a
  list of possible temporary directories.  Returns the current directory
  if no writable temporary directories are found.  The list of directories
  checked depends on the platform; e.g. File::Spec::Unix checks C<$ENV{TMPDIR}>
  (unless taint is on) and F</tmp>.
  
      $tmpdir = File::Spec->tmpdir();
  
  =item updir
  X<updir>
  
  Returns a string representation of the parent directory.
  
      $updir = File::Spec->updir();
  
  =item no_upwards
  
  Given a list of file names, strip out those that refer to a parent
  directory. (Does not strip symlinks, only '.', '..', and equivalents.)
  
      @paths = File::Spec->no_upwards( @paths );
  
  =item case_tolerant
  
  Returns a true or false value indicating, respectively, that alphabetic
  case is not or is significant when comparing file specifications.
  
      $is_case_tolerant = File::Spec->case_tolerant();
  
  =item file_name_is_absolute
  
  Takes as its argument a path, and returns true if it is an absolute path.
  
      $is_absolute = File::Spec->file_name_is_absolute( $path );
  
  This does not consult the local filesystem on Unix, Win32, OS/2, or
  Mac OS (Classic).  It does consult the working environment for VMS
  (see L<File::Spec::VMS/file_name_is_absolute>).
  
  =item path
  X<path>
  
  Takes no argument.  Returns the environment variable C<PATH> (or the local
  platform's equivalent) as a list.
  
      @PATH = File::Spec->path();
  
  =item join
  X<join, path>
  
  join is the same as catfile.
  
  =item splitpath
  X<splitpath> X<split, path>
  
  Splits a path in to volume, directory, and filename portions. On systems
  with no concept of volume, returns '' for volume. 
  
      ($volume,$directories,$file) = File::Spec->splitpath( $path );
      ($volume,$directories,$file) = File::Spec->splitpath( $path, $no_file );
  
  For systems with no syntax differentiating filenames from directories, 
  assumes that the last file is a path unless C<$no_file> is true or a
  trailing separator or F</.> or F</..> is present. On Unix, this means that C<$no_file>
  true makes this return ( '', $path, '' ).
  
  The directory portion may or may not be returned with a trailing '/'.
  
  The results can be passed to L</catpath()> to get back a path equivalent to
  (usually identical to) the original path.
  
  =item splitdir
  X<splitdir> X<split, dir>
  
  The opposite of L</catdir()>.
  
      @dirs = File::Spec->splitdir( $directories );
  
  C<$directories> must be only the directory portion of the path on systems 
  that have the concept of a volume or that have path syntax that differentiates
  files from directories.
  
  Unlike just splitting the directories on the separator, empty
  directory names (C<''>) can be returned, because these are significant
  on some OSes.
  
  =item catpath()
  
  Takes volume, directory and file portions and returns an entire path. Under
  Unix, C<$volume> is ignored, and directory and file are concatenated.  A '/' is
  inserted if need be.  On other OSes, C<$volume> is significant.
  
      $full_path = File::Spec->catpath( $volume, $directory, $file );
  
  =item abs2rel
  X<abs2rel> X<absolute, path> X<relative, path>
  
  Takes a destination path and an optional base path returns a relative path
  from the base path to the destination path:
  
      $rel_path = File::Spec->abs2rel( $path ) ;
      $rel_path = File::Spec->abs2rel( $path, $base ) ;
  
  If C<$base> is not present or '', then L<Cwd::cwd()|Cwd> is used. If C<$base> is
  relative, then it is converted to absolute form using
  L</rel2abs()>. This means that it is taken to be relative to
  L<Cwd::cwd()|Cwd>.
  
  On systems with the concept of volume, if C<$path> and C<$base> appear to be
  on two different volumes, we will not attempt to resolve the two
  paths, and we will instead simply return C<$path>.  Note that previous
  versions of this module ignored the volume of C<$base>, which resulted in
  garbage results part of the time.
  
  On systems that have a grammar that indicates filenames, this ignores the 
  C<$base> filename as well. Otherwise all path components are assumed to be
  directories.
  
  If C<$path> is relative, it is converted to absolute form using L</rel2abs()>.
  This means that it is taken to be relative to L<Cwd::cwd()|Cwd>.
  
  No checks against the filesystem are made.  On VMS, there is
  interaction with the working environment, as logicals and
  macros are expanded.
  
  Based on code written by Shigio Yamaguchi.
  
  =item rel2abs()
  X<rel2abs> X<absolute, path> X<relative, path>
  
  Converts a relative path to an absolute path. 
  
      $abs_path = File::Spec->rel2abs( $path ) ;
      $abs_path = File::Spec->rel2abs( $path, $base ) ;
  
  If C<$base> is not present or '', then L<Cwd::cwd()|Cwd> is used. If C<$base> is relative,
  then it is converted to absolute form using L</rel2abs()>. This means that it
  is taken to be relative to L<Cwd::cwd()|Cwd>.
  
  On systems with the concept of volume, if C<$path> and C<$base> appear to be
  on two different volumes, we will not attempt to resolve the two
  paths, and we will instead simply return C<$path>.  Note that previous
  versions of this module ignored the volume of C<$base>, which resulted in
  garbage results part of the time.
  
  On systems that have a grammar that indicates filenames, this ignores the 
  C<$base> filename as well. Otherwise all path components are assumed to be
  directories.
  
  If C<$path> is absolute, it is cleaned up and returned using L</canonpath()>.
  
  No checks against the filesystem are made.  On VMS, there is
  interaction with the working environment, as logicals and
  macros are expanded.
  
  Based on code written by Shigio Yamaguchi.
  
  =back
  
  For further information, please see L<File::Spec::Unix>,
  L<File::Spec::Mac>, L<File::Spec::OS2>, L<File::Spec::Win32>, or
  L<File::Spec::VMS>.
  
  =head1 SEE ALSO
  
  L<File::Spec::Unix>, L<File::Spec::Mac>, L<File::Spec::OS2>,
  L<File::Spec::Win32>, L<File::Spec::VMS>, L<File::Spec::Functions>,
  L<ExtUtils::MakeMaker>
  
  =head1 AUTHOR
  
  Currently maintained by Ken Williams C<< <KWILLIAMS@cpan.org> >>.
  
  The vast majority of the code was written by
  Kenneth Albanowski C<< <kjahds@kjahds.com> >>,
  Andy Dougherty C<< <doughera@lafayette.edu> >>,
  Andreas KE<ouml>nig C<< <A.Koenig@franz.ww.TU-Berlin.DE> >>,
  Tim Bunce C<< <Tim.Bunce@ig.co.uk> >>.
  VMS support by Charles Bailey C<< <bailey@newman.upenn.edu> >>.
  OS/2 support by Ilya Zakharevich C<< <ilya@math.ohio-state.edu> >>.
  Mac support by Paul Schinder C<< <schinder@pobox.com> >>, and
  Thomas Wegner C<< <wegner_thomas@yahoo.com> >>.
  abs2rel() and rel2abs() written by Shigio Yamaguchi C<< <shigio@tamacom.com> >>,
  modified by Barrie Slaymaker C<< <barries@slaysys.com> >>.
  splitpath(), splitdir(), catpath() and catdir() by Barrie Slaymaker.
  
  =head1 COPYRIGHT
  
  Copyright (c) 2004 by the Perl 5 Porters.  All rights reserved.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =cut
I386-LINUX-THREAD-MULTI_FILE_SPEC

$fatpacked{"i386-linux-thread-multi/File/Spec/Cygwin.pm"} = <<'I386-LINUX-THREAD-MULTI_FILE_SPEC_CYGWIN';
  package File::Spec::Cygwin;
  
  use strict;
  use vars qw(@ISA $VERSION);
  require File::Spec::Unix;
  
  $VERSION = '3.30';
  $VERSION = eval $VERSION;
  
  @ISA = qw(File::Spec::Unix);
  
  =head1 NAME
  
  File::Spec::Cygwin - methods for Cygwin file specs
  
  =head1 SYNOPSIS
  
   require File::Spec::Cygwin; # Done internally by File::Spec if needed
  
  =head1 DESCRIPTION
  
  See L<File::Spec> and L<File::Spec::Unix>.  This package overrides the
  implementation of these methods, not the semantics.
  
  This module is still in beta.  Cygwin-knowledgeable folks are invited
  to offer patches and suggestions.
  
  =cut
  
  =pod
  
  =over 4
  
  =item canonpath
  
  Any C<\> (backslashes) are converted to C</> (forward slashes),
  and then File::Spec::Unix canonpath() is called on the result.
  
  =cut
  
  sub canonpath {
      my($self,$path) = @_;
      return unless defined $path;
  
      $path =~ s|\\|/|g;
  
      # Handle network path names beginning with double slash
      my $node = '';
      if ( $path =~ s@^(//[^/]+)(?:/|\z)@/@s ) {
          $node = $1;
      }
      return $node . $self->SUPER::canonpath($path);
  }
  
  sub catdir {
      my $self = shift;
      return unless @_;
  
      # Don't create something that looks like a //network/path
      if ($_[0] and ($_[0] eq '/' or $_[0] eq '\\')) {
          shift;
          return $self->SUPER::catdir('', @_);
      }
  
      $self->SUPER::catdir(@_);
  }
  
  =pod
  
  =item file_name_is_absolute
  
  True is returned if the file name begins with C<drive_letter:>,
  and if not, File::Spec::Unix file_name_is_absolute() is called.
  
  =cut
  
  
  sub file_name_is_absolute {
      my ($self,$file) = @_;
      return 1 if $file =~ m{^([a-z]:)?[\\/]}is; # C:/test
      return $self->SUPER::file_name_is_absolute($file);
  }
  
  =item tmpdir (override)
  
  Returns a string representation of the first existing directory
  from the following list:
  
      $ENV{TMPDIR}
      /tmp
      $ENV{'TMP'}
      $ENV{'TEMP'}
      C:/temp
  
  Since Perl 5.8.0, if running under taint mode, and if the environment
  variables are tainted, they are not used.
  
  =cut
  
  my $tmpdir;
  sub tmpdir {
      return $tmpdir if defined $tmpdir;
      $tmpdir = $_[0]->_tmpdir( $ENV{TMPDIR}, "/tmp", $ENV{'TMP'}, $ENV{'TEMP'}, 'C:/temp' );
  }
  
  =item case_tolerant
  
  Override Unix. Cygwin case-tolerance depends on managed mount settings and
  as with MsWin32 on GetVolumeInformation() $ouFsFlags == FS_CASE_SENSITIVE,
  indicating the case significance when comparing file specifications.
  Default: 1
  
  =cut
  
  sub case_tolerant {
    return 1 unless $^O eq 'cygwin'
      and defined &Cygwin::mount_flags;
  
    my $drive = shift;
    if (! $drive) {
        my @flags = split(/,/, Cygwin::mount_flags('/cygwin'));
        my $prefix = pop(@flags);
        if (! $prefix || $prefix eq 'cygdrive') {
            $drive = '/cygdrive/c';
        } elsif ($prefix eq '/') {
            $drive = '/c';
        } else {
            $drive = "$prefix/c";
        }
    }
    my $mntopts = Cygwin::mount_flags($drive);
    if ($mntopts and ($mntopts =~ /,managed/)) {
      return 0;
    }
    eval { require Win32API::File; } or return 1;
    my $osFsType = "\0"x256;
    my $osVolName = "\0"x256;
    my $ouFsFlags = 0;
    Win32API::File::GetVolumeInformation($drive, $osVolName, 256, [], [], $ouFsFlags, $osFsType, 256 );
    if ($ouFsFlags & Win32API::File::FS_CASE_SENSITIVE()) { return 0; }
    else { return 1; }
  }
  
  =back
  
  =head1 COPYRIGHT
  
  Copyright (c) 2004,2007 by the Perl 5 Porters.  All rights reserved.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =cut
  
  1;
I386-LINUX-THREAD-MULTI_FILE_SPEC_CYGWIN

$fatpacked{"i386-linux-thread-multi/File/Spec/Epoc.pm"} = <<'I386-LINUX-THREAD-MULTI_FILE_SPEC_EPOC';
  package File::Spec::Epoc;
  
  use strict;
  use vars qw($VERSION @ISA);
  
  $VERSION = '3.30';
  $VERSION = eval $VERSION;
  
  require File::Spec::Unix;
  @ISA = qw(File::Spec::Unix);
  
  =head1 NAME
  
  File::Spec::Epoc - methods for Epoc file specs
  
  =head1 SYNOPSIS
  
   require File::Spec::Epoc; # Done internally by File::Spec if needed
  
  =head1 DESCRIPTION
  
  See File::Spec::Unix for a documentation of the methods provided
  there. This package overrides the implementation of these methods, not
  the semantics.
  
  This package is still work in progress ;-)
  
  =cut
  
  sub case_tolerant {
      return 1;
  }
  
  =pod
  
  =over 4
  
  =item canonpath()
  
  No physical check on the filesystem, but a logical cleanup of a
  path. On UNIX eliminated successive slashes and successive "/.".
  
  =back
  
  =cut
  
  sub canonpath {
      my ($self,$path) = @_;
      return unless defined $path;
  
      $path =~ s|/+|/|g;                             # xx////xx  -> xx/xx
      $path =~ s|(/\.)+/|/|g;                        # xx/././xx -> xx/xx
      $path =~ s|^(\./)+||s unless $path eq "./";    # ./xx      -> xx
      $path =~ s|^/(\.\./)+|/|s;                     # /../../xx -> xx
      $path =~  s|/\Z(?!\n)|| unless $path eq "/";          # xx/       -> xx
      return $path;
  }
  
  =pod
  
  =head1 AUTHOR
  
  o.flebbe@gmx.de
  
  =head1 COPYRIGHT
  
  Copyright (c) 2004 by the Perl 5 Porters.  All rights reserved.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =head1 SEE ALSO
  
  See L<File::Spec> and L<File::Spec::Unix>.  This package overrides the
  implementation of these methods, not the semantics.
  
  =cut
  
  1;
I386-LINUX-THREAD-MULTI_FILE_SPEC_EPOC

$fatpacked{"i386-linux-thread-multi/File/Spec/Functions.pm"} = <<'I386-LINUX-THREAD-MULTI_FILE_SPEC_FUNCTIONS';
  package File::Spec::Functions;
  
  use File::Spec;
  use strict;
  
  use vars qw(@ISA @EXPORT @EXPORT_OK %EXPORT_TAGS $VERSION);
  
  $VERSION = '3.30';
  $VERSION = eval $VERSION;
  
  require Exporter;
  
  @ISA = qw(Exporter);
  
  @EXPORT = qw(
  	canonpath
  	catdir
  	catfile
  	curdir
  	rootdir
  	updir
  	no_upwards
  	file_name_is_absolute
  	path
  );
  
  @EXPORT_OK = qw(
  	devnull
  	tmpdir
  	splitpath
  	splitdir
  	catpath
  	abs2rel
  	rel2abs
  	case_tolerant
  );
  
  %EXPORT_TAGS = ( ALL => [ @EXPORT_OK, @EXPORT ] );
  
  foreach my $meth (@EXPORT, @EXPORT_OK) {
      my $sub = File::Spec->can($meth);
      no strict 'refs';
      *{$meth} = sub {&$sub('File::Spec', @_)};
  }
  
  
  1;
  __END__
  
  =head1 NAME
  
  File::Spec::Functions - portably perform operations on file names
  
  =head1 SYNOPSIS
  
  	use File::Spec::Functions;
  	$x = catfile('a','b');
  
  =head1 DESCRIPTION
  
  This module exports convenience functions for all of the class methods
  provided by File::Spec.
  
  For a reference of available functions, please consult L<File::Spec::Unix>,
  which contains the entire set, and which is inherited by the modules for
  other platforms. For further information, please see L<File::Spec::Mac>,
  L<File::Spec::OS2>, L<File::Spec::Win32>, or L<File::Spec::VMS>.
  
  =head2 Exports
  
  The following functions are exported by default.
  
  	canonpath
  	catdir
  	catfile
  	curdir
  	rootdir
  	updir
  	no_upwards
  	file_name_is_absolute
  	path
  
  
  The following functions are exported only by request.
  
  	devnull
  	tmpdir
  	splitpath
  	splitdir
  	catpath
  	abs2rel
  	rel2abs
  	case_tolerant
  
  All the functions may be imported using the C<:ALL> tag.
  
  =head1 COPYRIGHT
  
  Copyright (c) 2004 by the Perl 5 Porters.  All rights reserved.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =head1 SEE ALSO
  
  File::Spec, File::Spec::Unix, File::Spec::Mac, File::Spec::OS2,
  File::Spec::Win32, File::Spec::VMS, ExtUtils::MakeMaker
  
  =cut
  
I386-LINUX-THREAD-MULTI_FILE_SPEC_FUNCTIONS

$fatpacked{"i386-linux-thread-multi/File/Spec/Mac.pm"} = <<'I386-LINUX-THREAD-MULTI_FILE_SPEC_MAC';
  package File::Spec::Mac;
  
  use strict;
  use vars qw(@ISA $VERSION);
  require File::Spec::Unix;
  
  $VERSION = '3.30';
  $VERSION = eval $VERSION;
  
  @ISA = qw(File::Spec::Unix);
  
  my $macfiles;
  if ($^O eq 'MacOS') {
  	$macfiles = eval { require Mac::Files };
  }
  
  sub case_tolerant { 1 }
  
  
  =head1 NAME
  
  File::Spec::Mac - File::Spec for Mac OS (Classic)
  
  =head1 SYNOPSIS
  
   require File::Spec::Mac; # Done internally by File::Spec if needed
  
  =head1 DESCRIPTION
  
  Methods for manipulating file specifications.
  
  =head1 METHODS
  
  =over 2
  
  =item canonpath
  
  On Mac OS, there's nothing to be done. Returns what it's given.
  
  =cut
  
  sub canonpath {
      my ($self,$path) = @_;
      return $path;
  }
  
  =item catdir()
  
  Concatenate two or more directory names to form a path separated by colons
  (":") ending with a directory. Resulting paths are B<relative> by default,
  but can be forced to be absolute (but avoid this, see below). Automatically
  puts a trailing ":" on the end of the complete path, because that's what's
  done in MacPerl's environment and helps to distinguish a file path from a
  directory path.
  
  B<IMPORTANT NOTE:> Beginning with version 1.3 of this module, the resulting
  path is relative by default and I<not> absolute. This decision was made due
  to portability reasons. Since C<File::Spec-E<gt>catdir()> returns relative paths
  on all other operating systems, it will now also follow this convention on Mac
  OS. Note that this may break some existing scripts.
  
  The intended purpose of this routine is to concatenate I<directory names>.
  But because of the nature of Macintosh paths, some additional possibilities
  are allowed to make using this routine give reasonable results for some
  common situations. In other words, you are also allowed to concatenate
  I<paths> instead of directory names (strictly speaking, a string like ":a"
  is a path, but not a name, since it contains a punctuation character ":").
  
  So, beside calls like
  
      catdir("a") = ":a:"
      catdir("a","b") = ":a:b:"
      catdir() = ""                    (special case)
  
  calls like the following
  
      catdir(":a:") = ":a:"
      catdir(":a","b") = ":a:b:"
      catdir(":a:","b") = ":a:b:"
      catdir(":a:",":b:") = ":a:b:"
      catdir(":") = ":"
  
  are allowed.
  
  Here are the rules that are used in C<catdir()>; note that we try to be as
  compatible as possible to Unix:
  
  =over 2
  
  =item 1.
  
  The resulting path is relative by default, i.e. the resulting path will have a
  leading colon.
  
  =item 2.
  
  A trailing colon is added automatically to the resulting path, to denote a
  directory.
  
  =item 3.
  
  Generally, each argument has one leading ":" and one trailing ":"
  removed (if any). They are then joined together by a ":". Special
  treatment applies for arguments denoting updir paths like "::lib:",
  see (4), or arguments consisting solely of colons ("colon paths"),
  see (5).
  
  =item 4.
  
  When an updir path like ":::lib::" is passed as argument, the number
  of directories to climb up is handled correctly, not removing leading
  or trailing colons when necessary. E.g.
  
      catdir(":::a","::b","c")    = ":::a::b:c:"
      catdir(":::a::","::b","c")  = ":::a:::b:c:"
  
  =item 5.
  
  Adding a colon ":" or empty string "" to a path at I<any> position
  doesn't alter the path, i.e. these arguments are ignored. (When a ""
  is passed as the first argument, it has a special meaning, see
  (6)). This way, a colon ":" is handled like a "." (curdir) on Unix,
  while an empty string "" is generally ignored (see
  C<Unix-E<gt>canonpath()> ). Likewise, a "::" is handled like a ".."
  (updir), and a ":::" is handled like a "../.." etc.  E.g.
  
      catdir("a",":",":","b")   = ":a:b:"
      catdir("a",":","::",":b") = ":a::b:"
  
  =item 6.
  
  If the first argument is an empty string "" or is a volume name, i.e. matches
  the pattern /^[^:]+:/, the resulting path is B<absolute>.
  
  =item 7.
  
  Passing an empty string "" as the first argument to C<catdir()> is
  like passingC<File::Spec-E<gt>rootdir()> as the first argument, i.e.
  
      catdir("","a","b")          is the same as
  
      catdir(rootdir(),"a","b").
  
  This is true on Unix, where C<catdir("","a","b")> yields "/a/b" and
  C<rootdir()> is "/". Note that C<rootdir()> on Mac OS is the startup
  volume, which is the closest in concept to Unix' "/". This should help
  to run existing scripts originally written for Unix.
  
  =item 8.
  
  For absolute paths, some cleanup is done, to ensure that the volume
  name isn't immediately followed by updirs. This is invalid, because
  this would go beyond "root". Generally, these cases are handled like
  their Unix counterparts:
  
   Unix:
      Unix->catdir("","")                 =  "/"
      Unix->catdir("",".")                =  "/"
      Unix->catdir("","..")               =  "/"              # can't go beyond root
      Unix->catdir("",".","..","..","a")  =  "/a"
   Mac:
      Mac->catdir("","")                  =  rootdir()         # (e.g. "HD:")
      Mac->catdir("",":")                 =  rootdir()
      Mac->catdir("","::")                =  rootdir()         # can't go beyond root
      Mac->catdir("",":","::","::","a")   =  rootdir() . "a:"  # (e.g. "HD:a:")
  
  However, this approach is limited to the first arguments following
  "root" (again, see C<Unix-E<gt>canonpath()> ). If there are more
  arguments that move up the directory tree, an invalid path going
  beyond root can be created.
  
  =back
  
  As you've seen, you can force C<catdir()> to create an absolute path
  by passing either an empty string or a path that begins with a volume
  name as the first argument. However, you are strongly encouraged not
  to do so, since this is done only for backward compatibility. Newer
  versions of File::Spec come with a method called C<catpath()> (see
  below), that is designed to offer a portable solution for the creation
  of absolute paths.  It takes volume, directory and file portions and
  returns an entire path. While C<catdir()> is still suitable for the
  concatenation of I<directory names>, you are encouraged to use
  C<catpath()> to concatenate I<volume names> and I<directory
  paths>. E.g.
  
      $dir      = File::Spec->catdir("tmp","sources");
      $abs_path = File::Spec->catpath("MacintoshHD:", $dir,"");
  
  yields
  
      "MacintoshHD:tmp:sources:" .
  
  =cut
  
  sub catdir {
  	my $self = shift;
  	return '' unless @_;
  	my @args = @_;
  	my $first_arg;
  	my $relative;
  
  	# take care of the first argument
  
  	if ($args[0] eq '')  { # absolute path, rootdir
  		shift @args;
  		$relative = 0;
  		$first_arg = $self->rootdir;
  
  	} elsif ($args[0] =~ /^[^:]+:/) { # absolute path, volume name
  		$relative = 0;
  		$first_arg = shift @args;
  		# add a trailing ':' if need be (may be it's a path like HD:dir)
  		$first_arg = "$first_arg:" unless ($first_arg =~ /:\Z(?!\n)/);
  
  	} else { # relative path
  		$relative = 1;
  		if ( $args[0] =~ /^::+\Z(?!\n)/ ) {
  			# updir colon path ('::', ':::' etc.), don't shift
  			$first_arg = ':';
  		} elsif ($args[0] eq ':') {
  			$first_arg = shift @args;
  		} else {
  			# add a trailing ':' if need be
  			$first_arg = shift @args;
  			$first_arg = "$first_arg:" unless ($first_arg =~ /:\Z(?!\n)/);
  		}
  	}
  
  	# For all other arguments,
  	# (a) ignore arguments that equal ':' or '',
  	# (b) handle updir paths specially:
  	#     '::' 			-> concatenate '::'
  	#     '::' . '::' 	-> concatenate ':::' etc.
  	# (c) add a trailing ':' if need be
  
  	my $result = $first_arg;
  	while (@args) {
  		my $arg = shift @args;
  		unless (($arg eq '') || ($arg eq ':')) {
  			if ($arg =~ /^::+\Z(?!\n)/ ) { # updir colon path like ':::'
  				my $updir_count = length($arg) - 1;
  				while ((@args) && ($args[0] =~ /^::+\Z(?!\n)/) ) { # while updir colon path
  					$arg = shift @args;
  					$updir_count += (length($arg) - 1);
  				}
  				$arg = (':' x $updir_count);
  			} else {
  				$arg =~ s/^://s; # remove a leading ':' if any
  				$arg = "$arg:" unless ($arg =~ /:\Z(?!\n)/); # ensure trailing ':'
  			}
  			$result .= $arg;
  		}#unless
  	}
  
  	if ( ($relative) && ($result !~ /^:/) ) {
  		# add a leading colon if need be
  		$result = ":$result";
  	}
  
  	unless ($relative) {
  		# remove updirs immediately following the volume name
  		$result =~ s/([^:]+:)(:*)(.*)\Z(?!\n)/$1$3/;
  	}
  
  	return $result;
  }
  
  =item catfile
  
  Concatenate one or more directory names and a filename to form a
  complete path ending with a filename. Resulting paths are B<relative>
  by default, but can be forced to be absolute (but avoid this).
  
  B<IMPORTANT NOTE:> Beginning with version 1.3 of this module, the
  resulting path is relative by default and I<not> absolute. This
  decision was made due to portability reasons. Since
  C<File::Spec-E<gt>catfile()> returns relative paths on all other
  operating systems, it will now also follow this convention on Mac OS.
  Note that this may break some existing scripts.
  
  The last argument is always considered to be the file portion. Since
  C<catfile()> uses C<catdir()> (see above) for the concatenation of the
  directory portions (if any), the following with regard to relative and
  absolute paths is true:
  
      catfile("")     = ""
      catfile("file") = "file"
  
  but
  
      catfile("","")        = rootdir()         # (e.g. "HD:")
      catfile("","file")    = rootdir() . file  # (e.g. "HD:file")
      catfile("HD:","file") = "HD:file"
  
  This means that C<catdir()> is called only when there are two or more
  arguments, as one might expect.
  
  Note that the leading ":" is removed from the filename, so that
  
      catfile("a","b","file")  = ":a:b:file"    and
  
      catfile("a","b",":file") = ":a:b:file"
  
  give the same answer.
  
  To concatenate I<volume names>, I<directory paths> and I<filenames>,
  you are encouraged to use C<catpath()> (see below).
  
  =cut
  
  sub catfile {
      my $self = shift;
      return '' unless @_;
      my $file = pop @_;
      return $file unless @_;
      my $dir = $self->catdir(@_);
      $file =~ s/^://s;
      return $dir.$file;
  }
  
  =item curdir
  
  Returns a string representing the current directory. On Mac OS, this is ":".
  
  =cut
  
  sub curdir {
      return ":";
  }
  
  =item devnull
  
  Returns a string representing the null device. On Mac OS, this is "Dev:Null".
  
  =cut
  
  sub devnull {
      return "Dev:Null";
  }
  
  =item rootdir
  
  Returns a string representing the root directory.  Under MacPerl,
  returns the name of the startup volume, since that's the closest in
  concept, although other volumes aren't rooted there. The name has a
  trailing ":", because that's the correct specification for a volume
  name on Mac OS.
  
  If Mac::Files could not be loaded, the empty string is returned.
  
  =cut
  
  sub rootdir {
  #
  #  There's no real root directory on Mac OS. The name of the startup
  #  volume is returned, since that's the closest in concept.
  #
      return '' unless $macfiles;
      my $system = Mac::Files::FindFolder(&Mac::Files::kOnSystemDisk,
  	&Mac::Files::kSystemFolderType);
      $system =~ s/:.*\Z(?!\n)/:/s;
      return $system;
  }
  
  =item tmpdir
  
  Returns the contents of $ENV{TMPDIR}, if that directory exits or the
  current working directory otherwise. Under MacPerl, $ENV{TMPDIR} will
  contain a path like "MacintoshHD:Temporary Items:", which is a hidden
  directory on your startup volume.
  
  =cut
  
  my $tmpdir;
  sub tmpdir {
      return $tmpdir if defined $tmpdir;
      $tmpdir = $_[0]->_tmpdir( $ENV{TMPDIR} );
  }
  
  =item updir
  
  Returns a string representing the parent directory. On Mac OS, this is "::".
  
  =cut
  
  sub updir {
      return "::";
  }
  
  =item file_name_is_absolute
  
  Takes as argument a path and returns true, if it is an absolute path.
  If the path has a leading ":", it's a relative path. Otherwise, it's an
  absolute path, unless the path doesn't contain any colons, i.e. it's a name
  like "a". In this particular case, the path is considered to be relative
  (i.e. it is considered to be a filename). Use ":" in the appropriate place
  in the path if you want to distinguish unambiguously. As a special case,
  the filename '' is always considered to be absolute. Note that with version
  1.2 of File::Spec::Mac, this does no longer consult the local filesystem.
  
  E.g.
  
      File::Spec->file_name_is_absolute("a");             # false (relative)
      File::Spec->file_name_is_absolute(":a:b:");         # false (relative)
      File::Spec->file_name_is_absolute("MacintoshHD:");  # true (absolute)
      File::Spec->file_name_is_absolute("");              # true (absolute)
  
  
  =cut
  
  sub file_name_is_absolute {
      my ($self,$file) = @_;
      if ($file =~ /:/) {
  	return (! ($file =~ m/^:/s) );
      } elsif ( $file eq '' ) {
          return 1 ;
      } else {
  	return 0; # i.e. a file like "a"
      }
  }
  
  =item path
  
  Returns the null list for the MacPerl application, since the concept is
  usually meaningless under Mac OS. But if you're using the MacPerl tool under
  MPW, it gives back $ENV{Commands} suitably split, as is done in
  :lib:ExtUtils:MM_Mac.pm.
  
  =cut
  
  sub path {
  #
  #  The concept is meaningless under the MacPerl application.
  #  Under MPW, it has a meaning.
  #
      return unless exists $ENV{Commands};
      return split(/,/, $ENV{Commands});
  }
  
  =item splitpath
  
      ($volume,$directories,$file) = File::Spec->splitpath( $path );
      ($volume,$directories,$file) = File::Spec->splitpath( $path, $no_file );
  
  Splits a path into volume, directory, and filename portions.
  
  On Mac OS, assumes that the last part of the path is a filename unless
  $no_file is true or a trailing separator ":" is present.
  
  The volume portion is always returned with a trailing ":". The directory portion
  is always returned with a leading (to denote a relative path) and a trailing ":"
  (to denote a directory). The file portion is always returned I<without> a leading ":".
  Empty portions are returned as empty string ''.
  
  The results can be passed to C<catpath()> to get back a path equivalent to
  (usually identical to) the original path.
  
  
  =cut
  
  sub splitpath {
      my ($self,$path, $nofile) = @_;
      my ($volume,$directory,$file);
  
      if ( $nofile ) {
          ( $volume, $directory ) = $path =~ m|^((?:[^:]+:)?)(.*)|s;
      }
      else {
          $path =~
              m|^( (?: [^:]+: )? )
                 ( (?: .*: )? )
                 ( .* )
               |xs;
          $volume    = $1;
          $directory = $2;
          $file      = $3;
      }
  
      $volume = '' unless defined($volume);
  	$directory = ":$directory" if ( $volume && $directory ); # take care of "HD::dir"
      if ($directory) {
          # Make sure non-empty directories begin and end in ':'
          $directory .= ':' unless (substr($directory,-1) eq ':');
          $directory = ":$directory" unless (substr($directory,0,1) eq ':');
      } else {
  	$directory = '';
      }
      $file = '' unless defined($file);
  
      return ($volume,$directory,$file);
  }
  
  
  =item splitdir
  
  The opposite of C<catdir()>.
  
      @dirs = File::Spec->splitdir( $directories );
  
  $directories should be only the directory portion of the path on systems
  that have the concept of a volume or that have path syntax that differentiates
  files from directories. Consider using C<splitpath()> otherwise.
  
  Unlike just splitting the directories on the separator, empty directory names
  (C<"">) can be returned. Since C<catdir()> on Mac OS always appends a trailing
  colon to distinguish a directory path from a file path, a single trailing colon
  will be ignored, i.e. there's no empty directory name after it.
  
  Hence, on Mac OS, both
  
      File::Spec->splitdir( ":a:b::c:" );    and
      File::Spec->splitdir( ":a:b::c" );
  
  yield:
  
      ( "a", "b", "::", "c")
  
  while
  
      File::Spec->splitdir( ":a:b::c::" );
  
  yields:
  
      ( "a", "b", "::", "c", "::")
  
  
  =cut
  
  sub splitdir {
  	my ($self, $path) = @_;
  	my @result = ();
  	my ($head, $sep, $tail, $volume, $directories);
  
  	return @result if ( (!defined($path)) || ($path eq '') );
  	return (':') if ($path eq ':');
  
  	( $volume, $sep, $directories ) = $path =~ m|^((?:[^:]+:)?)(:*)(.*)|s;
  
  	# deprecated, but handle it correctly
  	if ($volume) {
  		push (@result, $volume);
  		$sep .= ':';
  	}
  
  	while ($sep || $directories) {
  		if (length($sep) > 1) {
  			my $updir_count = length($sep) - 1;
  			for (my $i=0; $i<$updir_count; $i++) {
  				# push '::' updir_count times;
  				# simulate Unix '..' updirs
  				push (@result, '::');
  			}
  		}
  		$sep = '';
  		if ($directories) {
  			( $head, $sep, $tail ) = $directories =~ m|^((?:[^:]+)?)(:*)(.*)|s;
  			push (@result, $head);
  			$directories = $tail;
  		}
  	}
  	return @result;
  }
  
  
  =item catpath
  
      $path = File::Spec->catpath($volume,$directory,$file);
  
  Takes volume, directory and file portions and returns an entire path. On Mac OS,
  $volume, $directory and $file are concatenated.  A ':' is inserted if need be. You
  may pass an empty string for each portion. If all portions are empty, the empty
  string is returned. If $volume is empty, the result will be a relative path,
  beginning with a ':'. If $volume and $directory are empty, a leading ":" (if any)
  is removed form $file and the remainder is returned. If $file is empty, the
  resulting path will have a trailing ':'.
  
  
  =cut
  
  sub catpath {
      my ($self,$volume,$directory,$file) = @_;
  
      if ( (! $volume) && (! $directory) ) {
  	$file =~ s/^:// if $file;
  	return $file ;
      }
  
      # We look for a volume in $volume, then in $directory, but not both
  
      my ($dir_volume, $dir_dirs) = $self->splitpath($directory, 1);
  
      $volume = $dir_volume unless length $volume;
      my $path = $volume; # may be ''
      $path .= ':' unless (substr($path, -1) eq ':'); # ensure trailing ':'
  
      if ($directory) {
  	$directory = $dir_dirs if $volume;
  	$directory =~ s/^://; # remove leading ':' if any
  	$path .= $directory;
  	$path .= ':' unless (substr($path, -1) eq ':'); # ensure trailing ':'
      }
  
      if ($file) {
  	$file =~ s/^://; # remove leading ':' if any
  	$path .= $file;
      }
  
      return $path;
  }
  
  =item abs2rel
  
  Takes a destination path and an optional base path and returns a relative path
  from the base path to the destination path:
  
      $rel_path = File::Spec->abs2rel( $path ) ;
      $rel_path = File::Spec->abs2rel( $path, $base ) ;
  
  Note that both paths are assumed to have a notation that distinguishes a
  directory path (with trailing ':') from a file path (without trailing ':').
  
  If $base is not present or '', then the current working directory is used.
  If $base is relative, then it is converted to absolute form using C<rel2abs()>.
  This means that it is taken to be relative to the current working directory.
  
  If $path and $base appear to be on two different volumes, we will not
  attempt to resolve the two paths, and we will instead simply return
  $path.  Note that previous versions of this module ignored the volume
  of $base, which resulted in garbage results part of the time.
  
  If $base doesn't have a trailing colon, the last element of $base is
  assumed to be a filename.  This filename is ignored.  Otherwise all path
  components are assumed to be directories.
  
  If $path is relative, it is converted to absolute form using C<rel2abs()>.
  This means that it is taken to be relative to the current working directory.
  
  Based on code written by Shigio Yamaguchi.
  
  
  =cut
  
  # maybe this should be done in canonpath() ?
  sub _resolve_updirs {
  	my $path = shift @_;
  	my $proceed;
  
  	# resolve any updirs, e.g. "HD:tmp::file" -> "HD:file"
  	do {
  		$proceed = ($path =~ s/^(.*):[^:]+::(.*?)\z/$1:$2/);
  	} while ($proceed);
  
  	return $path;
  }
  
  
  sub abs2rel {
      my($self,$path,$base) = @_;
  
      # Clean up $path
      if ( ! $self->file_name_is_absolute( $path ) ) {
          $path = $self->rel2abs( $path ) ;
      }
  
      # Figure out the effective $base and clean it up.
      if ( !defined( $base ) || $base eq '' ) {
  	$base = $self->_cwd();
      }
      elsif ( ! $self->file_name_is_absolute( $base ) ) {
          $base = $self->rel2abs( $base ) ;
  	$base = _resolve_updirs( $base ); # resolve updirs in $base
      }
      else {
  	$base = _resolve_updirs( $base );
      }
  
      # Split up paths - ignore $base's file
      my ( $path_vol, $path_dirs, $path_file ) =  $self->splitpath( $path );
      my ( $base_vol, $base_dirs )             =  $self->splitpath( $base );
  
      return $path unless lc( $path_vol ) eq lc( $base_vol );
  
      # Now, remove all leading components that are the same
      my @pathchunks = $self->splitdir( $path_dirs );
      my @basechunks = $self->splitdir( $base_dirs );
  	
      while ( @pathchunks &&
  	    @basechunks &&
  	    lc( $pathchunks[0] ) eq lc( $basechunks[0] ) ) {
          shift @pathchunks ;
          shift @basechunks ;
      }
  
      # @pathchunks now has the directories to descend in to.
      # ensure relative path, even if @pathchunks is empty
      $path_dirs = $self->catdir( ':', @pathchunks );
  
      # @basechunks now contains the number of directories to climb out of.
      $base_dirs = (':' x @basechunks) . ':' ;
  
      return $self->catpath( '', $self->catdir( $base_dirs, $path_dirs ), $path_file ) ;
  }
  
  =item rel2abs
  
  Converts a relative path to an absolute path:
  
      $abs_path = File::Spec->rel2abs( $path ) ;
      $abs_path = File::Spec->rel2abs( $path, $base ) ;
  
  Note that both paths are assumed to have a notation that distinguishes a
  directory path (with trailing ':') from a file path (without trailing ':').
  
  If $base is not present or '', then $base is set to the current working
  directory. If $base is relative, then it is converted to absolute form
  using C<rel2abs()>. This means that it is taken to be relative to the
  current working directory.
  
  If $base doesn't have a trailing colon, the last element of $base is
  assumed to be a filename.  This filename is ignored.  Otherwise all path
  components are assumed to be directories.
  
  If $path is already absolute, it is returned and $base is ignored.
  
  Based on code written by Shigio Yamaguchi.
  
  =cut
  
  sub rel2abs {
      my ($self,$path,$base) = @_;
  
      if ( ! $self->file_name_is_absolute($path) ) {
          # Figure out the effective $base and clean it up.
          if ( !defined( $base ) || $base eq '' ) {
  	    $base = $self->_cwd();
          }
          elsif ( ! $self->file_name_is_absolute($base) ) {
              $base = $self->rel2abs($base) ;
          }
  
  	# Split up paths
  
  	# igonore $path's volume
          my ( $path_dirs, $path_file ) = ($self->splitpath($path))[1,2] ;
  
          # ignore $base's file part
  	my ( $base_vol, $base_dirs ) = $self->splitpath($base) ;
  
  	# Glom them together
  	$path_dirs = ':' if ($path_dirs eq '');
  	$base_dirs =~ s/:$//; # remove trailing ':', if any
  	$base_dirs = $base_dirs . $path_dirs;
  
          $path = $self->catpath( $base_vol, $base_dirs, $path_file );
      }
      return $path;
  }
  
  
  =back
  
  =head1 AUTHORS
  
  See the authors list in I<File::Spec>. Mac OS support by Paul Schinder
  <schinder@pobox.com> and Thomas Wegner <wegner_thomas@yahoo.com>.
  
  =head1 COPYRIGHT
  
  Copyright (c) 2004 by the Perl 5 Porters.  All rights reserved.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =head1 SEE ALSO
  
  See L<File::Spec> and L<File::Spec::Unix>.  This package overrides the
  implementation of these methods, not the semantics.
  
  =cut
  
  1;
I386-LINUX-THREAD-MULTI_FILE_SPEC_MAC

$fatpacked{"i386-linux-thread-multi/File/Spec/OS2.pm"} = <<'I386-LINUX-THREAD-MULTI_FILE_SPEC_OS2';
  package File::Spec::OS2;
  
  use strict;
  use vars qw(@ISA $VERSION);
  require File::Spec::Unix;
  
  $VERSION = '3.30';
  $VERSION = eval $VERSION;
  
  @ISA = qw(File::Spec::Unix);
  
  sub devnull {
      return "/dev/nul";
  }
  
  sub case_tolerant {
      return 1;
  }
  
  sub file_name_is_absolute {
      my ($self,$file) = @_;
      return scalar($file =~ m{^([a-z]:)?[\\/]}is);
  }
  
  sub path {
      my $path = $ENV{PATH};
      $path =~ s:\\:/:g;
      my @path = split(';',$path);
      foreach (@path) { $_ = '.' if $_ eq '' }
      return @path;
  }
  
  sub _cwd {
      # In OS/2 the "require Cwd" is unnecessary bloat.
      return Cwd::sys_cwd();
  }
  
  my $tmpdir;
  sub tmpdir {
      return $tmpdir if defined $tmpdir;
      my @d = @ENV{qw(TMPDIR TEMP TMP)};	# function call could autovivivy
      $tmpdir = $_[0]->_tmpdir( @d, '/tmp', '/'  );
  }
  
  sub catdir {
      my $self = shift;
      my @args = @_;
      foreach (@args) {
  	tr[\\][/];
          # append a backslash to each argument unless it has one there
          $_ .= "/" unless m{/$};
      }
      return $self->canonpath(join('', @args));
  }
  
  sub canonpath {
      my ($self,$path) = @_;
      return unless defined $path;
  
      $path =~ s/^([a-z]:)/\l$1/s;
      $path =~ s|\\|/|g;
      $path =~ s|([^/])/+|$1/|g;                  # xx////xx  -> xx/xx
      $path =~ s|(/\.)+/|/|g;                     # xx/././xx -> xx/xx
      $path =~ s|^(\./)+(?=[^/])||s;		# ./xx      -> xx
      $path =~ s|/\Z(?!\n)||
               unless $path =~ m#^([a-z]:)?/\Z(?!\n)#si;# xx/       -> xx
      $path =~ s{^/\.\.$}{/};                     # /..    -> /
      1 while $path =~ s{^/\.\.}{};               # /../xx -> /xx
      return $path;
  }
  
  
  sub splitpath {
      my ($self,$path, $nofile) = @_;
      my ($volume,$directory,$file) = ('','','');
      if ( $nofile ) {
          $path =~ 
              m{^( (?:[a-zA-Z]:|(?:\\\\|//)[^\\/]+[\\/][^\\/]+)? ) 
                   (.*)
               }xs;
          $volume    = $1;
          $directory = $2;
      }
      else {
          $path =~ 
              m{^ ( (?: [a-zA-Z]: |
                        (?:\\\\|//)[^\\/]+[\\/][^\\/]+
                    )?
                  )
                  ( (?:.*[\\\\/](?:\.\.?\Z(?!\n))?)? )
                  (.*)
               }xs;
          $volume    = $1;
          $directory = $2;
          $file      = $3;
      }
  
      return ($volume,$directory,$file);
  }
  
  
  sub splitdir {
      my ($self,$directories) = @_ ;
      split m|[\\/]|, $directories, -1;
  }
  
  
  sub catpath {
      my ($self,$volume,$directory,$file) = @_;
  
      # If it's UNC, make sure the glue separator is there, reusing
      # whatever separator is first in the $volume
      $volume .= $1
          if ( $volume =~ m@^([\\/])[\\/][^\\/]+[\\/][^\\/]+\Z(?!\n)@s &&
               $directory =~ m@^[^\\/]@s
             ) ;
  
      $volume .= $directory ;
  
      # If the volume is not just A:, make sure the glue separator is 
      # there, reusing whatever separator is first in the $volume if possible.
      if ( $volume !~ m@^[a-zA-Z]:\Z(?!\n)@s &&
           $volume =~ m@[^\\/]\Z(?!\n)@      &&
           $file   =~ m@[^\\/]@
         ) {
          $volume =~ m@([\\/])@ ;
          my $sep = $1 ? $1 : '/' ;
          $volume .= $sep ;
      }
  
      $volume .= $file ;
  
      return $volume ;
  }
  
  
  sub abs2rel {
      my($self,$path,$base) = @_;
  
      # Clean up $path
      if ( ! $self->file_name_is_absolute( $path ) ) {
          $path = $self->rel2abs( $path ) ;
      } else {
          $path = $self->canonpath( $path ) ;
      }
  
      # Figure out the effective $base and clean it up.
      if ( !defined( $base ) || $base eq '' ) {
  	$base = $self->_cwd();
      } elsif ( ! $self->file_name_is_absolute( $base ) ) {
          $base = $self->rel2abs( $base ) ;
      } else {
          $base = $self->canonpath( $base ) ;
      }
  
      # Split up paths
      my ( $path_volume, $path_directories, $path_file ) = $self->splitpath( $path, 1 ) ;
      my ( $base_volume, $base_directories ) = $self->splitpath( $base, 1 ) ;
      return $path unless $path_volume eq $base_volume;
  
      # Now, remove all leading components that are the same
      my @pathchunks = $self->splitdir( $path_directories );
      my @basechunks = $self->splitdir( $base_directories );
  
      while ( @pathchunks && 
              @basechunks && 
              lc( $pathchunks[0] ) eq lc( $basechunks[0] ) 
            ) {
          shift @pathchunks ;
          shift @basechunks ;
      }
  
      # No need to catdir, we know these are well formed.
      $path_directories = CORE::join( '/', @pathchunks );
      $base_directories = CORE::join( '/', @basechunks );
  
      # $base_directories now contains the directories the resulting relative
      # path must ascend out of before it can descend to $path_directory.  So, 
      # replace all names with $parentDir
  
      #FA Need to replace between backslashes...
      $base_directories =~ s|[^\\/]+|..|g ;
  
      # Glue the two together, using a separator if necessary, and preventing an
      # empty result.
  
      #FA Must check that new directories are not empty.
      if ( $path_directories ne '' && $base_directories ne '' ) {
          $path_directories = "$base_directories/$path_directories" ;
      } else {
          $path_directories = "$base_directories$path_directories" ;
      }
  
      return $self->canonpath( 
          $self->catpath( "", $path_directories, $path_file ) 
      ) ;
  }
  
  
  sub rel2abs {
      my ($self,$path,$base ) = @_;
  
      if ( ! $self->file_name_is_absolute( $path ) ) {
  
          if ( !defined( $base ) || $base eq '' ) {
  	    $base = $self->_cwd();
          }
          elsif ( ! $self->file_name_is_absolute( $base ) ) {
              $base = $self->rel2abs( $base ) ;
          }
          else {
              $base = $self->canonpath( $base ) ;
          }
  
          my ( $path_directories, $path_file ) =
              ($self->splitpath( $path, 1 ))[1,2] ;
  
          my ( $base_volume, $base_directories ) =
              $self->splitpath( $base, 1 ) ;
  
          $path = $self->catpath( 
              $base_volume, 
              $self->catdir( $base_directories, $path_directories ), 
              $path_file
          ) ;
      }
  
      return $self->canonpath( $path ) ;
  }
  
  1;
  __END__
  
  =head1 NAME
  
  File::Spec::OS2 - methods for OS/2 file specs
  
  =head1 SYNOPSIS
  
   require File::Spec::OS2; # Done internally by File::Spec if needed
  
  =head1 DESCRIPTION
  
  See L<File::Spec> and L<File::Spec::Unix>.  This package overrides the
  implementation of these methods, not the semantics.
  
  Amongst the changes made for OS/2 are...
  
  =over 4
  
  =item tmpdir
  
  Modifies the list of places temp directory information is looked for.
  
      $ENV{TMPDIR}
      $ENV{TEMP}
      $ENV{TMP}
      /tmp
      /
  
  =item splitpath
  
  Volumes can be drive letters or UNC sharenames (\\server\share).
  
  =back
  
  =head1 COPYRIGHT
  
  Copyright (c) 2004 by the Perl 5 Porters.  All rights reserved.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =cut
I386-LINUX-THREAD-MULTI_FILE_SPEC_OS2

$fatpacked{"i386-linux-thread-multi/File/Spec/Unix.pm"} = <<'I386-LINUX-THREAD-MULTI_FILE_SPEC_UNIX';
  package File::Spec::Unix;
  
  use strict;
  use vars qw($VERSION);
  
  $VERSION = '3.30';
  $VERSION = eval $VERSION;
  
  =head1 NAME
  
  File::Spec::Unix - File::Spec for Unix, base for other File::Spec modules
  
  =head1 SYNOPSIS
  
   require File::Spec::Unix; # Done automatically by File::Spec
  
  =head1 DESCRIPTION
  
  Methods for manipulating file specifications.  Other File::Spec
  modules, such as File::Spec::Mac, inherit from File::Spec::Unix and
  override specific methods.
  
  =head1 METHODS
  
  =over 2
  
  =item canonpath()
  
  No physical check on the filesystem, but a logical cleanup of a
  path. On UNIX eliminates successive slashes and successive "/.".
  
      $cpath = File::Spec->canonpath( $path ) ;
  
  Note that this does *not* collapse F<x/../y> sections into F<y>.  This
  is by design.  If F</foo> on your system is a symlink to F</bar/baz>,
  then F</foo/../quux> is actually F</bar/quux>, not F</quux> as a naive
  F<../>-removal would give you.  If you want to do this kind of
  processing, you probably want C<Cwd>'s C<realpath()> function to
  actually traverse the filesystem cleaning up paths like this.
  
  =cut
  
  sub canonpath {
      my ($self,$path) = @_;
      return unless defined $path;
      
      # Handle POSIX-style node names beginning with double slash (qnx, nto)
      # (POSIX says: "a pathname that begins with two successive slashes
      # may be interpreted in an implementation-defined manner, although
      # more than two leading slashes shall be treated as a single slash.")
      my $node = '';
      my $double_slashes_special = $^O eq 'qnx' || $^O eq 'nto';
  
  
      if ( $double_slashes_special
           && ( $path =~ s{^(//[^/]+)/?\z}{}s || $path =~ s{^(//[^/]+)/}{/}s ) ) {
        $node = $1;
      }
      # This used to be
      # $path =~ s|/+|/|g unless ($^O eq 'cygwin');
      # but that made tests 29, 30, 35, 46, and 213 (as of #13272) to fail
      # (Mainly because trailing "" directories didn't get stripped).
      # Why would cygwin avoid collapsing multiple slashes into one? --jhi
      $path =~ s|/{2,}|/|g;                            # xx////xx  -> xx/xx
      $path =~ s{(?:/\.)+(?:/|\z)}{/}g;                # xx/././xx -> xx/xx
      $path =~ s|^(?:\./)+||s unless $path eq "./";    # ./xx      -> xx
      $path =~ s|^/(?:\.\./)+|/|;                      # /../../xx -> xx
      $path =~ s|^/\.\.$|/|;                         # /..       -> /
      $path =~ s|/\z|| unless $path eq "/";          # xx/       -> xx
      return "$node$path";
  }
  
  =item catdir()
  
  Concatenate two or more directory names to form a complete path ending
  with a directory. But remove the trailing slash from the resulting
  string, because it doesn't look good, isn't necessary and confuses
  OS2. Of course, if this is the root directory, don't cut off the
  trailing slash :-)
  
  =cut
  
  sub catdir {
      my $self = shift;
  
      $self->canonpath(join('/', @_, '')); # '' because need a trailing '/'
  }
  
  =item catfile
  
  Concatenate one or more directory names and a filename to form a
  complete path ending with a filename
  
  =cut
  
  sub catfile {
      my $self = shift;
      my $file = $self->canonpath(pop @_);
      return $file unless @_;
      my $dir = $self->catdir(@_);
      $dir .= "/" unless substr($dir,-1) eq "/";
      return $dir.$file;
  }
  
  =item curdir
  
  Returns a string representation of the current directory.  "." on UNIX.
  
  =cut
  
  sub curdir { '.' }
  
  =item devnull
  
  Returns a string representation of the null device. "/dev/null" on UNIX.
  
  =cut
  
  sub devnull { '/dev/null' }
  
  =item rootdir
  
  Returns a string representation of the root directory.  "/" on UNIX.
  
  =cut
  
  sub rootdir { '/' }
  
  =item tmpdir
  
  Returns a string representation of the first writable directory from
  the following list or the current directory if none from the list are
  writable:
  
      $ENV{TMPDIR}
      /tmp
  
  Since perl 5.8.0, if running under taint mode, and if $ENV{TMPDIR}
  is tainted, it is not used.
  
  =cut
  
  my $tmpdir;
  sub _tmpdir {
      return $tmpdir if defined $tmpdir;
      my $self = shift;
      my @dirlist = @_;
      {
  	no strict 'refs';
  	if (${"\cTAINT"}) { # Check for taint mode on perl >= 5.8.0
              require Scalar::Util;
  	    @dirlist = grep { ! Scalar::Util::tainted($_) } @dirlist;
  	}
      }
      foreach (@dirlist) {
  	next unless defined && -d && -w _;
  	$tmpdir = $_;
  	last;
      }
      $tmpdir = $self->curdir unless defined $tmpdir;
      $tmpdir = defined $tmpdir && $self->canonpath($tmpdir);
      return $tmpdir;
  }
  
  sub tmpdir {
      return $tmpdir if defined $tmpdir;
      $tmpdir = $_[0]->_tmpdir( $ENV{TMPDIR}, "/tmp" );
  }
  
  =item updir
  
  Returns a string representation of the parent directory.  ".." on UNIX.
  
  =cut
  
  sub updir { '..' }
  
  =item no_upwards
  
  Given a list of file names, strip out those that refer to a parent
  directory. (Does not strip symlinks, only '.', '..', and equivalents.)
  
  =cut
  
  sub no_upwards {
      my $self = shift;
      return grep(!/^\.{1,2}\z/s, @_);
  }
  
  =item case_tolerant
  
  Returns a true or false value indicating, respectively, that alphabetic
  is not or is significant when comparing file specifications.
  
  =cut
  
  sub case_tolerant { 0 }
  
  =item file_name_is_absolute
  
  Takes as argument a path and returns true if it is an absolute path.
  
  This does not consult the local filesystem on Unix, Win32, OS/2 or Mac 
  OS (Classic).  It does consult the working environment for VMS (see
  L<File::Spec::VMS/file_name_is_absolute>).
  
  =cut
  
  sub file_name_is_absolute {
      my ($self,$file) = @_;
      return scalar($file =~ m:^/:s);
  }
  
  =item path
  
  Takes no argument, returns the environment variable PATH as an array.
  
  =cut
  
  sub path {
      return () unless exists $ENV{PATH};
      my @path = split(':', $ENV{PATH});
      foreach (@path) { $_ = '.' if $_ eq '' }
      return @path;
  }
  
  =item join
  
  join is the same as catfile.
  
  =cut
  
  sub join {
      my $self = shift;
      return $self->catfile(@_);
  }
  
  =item splitpath
  
      ($volume,$directories,$file) = File::Spec->splitpath( $path );
      ($volume,$directories,$file) = File::Spec->splitpath( $path, $no_file );
  
  Splits a path into volume, directory, and filename portions. On systems
  with no concept of volume, returns '' for volume. 
  
  For systems with no syntax differentiating filenames from directories, 
  assumes that the last file is a path unless $no_file is true or a 
  trailing separator or /. or /.. is present. On Unix this means that $no_file
  true makes this return ( '', $path, '' ).
  
  The directory portion may or may not be returned with a trailing '/'.
  
  The results can be passed to L</catpath()> to get back a path equivalent to
  (usually identical to) the original path.
  
  =cut
  
  sub splitpath {
      my ($self,$path, $nofile) = @_;
  
      my ($volume,$directory,$file) = ('','','');
  
      if ( $nofile ) {
          $directory = $path;
      }
      else {
          $path =~ m|^ ( (?: .* / (?: \.\.?\z )? )? ) ([^/]*) |xs;
          $directory = $1;
          $file      = $2;
      }
  
      return ($volume,$directory,$file);
  }
  
  
  =item splitdir
  
  The opposite of L</catdir()>.
  
      @dirs = File::Spec->splitdir( $directories );
  
  $directories must be only the directory portion of the path on systems 
  that have the concept of a volume or that have path syntax that differentiates
  files from directories.
  
  Unlike just splitting the directories on the separator, empty
  directory names (C<''>) can be returned, because these are significant
  on some OSs.
  
  On Unix,
  
      File::Spec->splitdir( "/a/b//c/" );
  
  Yields:
  
      ( '', 'a', 'b', '', 'c', '' )
  
  =cut
  
  sub splitdir {
      return split m|/|, $_[1], -1;  # Preserve trailing fields
  }
  
  
  =item catpath()
  
  Takes volume, directory and file portions and returns an entire path. Under
  Unix, $volume is ignored, and directory and file are concatenated.  A '/' is
  inserted if needed (though if the directory portion doesn't start with
  '/' it is not added).  On other OSs, $volume is significant.
  
  =cut
  
  sub catpath {
      my ($self,$volume,$directory,$file) = @_;
  
      if ( $directory ne ''                && 
           $file ne ''                     && 
           substr( $directory, -1 ) ne '/' && 
           substr( $file, 0, 1 ) ne '/' 
      ) {
          $directory .= "/$file" ;
      }
      else {
          $directory .= $file ;
      }
  
      return $directory ;
  }
  
  =item abs2rel
  
  Takes a destination path and an optional base path returns a relative path
  from the base path to the destination path:
  
      $rel_path = File::Spec->abs2rel( $path ) ;
      $rel_path = File::Spec->abs2rel( $path, $base ) ;
  
  If $base is not present or '', then L<cwd()|Cwd> is used. If $base is
  relative, then it is converted to absolute form using
  L</rel2abs()>. This means that it is taken to be relative to
  L<cwd()|Cwd>.
  
  On systems that have a grammar that indicates filenames, this ignores the 
  $base filename. Otherwise all path components are assumed to be
  directories.
  
  If $path is relative, it is converted to absolute form using L</rel2abs()>.
  This means that it is taken to be relative to L<cwd()|Cwd>.
  
  No checks against the filesystem are made.  On VMS, there is
  interaction with the working environment, as logicals and
  macros are expanded.
  
  Based on code written by Shigio Yamaguchi.
  
  =cut
  
  sub abs2rel {
      my($self,$path,$base) = @_;
      $base = $self->_cwd() unless defined $base and length $base;
  
      ($path, $base) = map $self->canonpath($_), $path, $base;
  
      if (grep $self->file_name_is_absolute($_), $path, $base) {
  	($path, $base) = map $self->rel2abs($_), $path, $base;
      }
      else {
  	# save a couple of cwd()s if both paths are relative
  	($path, $base) = map $self->catdir('/', $_), $path, $base;
      }
  
      my ($path_volume) = $self->splitpath($path, 1);
      my ($base_volume) = $self->splitpath($base, 1);
  
      # Can't relativize across volumes
      return $path unless $path_volume eq $base_volume;
  
      my $path_directories = ($self->splitpath($path, 1))[1];
      my $base_directories = ($self->splitpath($base, 1))[1];
  
      # For UNC paths, the user might give a volume like //foo/bar that
      # strictly speaking has no directory portion.  Treat it as if it
      # had the root directory for that volume.
      if (!length($base_directories) and $self->file_name_is_absolute($base)) {
        $base_directories = $self->rootdir;
      }
  
      # Now, remove all leading components that are the same
      my @pathchunks = $self->splitdir( $path_directories );
      my @basechunks = $self->splitdir( $base_directories );
  
      if ($base_directories eq $self->rootdir) {
        shift @pathchunks;
        return $self->canonpath( $self->catpath('', $self->catdir( @pathchunks ), '') );
      }
  
      while (@pathchunks && @basechunks && $self->_same($pathchunks[0], $basechunks[0])) {
          shift @pathchunks ;
          shift @basechunks ;
      }
      return $self->curdir unless @pathchunks || @basechunks;
  
      # $base now contains the directories the resulting relative path 
      # must ascend out of before it can descend to $path_directory.
      my $result_dirs = $self->catdir( ($self->updir) x @basechunks, @pathchunks );
      return $self->canonpath( $self->catpath('', $result_dirs, '') );
  }
  
  sub _same {
    $_[1] eq $_[2];
  }
  
  =item rel2abs()
  
  Converts a relative path to an absolute path. 
  
      $abs_path = File::Spec->rel2abs( $path ) ;
      $abs_path = File::Spec->rel2abs( $path, $base ) ;
  
  If $base is not present or '', then L<cwd()|Cwd> is used. If $base is
  relative, then it is converted to absolute form using
  L</rel2abs()>. This means that it is taken to be relative to
  L<cwd()|Cwd>.
  
  On systems that have a grammar that indicates filenames, this ignores
  the $base filename. Otherwise all path components are assumed to be
  directories.
  
  If $path is absolute, it is cleaned up and returned using L</canonpath()>.
  
  No checks against the filesystem are made.  On VMS, there is
  interaction with the working environment, as logicals and
  macros are expanded.
  
  Based on code written by Shigio Yamaguchi.
  
  =cut
  
  sub rel2abs {
      my ($self,$path,$base ) = @_;
  
      # Clean up $path
      if ( ! $self->file_name_is_absolute( $path ) ) {
          # Figure out the effective $base and clean it up.
          if ( !defined( $base ) || $base eq '' ) {
  	    $base = $self->_cwd();
          }
          elsif ( ! $self->file_name_is_absolute( $base ) ) {
              $base = $self->rel2abs( $base ) ;
          }
          else {
              $base = $self->canonpath( $base ) ;
          }
  
          # Glom them together
          $path = $self->catdir( $base, $path ) ;
      }
  
      return $self->canonpath( $path ) ;
  }
  
  =back
  
  =head1 COPYRIGHT
  
  Copyright (c) 2004 by the Perl 5 Porters.  All rights reserved.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =head1 SEE ALSO
  
  L<File::Spec>
  
  =cut
  
  # Internal routine to File::Spec, no point in making this public since
  # it is the standard Cwd interface.  Most of the platform-specific
  # File::Spec subclasses use this.
  sub _cwd {
      require Cwd;
      Cwd::getcwd();
  }
  
  
  # Internal method to reduce xx\..\yy -> yy
  sub _collapse {
      my($fs, $path) = @_;
  
      my $updir  = $fs->updir;
      my $curdir = $fs->curdir;
  
      my($vol, $dirs, $file) = $fs->splitpath($path);
      my @dirs = $fs->splitdir($dirs);
      pop @dirs if @dirs && $dirs[-1] eq '';
  
      my @collapsed;
      foreach my $dir (@dirs) {
          if( $dir eq $updir              and   # if we have an updir
              @collapsed                  and   # and something to collapse
              length $collapsed[-1]       and   # and its not the rootdir
              $collapsed[-1] ne $updir    and   # nor another updir
              $collapsed[-1] ne $curdir         # nor the curdir
            ) 
          {                                     # then
              pop @collapsed;                   # collapse
          }
          else {                                # else
              push @collapsed, $dir;            # just hang onto it
          }
      }
  
      return $fs->catpath($vol,
                          $fs->catdir(@collapsed),
                          $file
                         );
  }
  
  
  1;
I386-LINUX-THREAD-MULTI_FILE_SPEC_UNIX

$fatpacked{"i386-linux-thread-multi/File/Spec/VMS.pm"} = <<'I386-LINUX-THREAD-MULTI_FILE_SPEC_VMS';
  package File::Spec::VMS;
  
  use strict;
  use vars qw(@ISA $VERSION);
  require File::Spec::Unix;
  
  $VERSION = '3.30';
  $VERSION = eval $VERSION;
  
  @ISA = qw(File::Spec::Unix);
  
  use File::Basename;
  use VMS::Filespec;
  
  =head1 NAME
  
  File::Spec::VMS - methods for VMS file specs
  
  =head1 SYNOPSIS
  
   require File::Spec::VMS; # Done internally by File::Spec if needed
  
  =head1 DESCRIPTION
  
  See File::Spec::Unix for a documentation of the methods provided
  there. This package overrides the implementation of these methods, not
  the semantics.
  
  The mode of operation of these routines depend on the VMS features that
  are controlled by the DECC features C<DECC$FILENAME_REPORT_UNIX> and
  C<DECC$EFS_CHARSET>.
  
  Perl needs to be at least at 5.10 for these feature settings to work.
  Use of them on older perl versions on VMS will result in unpredictable
  operations.
  
  The default and traditional mode of these routines have been to expect VMS
  syntax on input and to return VMS syntax on output, even when Unix syntax was
  given on input.
  
  The default and traditional mode is also incompatible with the VMS
  C<EFS>, Extended File system character set, and with running Perl scripts
  under <GNV>, Gnu is not VMS, an optional Unix like runtime environment on VMS.
  
  If the C<DECC$EFS_CHARSET> feature is enabled, These routines will now accept
  either VMS or UNIX syntax.  If the input parameters are clearly VMS syntax,
  the return value will be in VMS syntax.  If the input parameters are clearly
  in Unix syntax, the output will be in Unix syntax.
  
  This corresponds to the way that the VMS C library routines have always
  handled filenames, and what a programmer who has not specifically read this
  pod before would also expect.
  
  If the C<DECC$FILENAME_REPORT_UNIX> feature is enabled, then if the output
  syntax can not be determined from the input syntax, the output syntax will be
  UNIX.  If the feature is not enabled, VMS output will be the default.
  
  =over 4
  
  =cut
  
  # Need to look up the feature settings.  The preferred way is to use the
  # VMS::Feature module, but that may not be available to dual life modules.
  
  my $use_feature;
  BEGIN {
      if (eval { local $SIG{__DIE__}; require VMS::Feature; }) {
          $use_feature = 1;
      }
  }
  
  # Need to look up the UNIX report mode.  This may become a dynamic mode
  # in the future.
  sub _unix_rpt {
      my $unix_rpt;
      if ($use_feature) {
          $unix_rpt = VMS::Feature::current("filename_unix_report");
      } else {
          my $env_unix_rpt = $ENV{'DECC$FILENAME_UNIX_REPORT'} || '';
          $unix_rpt = $env_unix_rpt =~ /^[ET1]/i; 
      }
      return $unix_rpt;
  }
  
  # Need to look up the EFS character set mode.  This may become a dynamic
  # mode in the future.
  sub _efs {
      my $efs;
      if ($use_feature) {
          $efs = VMS::Feature::current("efs_charset");
      } else {
          my $env_efs = $ENV{'DECC$EFS_CHARSET'} || '';
          $efs = $env_efs =~ /^[ET1]/i; 
      }
      return $efs;
  }
  
  =item canonpath (override)
  
  Removes redundant portions of file specifications according to the syntax
  detected.
  
  =cut
  
  
  sub canonpath {
      my($self,$path) = @_;
  
      return undef unless defined $path;
  
      my $efs = $self->_efs;
  
      if ($path =~ m|/|) { # Fake Unix
        my $pathify = $path =~ m|/\Z(?!\n)|;
        $path = $self->SUPER::canonpath($path);
  
        # Do not convert to VMS when EFS character sets are in use
        return $path if $efs;
  
        if ($pathify) { return vmspath($path); }
        else          { return vmsify($path);  }
      }
      else {
  
  #FIXME - efs parsing has different rules.  Characters in a VMS filespec
  #        are only delimiters if not preceded by '^';
  
  	$path =~ tr/<>/[]/;			# < and >       ==> [ and ]
  	$path =~ s/\]\[\./\.\]\[/g;		# ][.		==> .][
  	$path =~ s/\[000000\.\]\[/\[/g;		# [000000.][	==> [
  	$path =~ s/\[000000\./\[/g;		# [000000.	==> [
  	$path =~ s/\.\]\[000000\]/\]/g;		# .][000000]	==> ]
  	$path =~ s/\.\]\[/\./g;			# foo.][bar     ==> foo.bar
  	1 while ($path =~ s/([\[\.])(-+)\.(-+)([\.\]])/$1$2$3$4/);
  						# That loop does the following
  						# with any amount of dashes:
  						# .-.-.		==> .--.
  						# [-.-.		==> [--.
  						# .-.-]		==> .--]
  						# [-.-]		==> [--]
  	1 while ($path =~ s/([\[\.])[^\]\.]+\.-(-+)([\]\.])/$1$2$3/);
  						# That loop does the following
  						# with any amount (minimum 2)
  						# of dashes:
  						# .foo.--.	==> .-.
  						# .foo.--]	==> .-]
  						# [foo.--.	==> [-.
  						# [foo.--]	==> [-]
  						#
  						# And then, the remaining cases
  	$path =~ s/\[\.-/[-/;			# [.-		==> [-
  	$path =~ s/\.[^\]\.]+\.-\./\./g;	# .foo.-.	==> .
  	$path =~ s/\[[^\]\.]+\.-\./\[/g;	# [foo.-.	==> [
  	$path =~ s/\.[^\]\.]+\.-\]/\]/g;	# .foo.-]	==> ]
  	$path =~ s/\[[^\]\.]+\.-\]/\[000000\]/g;# [foo.-]       ==> [000000]
  	$path =~ s/\[\]// unless $path eq '[]';	# []		==>
  	return $path;
      }
  }
  
  =item catdir (override)
  
  Concatenates a list of file specifications, and returns the result as a
  directory specification.  No check is made for "impossible"
  cases (e.g. elements other than the first being absolute filespecs).
  
  =cut
  
  sub catdir {
      my $self = shift;
      my $dir = pop;
  
      my $efs = $self->_efs;
      my $unix_rpt = $self->_unix_rpt;
  
  
      my @dirs = grep {defined() && length()} @_;
      if ($efs) {
          # Legacy mode removes blank entries.
          # But that breaks existing generic perl code that
          # uses a blank path at the beginning of the array
          # to indicate an absolute path.
          # So put it back if found.
          if (@_) {
              if ($_[0] eq '') {
                  unshift @dirs, '';
              }
          }
      }
  
      my $rslt;
      if (@dirs) {
  	my $path = (@dirs == 1 ? $dirs[0] : $self->catdir(@dirs));
  	my ($spath,$sdir) = ($path,$dir);
  
          if ($efs) {
              # Extended character set in use, go into DWIM mode.
  
              # Now we need to identify what the directory is in
              # of the specification in order to merge them.
              my $path_unix = 0;
              $path_unix = 1 if ($path =~ m#/#);
              $path_unix = 1 if ($path =~ /^\.\.?$/);
              my $path_vms = 0;
              $path_vms = 1 if ($path =~ m#[\[<\]]#);
              $path_vms = 1 if ($path =~ /^--?$/);
              my $dir_unix = 0;
              $dir_unix = 1 if ($dir =~ m#/#);
              $dir_unix = 1 if ($dir =~ /^\.\.?$/);
              my $dir_vms = 0;
              $dir_vms = 1 if ($dir =~ m#[\[<\]]#);
              $dir_vms = 1 if ($dir =~ /^--?$/);
  
              my $unix_mode = 0;
              if (($path_unix != $dir_unix) && ($path_vms != $dir_vms)) {
                  # Ambiguous, so if in $unix_rpt mode then assume UNIX.
                  $unix_mode = 1 if $unix_rpt;
              } else {
                  $unix_mode = 1 if (!$path_vms && !$dir_vms && $unix_rpt);
                  $unix_mode = 1 if ($path_unix || $dir_unix);
              }
  
              if ($unix_mode) {
  
                  # Fix up mixed syntax imput as good as possible - GIGO
                  $path = unixify($path) if $path_vms;
                  $dir = unixify($dir) if $dir_vms;
  
                  $rslt = $path;
                  # Append a path delimiter
                  $rslt .= '/' unless ($rslt =~ m#/$#);
  
                  $rslt .= $dir;
                  return $self->SUPER::canonpath($rslt);
              } else {
  
                  #with <> posible instead of [.
                  # Normalize the brackets
                  # Fixme - need to not switch when preceded by ^.
                  $path =~ s/</\[/g;
                  $path =~ s/>/\]/g;
                  $dir =~ s/</\[/g;
                  $dir =~ s/>/\]/g;
  
                  # Fix up mixed syntax imput as good as possible - GIGO
                  $path = vmsify($path) if $path_unix;
                  $dir = vmsify($dir) if $dir_unix;
  
                  #Possible path values: foo: [.foo] [foo] foo, and $(foo)
                  #or starting with '-', or foo.dir
                  #If path is foo, it needs to be converted to [.foo]
  
                  # Fix up a bare path name.
                  unless ($path_vms) {
                      $path =~ s/\.dir\Z(?!\n)//i;
                      if (($path ne '') && ($path !~ /^-/)) {
                          # Non blank and not prefixed with '-', add a dot
                          $path = '[.' . $path;
                      } else {
                          # Just start a directory.
                          $path = '[' . $path;
                      }
                  } else {
                      $path =~ s/\]$//;
                  }
  
                  #Possible dir values: [.dir] dir and $(foo)
  
                  # No punctuation may have a trailing .dir
                  unless ($dir_vms) {
                      $dir =~ s/\.dir\Z(?!\n)//i;
                  } else {
  
                      #strip off the brackets
                      $dir =~ s/^\[//;
                      $dir =~ s/\]$//;
                  }
  
                  #strip off the leading dot if present.
                  $dir =~ s/^\.//;
  
                  # Now put the specifications together.
                  if ($dir ne '') {
                      # Add a separator unless this is an absolute path
                      $path .= '.' if ($path ne '[');
                      $rslt = $path . $dir . ']';
                  } else {
                      $rslt = $path . ']';
                  }
              }
  
  	} else {
  	    # Traditional ODS-2 mode.
  	    $spath =~ s/\.dir\Z(?!\n)//i; $sdir =~ s/\.dir\Z(?!\n)//i; 
  
  	    $sdir = $self->eliminate_macros($sdir)
  		unless $sdir =~ /^[\w\-]+\Z(?!\n)/s;
  	    $rslt = $self->fixpath($self->eliminate_macros($spath)."/$sdir",1);
  
  	    # Special case for VMS absolute directory specs: these will have
  	    # had device prepended during trip through Unix syntax in
  	    # eliminate_macros(), since Unix syntax has no way to express
  	    # "absolute from the top of this device's directory tree".
  	    if ($spath =~ /^[\[<][^.\-]/s) { $rslt =~ s/^[^\[<]+//s; }
  	} 
      } else {
  	# Single directory, just make sure it is in directory format
  	# Return an empty string on null input, and pass through macros.
  
  	if    (not defined $dir or not length $dir) { $rslt = ''; }
  	elsif ($dir =~ /^\$\([^\)]+\)\Z(?!\n)/s) { 
  	    $rslt = $dir;
  	} else {
              my $unix_mode = 0;
  
              if ($efs) {
                  my $dir_unix = 0;
                  $dir_unix = 1 if ($dir =~ m#/#);
                  $dir_unix = 1 if ($dir =~ /^\.\.?$/);
                  my $dir_vms = 0;
                  $dir_vms = 1 if ($dir =~ m#[\[<\]]#);
                  $dir_vms = 1 if ($dir =~ /^--?$/);
  
                  if ($dir_vms == $dir_unix) {
                      # Ambiguous, so if in $unix_rpt mode then assume UNIX.
                      $unix_mode = 1 if $unix_rpt;
                  } else {
                      $unix_mode = 1 if $dir_unix;
                  }
              }
  
              if ($unix_mode) {
                  return $dir;
              } else {
                  # For VMS, force it to be in directory format
  	 	$rslt = vmspath($dir);
  	    }
  	}
      }
      return $self->canonpath($rslt);
  }
  
  =item catfile (override)
  
  Concatenates a list of directory specifications with a filename specification
  to build a path.
  
  =cut
  
  sub catfile {
      my $self = shift;
      my $tfile = pop();
      my $file = $self->canonpath($tfile);
      my @files = grep {defined() && length()} @_;
  
      my $efs = $self->_efs;
      my $unix_rpt = $self->_unix_rpt;
  
      # Assume VMS mode
      my $unix_mode = 0;
      my $file_unix = 0;
      my $file_vms = 0;
      if ($efs) {
  
          # Now we need to identify format the file is in
          # of the specification in order to merge them.
          $file_unix = 1 if ($tfile =~ m#/#);
          $file_unix = 1 if ($tfile =~ /^\.\.?$/);
          $file_vms = 1 if ($tfile =~ m#[\[<\]]#);
          $file_vms = 1 if ($tfile =~ /^--?$/);
  
          # We may know for sure what the format is.
          if (($file_unix != $file_vms)) {
              $unix_mode = 1 if ($file_unix && $unix_rpt);
          }
      }
  
      my $rslt;
      if (@files) {
  	# concatenate the directories.
  	my $path;
          if (@files == 1) {
             $path = $files[0];
          } else {
              if ($file_vms) {
                  # We need to make sure this is in VMS mode to avoid doing
                  # both a vmsify and unixfy on the same path, as that may
                  # lose significant data.
                  my $i = @files - 1;
                  my $tdir = $files[$i];
                  my $tdir_vms = 0;
                  my $tdir_unix = 0;
                  $tdir_vms = 1 if ($tdir =~ m#[\[<\]]#);
                  $tdir_unix = 1 if ($tdir =~ m#/#);
                  $tdir_unix = 1 if ($tdir =~ /^\.\.?$/);
  
                  if (!$tdir_vms) {
                      if ($tdir_unix) { 
                          $tdir = vmspath($tdir);
                      } else {
                          $tdir =~ s/\.dir\Z(?!\n)//i;
                          $tdir = '[.' . $tdir . ']';
                      }
                      $files[$i] = $tdir;
                  }
              }
              $path = $self->catdir(@files);
          }
  	my $spath = $path;
  
          # Some thing building a VMS path in pieces may try to pass a
          # directory name in filename format, so normalize it.
  	$spath =~ s/\.dir\Z(?!\n)//i;
  
          # if the spath ends with a directory delimiter and the file is bare,
          # then just concat them.
          # FIX-ME: In VMS format "[]<>:" are not delimiters if preceded by '^' 
          # Quite a bit of Perl does not know that yet.
  	if ($spath =~ /^[^\)\]\/:>]+\)\Z(?!\n)/s && basename($file) eq $file) {
  	    $rslt = "$spath$file";
  	} else {
              if ($efs) {
  
                  # Now we need to identify what the directory is in
                  # of the specification in order to merge them.
                  my $spath_unix = 0;
                  $spath_unix = 1 if ($spath =~ m#/#);
                  $spath_unix = 1 if ($spath =~ /^\.\.?$/);
                  my $spath_vms = 0;
                  $spath_vms = 1 if ($spath =~ m#[\[<\]]#);
                  $spath_vms = 1 if ($spath =~ /^--?$/);
  
                  # Assume VMS mode
                  if (($spath_unix == $spath_vms) &&
                      ($file_unix == $file_vms)) {
                       # Ambigous, so if in $unix_rpt mode then assume UNIX.
                       $unix_mode = 1 if $unix_rpt;
                  } else {
                       $unix_mode = 1
                           if (($spath_unix || $file_unix) && $unix_rpt);
                  }
  
                  if (!$unix_mode) {
                      if ($spath_vms) {
                          $spath = '[' . $spath . ']' if $spath =~ /^-/;
                          $rslt = vmspath($spath);
                      } else {
                          $rslt = '[.' . $spath . ']';
                      }
                      $file = vmsify($file) if ($file_unix);
                  } else {
                      $spath = unixify($spath) if ($spath_vms);
                      $rslt = $spath;
                      $file = unixify($file) if ($file_vms);
  
                      # Unix merge may need a directory delimitor.
                      # A null path indicates root on Unix.
                      $rslt .= '/' unless ($rslt =~ m#/$#);
                  }
  
                  $rslt .= $file;
                  $rslt =~ s/\]\[//;
  
  	    } else {
  		# Traditional VMS Perl mode expects that this is done.
  		# Note for future maintainers:
  		# This is left here for compatibility with perl scripts
  		# that have come to expect this behavior, even though
  		# usually the Perl scripts ported to VMS have to be
  		# patched because of it changing Unix syntax file
  		# to VMS format.
  
  		$rslt = $self->eliminate_macros($spath);
  
  
  	        $rslt = vmsify($rslt.((defined $rslt) &&
  		    ($rslt ne '') ? '/' : '').unixify($file));
  	    }
  	}
      }
      else {
          # Only passed a single file?
          my $xfile = $file;
  
          # Traditional VMS perl expects this conversion.
          $xfile = vmsify($file) unless ($efs);
  
          $rslt = (defined($file) && length($file)) ? $xfile : '';
      }
      return $self->canonpath($rslt) unless $unix_rpt;
  
      # In Unix report mode, do not strip off redundent path information.
      return $rslt;
  }
  
  
  =item curdir (override)
  
  Returns a string representation of the current directory: '[]' or '.'
  
  =cut
  
  sub curdir {
      my $self = shift @_;
      return '.' if ($self->_unix_rpt);
      return '[]';
  }
  
  =item devnull (override)
  
  Returns a string representation of the null device: '_NLA0:' or '/dev/null'
  
  =cut
  
  sub devnull {
      my $self = shift @_;
      return '/dev/null' if ($self->_unix_rpt);
      return "_NLA0:";
  }
  
  =item rootdir (override)
  
  Returns a string representation of the root directory: 'SYS$DISK:[000000]'
  or '/'
  
  =cut
  
  sub rootdir {
      my $self = shift @_;
      if ($self->_unix_rpt) {
         # Root may exist, try it first.
         my $try = '/';
         my ($dev1, $ino1) = stat('/');
         my ($dev2, $ino2) = stat('.');
  
         # Perl falls back to '.' if it can not determine '/'
         if (($dev1 != $dev2) || ($ino1 != $ino2)) {
             return $try;
         }
         # Fall back to UNIX format sys$disk.
         return '/sys$disk/';
      }
      return 'SYS$DISK:[000000]';
  }
  
  =item tmpdir (override)
  
  Returns a string representation of the first writable directory
  from the following list or '' if none are writable:
  
      /tmp if C<DECC$FILENAME_REPORT_UNIX> is enabled.
      sys$scratch:
      $ENV{TMPDIR}
  
  Since perl 5.8.0, if running under taint mode, and if $ENV{TMPDIR}
  is tainted, it is not used.
  
  =cut
  
  my $tmpdir;
  sub tmpdir {
      my $self = shift @_;
      return $tmpdir if defined $tmpdir;
      if ($self->_unix_rpt) {
          $tmpdir = $self->_tmpdir('/tmp', '/sys$scratch', $ENV{TMPDIR});
          return $tmpdir;
      }
  
      $tmpdir = $self->_tmpdir( 'sys$scratch:', $ENV{TMPDIR} );
  }
  
  =item updir (override)
  
  Returns a string representation of the parent directory: '[-]' or '..'
  
  =cut
  
  sub updir {
      my $self = shift @_;
      return '..' if ($self->_unix_rpt);
      return '[-]';
  }
  
  =item case_tolerant (override)
  
  VMS file specification syntax is case-tolerant.
  
  =cut
  
  sub case_tolerant {
      return 1;
  }
  
  =item path (override)
  
  Translate logical name DCL$PATH as a searchlist, rather than trying
  to C<split> string value of C<$ENV{'PATH'}>.
  
  =cut
  
  sub path {
      my (@dirs,$dir,$i);
      while ($dir = $ENV{'DCL$PATH;' . $i++}) { push(@dirs,$dir); }
      return @dirs;
  }
  
  =item file_name_is_absolute (override)
  
  Checks for VMS directory spec as well as Unix separators.
  
  =cut
  
  sub file_name_is_absolute {
      my ($self,$file) = @_;
      # If it's a logical name, expand it.
      $file = $ENV{$file} while $file =~ /^[\w\$\-]+\Z(?!\n)/s && $ENV{$file};
      return scalar($file =~ m!^/!s             ||
  		  $file =~ m![<\[][^.\-\]>]!  ||
  		  $file =~ /:[^<\[]/);
  }
  
  =item splitpath (override)
  
      ($volume,$directories,$file) = File::Spec->splitpath( $path );
      ($volume,$directories,$file) = File::Spec->splitpath( $path, $no_file );
  
  Passing a true value for C<$no_file> indicates that the path being
  split only contains directory components, even on systems where you
  can usually (when not supporting a foreign syntax) tell the difference
  between directories and files at a glance.
  
  =cut
  
  sub splitpath {
      my($self,$path, $nofile) = @_;
      my($dev,$dir,$file)      = ('','','');
      my $efs = $self->_efs;
      my $vmsify_path = vmsify($path);
      if ($efs) {
          my $path_vms = 0;
          $path_vms = 1 if ($path =~ m#[\[<\]]#);
          $path_vms = 1 if ($path =~ /^--?$/);
          if (!$path_vms) {
              return $self->SUPER::splitpath($path, $nofile);
          }
          $vmsify_path = $path;
      }
  
      if ( $nofile ) {
          #vmsify('d1/d2/d3') returns '[.d1.d2]d3'
          #vmsify('/d1/d2/d3') returns 'd1:[d2]d3'
          if( $vmsify_path =~ /(.*)\](.+)/ ){
              $vmsify_path = $1.'.'.$2.']';
          }
          $vmsify_path =~ /(.+:)?(.*)/s;
          $dir = defined $2 ? $2 : ''; # dir can be '0'
          return ($1 || '',$dir,$file);
      }
      else {
          $vmsify_path =~ /(.+:)?([\[<].*[\]>])?(.*)/s;
          return ($1 || '',$2 || '',$3);
      }
  }
  
  =item splitdir (override)
  
  Split a directory specification into the components.
  
  =cut
  
  sub splitdir {
      my($self,$dirspec) = @_;
      my @dirs = ();
      return @dirs if ( (!defined $dirspec) || ('' eq $dirspec) );
  
      my $efs = $self->_efs;
  
      my $dir_unix = 0;
      $dir_unix = 1 if ($dirspec =~ m#/#);
      $dir_unix = 1 if ($dirspec =~ /^\.\.?$/);
  
      # Unix filespecs in EFS mode handled by Unix routines.
      if ($efs && $dir_unix) {
          return $self->SUPER::splitdir($dirspec);
      }
  
      # FIX ME, only split for VMS delimiters not prefixed with '^'.
  
      $dirspec =~ tr/<>/[]/;			# < and >	==> [ and ]
      $dirspec =~ s/\]\[\./\.\]\[/g;		# ][.		==> .][
      $dirspec =~ s/\[000000\.\]\[/\[/g;		# [000000.][	==> [
      $dirspec =~ s/\[000000\./\[/g;		# [000000.	==> [
      $dirspec =~ s/\.\]\[000000\]/\]/g;		# .][000000]	==> ]
      $dirspec =~ s/\.\]\[/\./g;			# foo.][bar	==> foo.bar
      while ($dirspec =~ s/(^|[\[\<\.])\-(\-+)($|[\]\>\.])/$1-.$2$3/g) {}
  						# That loop does the following
  						# with any amount of dashes:
  						# .--.		==> .-.-.
  						# [--.		==> [-.-.
  						# .--]		==> .-.-]
  						# [--]		==> [-.-]
      $dirspec = "[$dirspec]" unless $dirspec =~ /[\[<]/; # make legal
      $dirspec =~ s/^(\[|<)\./$1/;
      @dirs = split /(?<!\^)\./, vmspath($dirspec);
      $dirs[0] =~ s/^[\[<]//s;  $dirs[-1] =~ s/[\]>]\Z(?!\n)//s;
      @dirs;
  }
  
  
  =item catpath (override)
  
  Construct a complete filespec.
  
  =cut
  
  sub catpath {
      my($self,$dev,$dir,$file) = @_;
      
      my $efs = $self->_efs;
      my $unix_rpt = $self->_unix_rpt;
  
      my $unix_mode = 0;
      my $dir_unix = 0;
      $dir_unix = 1 if ($dir =~ m#/#);
      $dir_unix = 1 if ($dir =~ /^\.\.?$/);
      my $dir_vms = 0;
      $dir_vms = 1 if ($dir =~ m#[\[<\]]#);
      $dir_vms = 1 if ($dir =~ /^--?$/);
  
      if ($efs && (length($dev) == 0)) {
          if ($dir_unix == $dir_vms) {
              $unix_mode = $unix_rpt;
          } else {
              $unix_mode = $dir_unix;
          }
      } 
  
      # We look for a volume in $dev, then in $dir, but not both
      # but only if using VMS syntax.
      if (!$unix_mode) {
          $dir = vmspath($dir) if $dir_unix;
          my ($dir_volume, $dir_dir, $dir_file) = $self->splitpath($dir);
          $dev = $dir_volume unless length $dev;
          $dir = length $dir_file ? $self->catfile($dir_dir, $dir_file) :
                                    $dir_dir;
      }
      if ($dev =~ m|^/+([^/]+)|) { $dev = "$1:"; }
      else { $dev .= ':' unless $dev eq '' or $dev =~ /:\Z(?!\n)/; }
      if (length($dev) or length($dir)) {
        if ($efs) {
            if ($unix_mode) {
                $dir .= '/' unless ($dir =~ m#/$#);
            } else {
                $dir = vmspath($dir) if (($dir =~ m#/#) || ($dir =~ /^\.\.?$/));
                $dir = "[$dir]" unless $dir =~ /^[\[<]/;
            }
        } else {
            $dir = "[$dir]" unless $dir =~ /[\[<\/]/;
            $dir = vmspath($dir);
        }
      }
      "$dev$dir$file";
  }
  
  =item abs2rel (override)
  
  Attempt to convert a file specification to a relative specification.
  On a system with volumes, like VMS, this may not be possible.
  
  =cut
  
  sub abs2rel {
      my $self = shift;
      my($path,$base) = @_;
  
      my $efs = $self->_efs;
      my $unix_rpt = $self->_unix_rpt;
  
      if (!$efs) {
          return vmspath(File::Spec::Unix::abs2rel( $self, @_ ))
              if grep m{/}, @_;
      }
  
      # We need to identify what the directory is in
      # of the specification in order to process them
      my $path_unix = 0;
      $path_unix = 1 if ($path =~ m#/#);
      $path_unix = 1 if ($path =~ /^\.\.?$/);
      my $path_vms = 0;
      $path_vms = 1 if ($path =~ m#[\[<\]]#);
      $path_vms = 1 if ($path =~ /^--?$/);
  
      my $unix_mode = 0;
      if ($path_vms == $path_unix) {
          $unix_mode = $unix_rpt;
      } else {
          $unix_mode = $path_unix;
      }
  
      my $base_unix = 0;
      my $base_vms = 0;
  
      if (defined $base) {
          $base_unix = 1 if ($base =~ m#/#);
          $base_unix = 1 if ($base =~ /^\.\.?$/);
          $base_vms = 1 if ($base =~ m#[\[<\]]#);
          $base_vms = 1 if ($base =~ /^--?$/);
  
          if ($path_vms == $path_unix) {
              if ($base_vms == $base_unix) {
                  $unix_mode = $unix_rpt;
              } else {
                  $unix_mode = $base_unix;
              }
          } else {
              $unix_mode = 0 if $base_vms;
          }
      }
  
      if ($efs) {
          if ($unix_mode) {
              # We are UNIX mode.
              $base = unixpath($base) if $base_vms;
              $base = unixify($path) if $path_vms;
  
              # Here VMS is different, and in order to do this right
              # we have to take the realpath for both the path and the base
              # so that we can remove the common components.
  
              if ($path =~ m#^/#) {
                  if (defined $base) {
  
                      # For the shorterm, if the starting directories are
                      # common, remove them.
                      my $bq = qq($base);
                      $bq =~ s/\$/\\\$/;
                      $path =~ s/^$bq//i;
                  }
                  return $path;
              }
  
              return File::Spec::Unix::abs2rel( $self, $path, $base );
  
          } else {
              $base = vmspath($base) if $base_unix;
              $path = vmsify($path) if $path_unix;
          }
      }
  
      unless (defined $base and length $base) {
          $base = $self->_cwd();
          if ($efs) {
              $base_unix = 1 if ($base =~ m#/#);
              $base_unix = 1 if ($base =~ /^\.\.?$/);
              $base = vmspath($base) if $base_unix;
          }
      }
  
      for ($path, $base) { $_ = $self->canonpath($_) }
  
      # Are we even starting $path on the same (node::)device as $base?  Note that
      # logical paths or nodename differences may be on the "same device" 
      # but the comparison that ignores device differences so as to concatenate 
      # [---] up directory specs is not even a good idea in cases where there is 
      # a logical path difference between $path and $base nodename and/or device.
      # Hence we fall back to returning the absolute $path spec
      # if there is a case blind device (or node) difference of any sort
      # and we do not even try to call $parse() or consult %ENV for $trnlnm()
      # (this module needs to run on non VMS platforms after all).
      
      my ($path_volume, $path_directories, $path_file) = $self->splitpath($path);
      my ($base_volume, $base_directories, $base_file) = $self->splitpath($base);
      return $path unless lc($path_volume) eq lc($base_volume);
  
      for ($path, $base) { $_ = $self->rel2abs($_) }
  
      # Now, remove all leading components that are the same
      my @pathchunks = $self->splitdir( $path_directories );
      my $pathchunks = @pathchunks;
      unshift(@pathchunks,'000000') unless $pathchunks[0] eq '000000';
      my @basechunks = $self->splitdir( $base_directories );
      my $basechunks = @basechunks;
      unshift(@basechunks,'000000') unless $basechunks[0] eq '000000';
  
      while ( @pathchunks && 
              @basechunks && 
              lc( $pathchunks[0] ) eq lc( $basechunks[0] ) 
            ) {
          shift @pathchunks ;
          shift @basechunks ;
      }
  
      # @basechunks now contains the directories to climb out of,
      # @pathchunks now has the directories to descend in to.
      if ((@basechunks > 0) || ($basechunks != $pathchunks)) {
        $path_directories = join '.', ('-' x @basechunks, @pathchunks) ;
      }
      else {
        $path_directories = join '.', @pathchunks;
      }
      $path_directories = '['.$path_directories.']';
      return $self->canonpath( $self->catpath( '', $path_directories, $path_file ) ) ;
  }
  
  
  =item rel2abs (override)
  
  Return an absolute file specification from a relative one.
  
  =cut
  
  sub rel2abs {
      my $self = shift ;
      my ($path,$base ) = @_;
      return undef unless defined $path;
  
      my $efs = $self->_efs;
      my $unix_rpt = $self->_unix_rpt;
  
      # We need to identify what the directory is in
      # of the specification in order to process them
      my $path_unix = 0;
      $path_unix = 1 if ($path =~ m#/#);
      $path_unix = 1 if ($path =~ /^\.\.?$/);
      my $path_vms = 0;
      $path_vms = 1 if ($path =~ m#[\[<\]]#);
      $path_vms = 1 if ($path =~ /^--?$/);
  
      my $unix_mode = 0;
      if ($path_vms == $path_unix) {
          $unix_mode = $unix_rpt;
      } else {
          $unix_mode = $path_unix;
      }
  
      my $base_unix = 0;
      my $base_vms = 0;
  
      if (defined $base) {
          $base_unix = 1 if ($base =~ m#/#);
          $base_unix = 1 if ($base =~ /^\.\.?$/);
          $base_vms = 1 if ($base =~ m#[\[<\]]#);
          $base_vms = 1 if ($base =~ /^--?$/);
  
          # If we could not determine the path mode, see if we can find out
          # from the base.
          if ($path_vms == $path_unix) {
              if ($base_vms != $base_unix) {
                  $unix_mode = $base_unix;
              }
          }
      }
  
      if (!$efs) {
          # Legacy behavior, convert to VMS syntax.
          $unix_mode = 0;
          if (defined $base) {
              $base = vmspath($base) if $base =~ m/\//;
          }
  
          if ($path =~ m/\//) {
  	    $path = ( -d $path || $path =~ m/\/\z/  # educated guessing about
  		       ? vmspath($path)             # whether it's a directory
  		       : vmsify($path) );
          }
     }
  
      # Clean up and split up $path
      if ( ! $self->file_name_is_absolute( $path ) ) {
          # Figure out the effective $base and clean it up.
          if ( !defined( $base ) || $base eq '' ) {
              $base = $self->_cwd;
          }
          elsif ( ! $self->file_name_is_absolute( $base ) ) {
              $base = $self->rel2abs( $base ) ;
          }
          else {
              $base = $self->canonpath( $base ) ;
          }
  
          if ($efs) {
              # base may have changed, so need to look up format again.
              if ($unix_mode) {
                  $base_vms = 1 if ($base =~ m#[\[<\]]#);
                  $base_vms = 1 if ($base =~ /^--?$/);
                  $base = unixpath($base) if $base_vms;
                  $base .= '/' unless ($base =~ m#/$#);
              } else {
                  $base_unix = 1 if ($base =~ m#/#);
                  $base_unix = 1 if ($base =~ /^\.\.?$/);
                  $base = vmspath($base) if $base_unix; 
              }
          }
  
          # Split up paths
          my ( $path_directories, $path_file ) =
              ($self->splitpath( $path ))[1,2] ;
  
          my ( $base_volume, $base_directories ) =
              $self->splitpath( $base ) ;
  
          $path_directories = '' if $path_directories eq '[]' ||
                                    $path_directories eq '<>';
          my $sep = '' ;
  
          if ($efs) {
              # Merge the paths assuming that the base is absolute.
              $base_directories = $self->catdir('',
                                                $base_directories,
                                                $path_directories);
          } else {
              # Legacy behavior assumes VMS only paths
              $sep = '.'
                  if ( $base_directories =~ m{[^.\]>]\Z(?!\n)} &&
                       $path_directories =~ m{^[^.\[<]}s
                  ) ;
              $base_directories = "$base_directories$sep$path_directories";
              $base_directories =~ s{\.?[\]>][\[<]\.?}{.};
          }
  
          $path_file = '' if ($path_file eq '.') && $unix_mode;
  
          $path = $self->catpath( $base_volume, $base_directories, $path_file );
     }
  
      return $self->canonpath( $path ) ;
  }
  
  
  # eliminate_macros() and fixpath() are MakeMaker-specific methods
  # which are used inside catfile() and catdir().  MakeMaker has its own
  # copies as of 6.06_03 which are the canonical ones.  We leave these
  # here, in peace, so that File::Spec continues to work with MakeMakers
  # prior to 6.06_03.
  # 
  # Please consider these two methods deprecated.  Do not patch them,
  # patch the ones in ExtUtils::MM_VMS instead.
  #
  # Update:  MakeMaker 6.48 is still using these routines on VMS.
  # so they need to be kept up to date with ExtUtils::MM_VMS.
  #
  # The traditional VMS mode using ODS-2 disks depends on these routines
  # being here.  These routines should not be called in when the
  # C<DECC$EFS_CHARSET> or C<DECC$FILENAME_REPORT_UNIX> modes are enabled.
  
  sub eliminate_macros {
      my($self,$path) = @_;
      return '' unless (defined $path) && ($path ne '');
      $self = {} unless ref $self;
  
      if ($path =~ /\s/) {
        return join ' ', map { $self->eliminate_macros($_) } split /\s+/, $path;
      }
  
      my $npath = unixify($path);
      # sometimes unixify will return a string with an off-by-one trailing null
      $npath =~ s{\0$}{};
  
      my($complex) = 0;
      my($head,$macro,$tail);
  
      # perform m##g in scalar context so it acts as an iterator
      while ($npath =~ m#(.*?)\$\((\S+?)\)(.*)#gs) { 
          if (defined $self->{$2}) {
              ($head,$macro,$tail) = ($1,$2,$3);
              if (ref $self->{$macro}) {
                  if (ref $self->{$macro} eq 'ARRAY') {
                      $macro = join ' ', @{$self->{$macro}};
                  }
                  else {
                      print "Note: can't expand macro \$($macro) containing ",ref($self->{$macro}),
                            "\n\t(using MMK-specific deferred substitutuon; MMS will break)\n";
                      $macro = "\cB$macro\cB";
                      $complex = 1;
                  }
              }
              else { ($macro = unixify($self->{$macro})) =~ s#/\Z(?!\n)##; }
              $npath = "$head$macro$tail";
          }
      }
      if ($complex) { $npath =~ s#\cB(.*?)\cB#\${$1}#gs; }
      $npath;
  }
  
  # Deprecated.  See the note above for eliminate_macros().
  
  # Catchall routine to clean up problem MM[SK]/Make macros.  Expands macros
  # in any directory specification, in order to avoid juxtaposing two
  # VMS-syntax directories when MM[SK] is run.  Also expands expressions which
  # are all macro, so that we can tell how long the expansion is, and avoid
  # overrunning DCL's command buffer when MM[KS] is running.
  
  # fixpath() checks to see whether the result matches the name of a
  # directory in the current default directory and returns a directory or
  # file specification accordingly.  C<$is_dir> can be set to true to
  # force fixpath() to consider the path to be a directory or false to force
  # it to be a file.
  
  sub fixpath {
      my($self,$path,$force_path) = @_;
      return '' unless $path;
      $self = bless {}, $self unless ref $self;
      my($fixedpath,$prefix,$name);
  
      if ($path =~ /\s/) {
        return join ' ',
               map { $self->fixpath($_,$force_path) }
  	     split /\s+/, $path;
      }
  
      if ($path =~ m#^\$\([^\)]+\)\Z(?!\n)#s || $path =~ m#[/:>\]]#) { 
          if ($force_path or $path =~ /(?:DIR\)|\])\Z(?!\n)/) {
              $fixedpath = vmspath($self->eliminate_macros($path));
          }
          else {
              $fixedpath = vmsify($self->eliminate_macros($path));
          }
      }
      elsif ((($prefix,$name) = ($path =~ m#^\$\(([^\)]+)\)(.+)#s)) && $self->{$prefix}) {
          my($vmspre) = $self->eliminate_macros("\$($prefix)");
          # is it a dir or just a name?
          $vmspre = ($vmspre =~ m|/| or $prefix =~ /DIR\Z(?!\n)/) ? vmspath($vmspre) : '';
          $fixedpath = ($vmspre ? $vmspre : $self->{$prefix}) . $name;
          $fixedpath = vmspath($fixedpath) if $force_path;
      }
      else {
          $fixedpath = $path;
          $fixedpath = vmspath($fixedpath) if $force_path;
      }
      # No hints, so we try to guess
      if (!defined($force_path) and $fixedpath !~ /[:>(.\]]/) {
          $fixedpath = vmspath($fixedpath) if -d $fixedpath;
      }
  
      # Trim off root dirname if it's had other dirs inserted in front of it.
      $fixedpath =~ s/\.000000([\]>])/$1/;
      # Special case for VMS absolute directory specs: these will have had device
      # prepended during trip through Unix syntax in eliminate_macros(), since
      # Unix syntax has no way to express "absolute from the top of this device's
      # directory tree".
      if ($path =~ /^[\[>][^.\-]/) { $fixedpath =~ s/^[^\[<]+//; }
      $fixedpath;
  }
  
  
  =back
  
  =head1 COPYRIGHT
  
  Copyright (c) 2004 by the Perl 5 Porters.  All rights reserved.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =head1 SEE ALSO
  
  See L<File::Spec> and L<File::Spec::Unix>.  This package overrides the
  implementation of these methods, not the semantics.
  
  An explanation of VMS file specs can be found at
  L<"http://h71000.www7.hp.com/doc/731FINAL/4506/4506pro_014.html#apps_locating_naming_files">.
  
  =cut
  
  1;
I386-LINUX-THREAD-MULTI_FILE_SPEC_VMS

$fatpacked{"i386-linux-thread-multi/File/Spec/Win32.pm"} = <<'I386-LINUX-THREAD-MULTI_FILE_SPEC_WIN32';
  package File::Spec::Win32;
  
  use strict;
  
  use vars qw(@ISA $VERSION);
  require File::Spec::Unix;
  
  $VERSION = '3.30';
  $VERSION = eval $VERSION;
  
  @ISA = qw(File::Spec::Unix);
  
  # Some regexes we use for path splitting
  my $DRIVE_RX = '[a-zA-Z]:';
  my $UNC_RX = '(?:\\\\\\\\|//)[^\\\\/]+[\\\\/][^\\\\/]+';
  my $VOL_RX = "(?:$DRIVE_RX|$UNC_RX)";
  
  
  =head1 NAME
  
  File::Spec::Win32 - methods for Win32 file specs
  
  =head1 SYNOPSIS
  
   require File::Spec::Win32; # Done internally by File::Spec if needed
  
  =head1 DESCRIPTION
  
  See File::Spec::Unix for a documentation of the methods provided
  there. This package overrides the implementation of these methods, not
  the semantics.
  
  =over 4
  
  =item devnull
  
  Returns a string representation of the null device.
  
  =cut
  
  sub devnull {
      return "nul";
  }
  
  sub rootdir { '\\' }
  
  
  =item tmpdir
  
  Returns a string representation of the first existing directory
  from the following list:
  
      $ENV{TMPDIR}
      $ENV{TEMP}
      $ENV{TMP}
      SYS:/temp
      C:\system\temp
      C:/temp
      /tmp
      /
  
  The SYS:/temp is preferred in Novell NetWare and the C:\system\temp
  for Symbian (the File::Spec::Win32 is used also for those platforms).
  
  Since Perl 5.8.0, if running under taint mode, and if the environment
  variables are tainted, they are not used.
  
  =cut
  
  my $tmpdir;
  sub tmpdir {
      return $tmpdir if defined $tmpdir;
      $tmpdir = $_[0]->_tmpdir( map( $ENV{$_}, qw(TMPDIR TEMP TMP) ),
  			      'SYS:/temp',
  			      'C:\system\temp',
  			      'C:/temp',
  			      '/tmp',
  			      '/'  );
  }
  
  =item case_tolerant
  
  MSWin32 case-tolerance depends on GetVolumeInformation() $ouFsFlags == FS_CASE_SENSITIVE,
  indicating the case significance when comparing file specifications.
  Since XP FS_CASE_SENSITIVE is effectively disabled for the NT subsubsystem.
  See http://cygwin.com/ml/cygwin/2007-07/msg00891.html
  Default: 1
  
  =cut
  
  sub case_tolerant {
    eval { require Win32API::File; } or return 1;
    my $drive = shift || "C:";
    my $osFsType = "\0"x256;
    my $osVolName = "\0"x256;
    my $ouFsFlags = 0;
    Win32API::File::GetVolumeInformation($drive, $osVolName, 256, [], [], $ouFsFlags, $osFsType, 256 );
    if ($ouFsFlags & Win32API::File::FS_CASE_SENSITIVE()) { return 0; }
    else { return 1; }
  }
  
  =item file_name_is_absolute
  
  As of right now, this returns 2 if the path is absolute with a
  volume, 1 if it's absolute with no volume, 0 otherwise.
  
  =cut
  
  sub file_name_is_absolute {
  
      my ($self,$file) = @_;
  
      if ($file =~ m{^($VOL_RX)}o) {
        my $vol = $1;
        return ($vol =~ m{^$UNC_RX}o ? 2
  	      : $file =~ m{^$DRIVE_RX[\\/]}o ? 2
  	      : 0);
      }
      return $file =~  m{^[\\/]} ? 1 : 0;
  }
  
  =item catfile
  
  Concatenate one or more directory names and a filename to form a
  complete path ending with a filename
  
  =cut
  
  sub catfile {
      shift;
  
      # Legacy / compatibility support
      #
      shift, return _canon_cat( "/", @_ )
  	if $_[0] eq "";
  
      # Compatibility with File::Spec <= 3.26:
      #     catfile('A:', 'foo') should return 'A:\foo'.
      return _canon_cat( ($_[0].'\\'), @_[1..$#_] )
          if $_[0] =~ m{^$DRIVE_RX\z}o;
  
      return _canon_cat( @_ );
  }
  
  sub catdir {
      shift;
  
      # Legacy / compatibility support
      #
      return ""
      	unless @_;
      shift, return _canon_cat( "/", @_ )
  	if $_[0] eq "";
  
      # Compatibility with File::Spec <= 3.26:
      #     catdir('A:', 'foo') should return 'A:\foo'.
      return _canon_cat( ($_[0].'\\'), @_[1..$#_] )
          if $_[0] =~ m{^$DRIVE_RX\z}o;
  
      return _canon_cat( @_ );
  }
  
  sub path {
      my @path = split(';', $ENV{PATH});
      s/"//g for @path;
      @path = grep length, @path;
      unshift(@path, ".");
      return @path;
  }
  
  =item canonpath
  
  No physical check on the filesystem, but a logical cleanup of a
  path. On UNIX eliminated successive slashes and successive "/.".
  On Win32 makes 
  
  	dir1\dir2\dir3\..\..\dir4 -> \dir\dir4 and even
  	dir1\dir2\dir3\...\dir4   -> \dir\dir4
  
  =cut
  
  sub canonpath {
      # Legacy / compatibility support
      #
      return $_[1] if !defined($_[1]) or $_[1] eq '';
      return _canon_cat( $_[1] );
  }
  
  =item splitpath
  
      ($volume,$directories,$file) = File::Spec->splitpath( $path );
      ($volume,$directories,$file) = File::Spec->splitpath( $path, $no_file );
  
  Splits a path into volume, directory, and filename portions. Assumes that 
  the last file is a path unless the path ends in '\\', '\\.', '\\..'
  or $no_file is true.  On Win32 this means that $no_file true makes this return 
  ( $volume, $path, '' ).
  
  Separators accepted are \ and /.
  
  Volumes can be drive letters or UNC sharenames (\\server\share).
  
  The results can be passed to L</catpath> to get back a path equivalent to
  (usually identical to) the original path.
  
  =cut
  
  sub splitpath {
      my ($self,$path, $nofile) = @_;
      my ($volume,$directory,$file) = ('','','');
      if ( $nofile ) {
          $path =~ 
              m{^ ( $VOL_RX ? ) (.*) }sox;
          $volume    = $1;
          $directory = $2;
      }
      else {
          $path =~ 
              m{^ ( $VOL_RX ? )
                  ( (?:.*[\\/](?:\.\.?\Z(?!\n))?)? )
                  (.*)
               }sox;
          $volume    = $1;
          $directory = $2;
          $file      = $3;
      }
  
      return ($volume,$directory,$file);
  }
  
  
  =item splitdir
  
  The opposite of L<catdir()|File::Spec/catdir()>.
  
      @dirs = File::Spec->splitdir( $directories );
  
  $directories must be only the directory portion of the path on systems 
  that have the concept of a volume or that have path syntax that differentiates
  files from directories.
  
  Unlike just splitting the directories on the separator, leading empty and 
  trailing directory entries can be returned, because these are significant
  on some OSs. So,
  
      File::Spec->splitdir( "/a/b/c" );
  
  Yields:
  
      ( '', 'a', 'b', '', 'c', '' )
  
  =cut
  
  sub splitdir {
      my ($self,$directories) = @_ ;
      #
      # split() likes to forget about trailing null fields, so here we
      # check to be sure that there will not be any before handling the
      # simple case.
      #
      if ( $directories !~ m|[\\/]\Z(?!\n)| ) {
          return split( m|[\\/]|, $directories );
      }
      else {
          #
          # since there was a trailing separator, add a file name to the end, 
          # then do the split, then replace it with ''.
          #
          my( @directories )= split( m|[\\/]|, "${directories}dummy" ) ;
          $directories[ $#directories ]= '' ;
          return @directories ;
      }
  }
  
  
  =item catpath
  
  Takes volume, directory and file portions and returns an entire path. Under
  Unix, $volume is ignored, and this is just like catfile(). On other OSs,
  the $volume become significant.
  
  =cut
  
  sub catpath {
      my ($self,$volume,$directory,$file) = @_;
  
      # If it's UNC, make sure the glue separator is there, reusing
      # whatever separator is first in the $volume
      my $v;
      $volume .= $v
          if ( (($v) = $volume =~ m@^([\\/])[\\/][^\\/]+[\\/][^\\/]+\Z(?!\n)@s) &&
               $directory =~ m@^[^\\/]@s
             ) ;
  
      $volume .= $directory ;
  
      # If the volume is not just A:, make sure the glue separator is 
      # there, reusing whatever separator is first in the $volume if possible.
      if ( $volume !~ m@^[a-zA-Z]:\Z(?!\n)@s &&
           $volume =~ m@[^\\/]\Z(?!\n)@      &&
           $file   =~ m@[^\\/]@
         ) {
          $volume =~ m@([\\/])@ ;
          my $sep = $1 ? $1 : '\\' ;
          $volume .= $sep ;
      }
  
      $volume .= $file ;
  
      return $volume ;
  }
  
  sub _same {
    lc($_[1]) eq lc($_[2]);
  }
  
  sub rel2abs {
      my ($self,$path,$base ) = @_;
  
      my $is_abs = $self->file_name_is_absolute($path);
  
      # Check for volume (should probably document the '2' thing...)
      return $self->canonpath( $path ) if $is_abs == 2;
  
      if ($is_abs) {
        # It's missing a volume, add one
        my $vol = ($self->splitpath( $self->_cwd() ))[0];
        return $self->canonpath( $vol . $path );
      }
  
      if ( !defined( $base ) || $base eq '' ) {
        require Cwd ;
        $base = Cwd::getdcwd( ($self->splitpath( $path ))[0] ) if defined &Cwd::getdcwd ;
        $base = $self->_cwd() unless defined $base ;
      }
      elsif ( ! $self->file_name_is_absolute( $base ) ) {
        $base = $self->rel2abs( $base ) ;
      }
      else {
        $base = $self->canonpath( $base ) ;
      }
  
      my ( $path_directories, $path_file ) =
        ($self->splitpath( $path, 1 ))[1,2] ;
  
      my ( $base_volume, $base_directories ) =
        $self->splitpath( $base, 1 ) ;
  
      $path = $self->catpath( 
  			   $base_volume, 
  			   $self->catdir( $base_directories, $path_directories ), 
  			   $path_file
  			  ) ;
  
      return $self->canonpath( $path ) ;
  }
  
  =back
  
  =head2 Note For File::Spec::Win32 Maintainers
  
  Novell NetWare inherits its File::Spec behaviour from File::Spec::Win32.
  
  =head1 COPYRIGHT
  
  Copyright (c) 2004,2007 by the Perl 5 Porters.  All rights reserved.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =head1 SEE ALSO
  
  See L<File::Spec> and L<File::Spec::Unix>.  This package overrides the
  implementation of these methods, not the semantics.
  
  =cut
  
  
  sub _canon_cat				# @path -> path
  {
      my ($first, @rest) = @_;
  
      my $volume = $first =~ s{ \A ([A-Za-z]:) ([\\/]?) }{}x	# drive letter
      	       ? ucfirst( $1 ).( $2 ? "\\" : "" )
  	       : $first =~ s{ \A (?:\\\\|//) ([^\\/]+)
  				 (?: [\\/] ([^\\/]+) )?
  	       			 [\\/]? }{}xs			# UNC volume
  	       ? "\\\\$1".( defined $2 ? "\\$2" : "" )."\\"
  	       : $first =~ s{ \A [\\/] }{}x			# root dir
  	       ? "\\"
  	       : "";
      my $path   = join "\\", $first, @rest;
  
      $path =~ tr#\\/#\\\\#s;		# xx/yy --> xx\yy & xx\\yy --> xx\yy
  
      					# xx/././yy --> xx/yy
      $path =~ s{(?:
  		(?:\A|\\)		# at begin or after a slash
  		\.
  		(?:\\\.)*		# and more
  		(?:\\|\z) 		# at end or followed by slash
  	       )+			# performance boost -- I do not know why
  	     }{\\}gx;
  
      # XXX I do not know whether more dots are supported by the OS supporting
      #     this ... annotation (NetWare or symbian but not MSWin32).
      #     Then .... could easily become ../../.. etc:
      # Replace \.\.\. by (\.\.\.+)  and substitute with
      # { $1 . ".." . "\\.." x (length($2)-2) }gex
  	     				# ... --> ../..
      $path =~ s{ (\A|\\)			# at begin or after a slash
      		\.\.\.
  		(?=\\|\z) 		# at end or followed by slash
  	     }{$1..\\..}gx;
      					# xx\yy\..\zz --> xx\zz
      while ( $path =~ s{(?:
  		(?:\A|\\)		# at begin or after a slash
  		[^\\]+			# rip this 'yy' off
  		\\\.\.
  		(?<!\A\.\.\\\.\.)	# do *not* replace ^..\..
  		(?<!\\\.\.\\\.\.)	# do *not* replace \..\..
  		(?:\\|\z) 		# at end or followed by slash
  	       )+			# performance boost -- I do not know why
  	     }{\\}sx ) {}
  
      $path =~ s#\A\\##;			# \xx --> xx  NOTE: this is *not* root
      $path =~ s#\\\z##;			# xx\ --> xx
  
      if ( $volume =~ m#\\\z# )
      {					# <vol>\.. --> <vol>\
  	$path =~ s{ \A			# at begin
  		    \.\.
  		    (?:\\\.\.)*		# and more
  		    (?:\\|\z) 		# at end or followed by slash
  		 }{}x;
  
  	return $1			# \\HOST\SHARE\ --> \\HOST\SHARE
  	    if    $path eq ""
  	      and $volume =~ m#\A(\\\\.*)\\\z#s;
      }
      return $path ne "" || $volume ? $volume.$path : ".";
  }
  
  1;
I386-LINUX-THREAD-MULTI_FILE_SPEC_WIN32

$fatpacked{"i386-linux-thread-multi/List/Util.pm"} = <<'I386-LINUX-THREAD-MULTI_LIST_UTIL';
  # List::Util.pm
  #
  # Copyright (c) 1997-2009 Graham Barr <gbarr@pobox.com>. All rights reserved.
  # This program is free software; you can redistribute it and/or
  # modify it under the same terms as Perl itself.
  #
  # This module is normally only loaded if the XS module is not available
  
  package List::Util;
  
  use strict;
  use vars qw(@ISA @EXPORT_OK $VERSION $XS_VERSION $TESTING_PERL_ONLY);
  require Exporter;
  
  @ISA        = qw(Exporter);
  @EXPORT_OK  = qw(first min max minstr maxstr reduce sum shuffle);
  $VERSION    = "1.23";
  $XS_VERSION = $VERSION;
  $VERSION    = eval $VERSION;
  
  eval {
    # PERL_DL_NONLAZY must be false, or any errors in loading will just
    # cause the perl code to be tested
    local $ENV{PERL_DL_NONLAZY} = 0 if $ENV{PERL_DL_NONLAZY};
    eval {
      require XSLoader;
      XSLoader::load('List::Util', $XS_VERSION);
      1;
    } or do {
      require DynaLoader;
      local @ISA = qw(DynaLoader);
      bootstrap List::Util $XS_VERSION;
    };
  } unless $TESTING_PERL_ONLY;
  
  
  if (!defined &sum) {
    require List::Util::PP;
    List::Util::PP->import;
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  List::Util - A selection of general-utility list subroutines
  
  =head1 SYNOPSIS
  
      use List::Util qw(first max maxstr min minstr reduce shuffle sum);
  
  =head1 DESCRIPTION
  
  C<List::Util> contains a selection of subroutines that people have
  expressed would be nice to have in the perl core, but the usage would
  not really be high enough to warrant the use of a keyword, and the size
  so small such that being individual extensions would be wasteful.
  
  By default C<List::Util> does not export any subroutines. The
  subroutines defined are
  
  =over 4
  
  =item first BLOCK LIST
  
  Similar to C<grep> in that it evaluates BLOCK setting C<$_> to each element
  of LIST in turn. C<first> returns the first element where the result from
  BLOCK is a true value. If BLOCK never returns true or LIST was empty then
  C<undef> is returned.
  
      $foo = first { defined($_) } @list    # first defined value in @list
      $foo = first { $_ > $value } @list    # first value in @list which
                                            # is greater than $value
  
  This function could be implemented using C<reduce> like this
  
      $foo = reduce { defined($a) ? $a : wanted($b) ? $b : undef } undef, @list
  
  for example wanted() could be defined() which would return the first
  defined value in @list
  
  =item max LIST
  
  Returns the entry in the list with the highest numerical value. If the
  list is empty then C<undef> is returned.
  
      $foo = max 1..10                # 10
      $foo = max 3,9,12               # 12
      $foo = max @bar, @baz           # whatever
  
  This function could be implemented using C<reduce> like this
  
      $foo = reduce { $a > $b ? $a : $b } 1..10
  
  =item maxstr LIST
  
  Similar to C<max>, but treats all the entries in the list as strings
  and returns the highest string as defined by the C<gt> operator.
  If the list is empty then C<undef> is returned.
  
      $foo = maxstr 'A'..'Z'          # 'Z'
      $foo = maxstr "hello","world"   # "world"
      $foo = maxstr @bar, @baz        # whatever
  
  This function could be implemented using C<reduce> like this
  
      $foo = reduce { $a gt $b ? $a : $b } 'A'..'Z'
  
  =item min LIST
  
  Similar to C<max> but returns the entry in the list with the lowest
  numerical value. If the list is empty then C<undef> is returned.
  
      $foo = min 1..10                # 1
      $foo = min 3,9,12               # 3
      $foo = min @bar, @baz           # whatever
  
  This function could be implemented using C<reduce> like this
  
      $foo = reduce { $a < $b ? $a : $b } 1..10
  
  =item minstr LIST
  
  Similar to C<min>, but treats all the entries in the list as strings
  and returns the lowest string as defined by the C<lt> operator.
  If the list is empty then C<undef> is returned.
  
      $foo = minstr 'A'..'Z'          # 'A'
      $foo = minstr "hello","world"   # "hello"
      $foo = minstr @bar, @baz        # whatever
  
  This function could be implemented using C<reduce> like this
  
      $foo = reduce { $a lt $b ? $a : $b } 'A'..'Z'
  
  =item reduce BLOCK LIST
  
  Reduces LIST by calling BLOCK, in a scalar context, multiple times,
  setting C<$a> and C<$b> each time. The first call will be with C<$a>
  and C<$b> set to the first two elements of the list, subsequent
  calls will be done by setting C<$a> to the result of the previous
  call and C<$b> to the next element in the list.
  
  Returns the result of the last call to BLOCK. If LIST is empty then
  C<undef> is returned. If LIST only contains one element then that
  element is returned and BLOCK is not executed.
  
      $foo = reduce { $a < $b ? $a : $b } 1..10       # min
      $foo = reduce { $a lt $b ? $a : $b } 'aa'..'zz' # minstr
      $foo = reduce { $a + $b } 1 .. 10               # sum
      $foo = reduce { $a . $b } @bar                  # concat
  
  If your algorithm requires that C<reduce> produce an identity value, then
  make sure that you always pass that identity value as the first argument to prevent
  C<undef> being returned
  
    $foo = reduce { $a + $b } 0, @values;             # sum with 0 identity value
  
  =item shuffle LIST
  
  Returns the elements of LIST in a random order
  
      @cards = shuffle 0..51      # 0..51 in a random order
  
  =item sum LIST
  
  Returns the sum of all the elements in LIST. If LIST is empty then
  C<undef> is returned.
  
      $foo = sum 1..10                # 55
      $foo = sum 3,9,12               # 24
      $foo = sum @bar, @baz           # whatever
  
  This function could be implemented using C<reduce> like this
  
      $foo = reduce { $a + $b } 1..10
  
  If your algorithm requires that C<sum> produce an identity of 0, then
  make sure that you always pass C<0> as the first argument to prevent
  C<undef> being returned
  
    $foo = sum 0, @values;
  
  =back
  
  =head1 KNOWN BUGS
  
  With perl versions prior to 5.005 there are some cases where reduce
  will return an incorrect result. This will show up as test 7 of
  reduce.t failing.
  
  =head1 SUGGESTED ADDITIONS
  
  The following are additions that have been requested, but I have been reluctant
  to add due to them being very simple to implement in perl
  
    # One argument is true
  
    sub any { $_ && return 1 for @_; 0 }
  
    # All arguments are true
  
    sub all { $_ || return 0 for @_; 1 }
  
    # All arguments are false
  
    sub none { $_ && return 0 for @_; 1 }
  
    # One argument is false
  
    sub notall { $_ || return 1 for @_; 0 }
  
    # How many elements are true
  
    sub true { scalar grep { $_ } @_ }
  
    # How many elements are false
  
    sub false { scalar grep { !$_ } @_ }
  
  =head1 SEE ALSO
  
  L<Scalar::Util>, L<List::MoreUtils>
  
  =head1 COPYRIGHT
  
  Copyright (c) 1997-2007 Graham Barr <gbarr@pobox.com>. All rights reserved.
  This program is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  =cut
I386-LINUX-THREAD-MULTI_LIST_UTIL

$fatpacked{"i386-linux-thread-multi/List/Util/PP.pm"} = <<'I386-LINUX-THREAD-MULTI_LIST_UTIL_PP';
  # List::Util::PP.pm
  #
  # Copyright (c) 1997-2009 Graham Barr <gbarr@pobox.com>. All rights reserved.
  # This program is free software; you can redistribute it and/or
  # modify it under the same terms as Perl itself.
  
  package List::Util::PP;
  
  use strict;
  use warnings;
  use vars qw(@ISA @EXPORT $VERSION $a $b);
  require Exporter;
  
  @ISA     = qw(Exporter);
  @EXPORT  = qw(first min max minstr maxstr reduce sum shuffle);
  $VERSION = "1.23";
  $VERSION = eval $VERSION;
  
  sub reduce (&@) {
    my $code = shift;
    require Scalar::Util;
    my $type = Scalar::Util::reftype($code);
    unless($type and $type eq 'CODE') {
      require Carp;
      Carp::croak("Not a subroutine reference");
    }
    no strict 'refs';
  
    return shift unless @_ > 1;
  
    use vars qw($a $b);
  
    my $caller = caller;
    local(*{$caller."::a"}) = \my $a;
    local(*{$caller."::b"}) = \my $b;
  
    $a = shift;
    foreach (@_) {
      $b = $_;
      $a = &{$code}();
    }
  
    $a;
  }
  
  sub first (&@) {
    my $code = shift;
    require Scalar::Util;
    my $type = Scalar::Util::reftype($code);
    unless($type and $type eq 'CODE') {
      require Carp;
      Carp::croak("Not a subroutine reference");
    }
  
    foreach (@_) {
      return $_ if &{$code}();
    }
  
    undef;
  }
  
  
  sub sum (@) { reduce { $a + $b } @_ }
  
  sub min (@) { reduce { $a < $b ? $a : $b } @_ }
  
  sub max (@) { reduce { $a > $b ? $a : $b } @_ }
  
  sub minstr (@) { reduce { $a lt $b ? $a : $b } @_ }
  
  sub maxstr (@) { reduce { $a gt $b ? $a : $b } @_ }
  
  sub shuffle (@) {
    my @a=\(@_);
    my $n;
    my $i=@_;
    map {
      $n = rand($i--);
      (${$a[$n]}, $a[$n] = $a[$i])[0];
    } @_;
  }
  
  1;
I386-LINUX-THREAD-MULTI_LIST_UTIL_PP

$fatpacked{"i386-linux-thread-multi/List/Util/XS.pm"} = <<'I386-LINUX-THREAD-MULTI_LIST_UTIL_XS';
  package List::Util::XS;
  use strict;
  use vars qw($VERSION);
  use List::Util;
  
  $VERSION = "1.23";           # FIXUP
  $VERSION = eval $VERSION;    # FIXUP
  
  sub _VERSION { # FIXUP
    require Carp;
    Carp::croak("You need to install Scalar-List-Utils with a C compiler to ensure the XS is compiled")
      if defined $_[1];
    $VERSION;
  }
  
  1;
  __END__
  
  =head1 NAME
  
  List::Util::XS - Indicate if List::Util was compiled with a C compiler
  
  =head1 SYNOPSIS
  
      use List::Util::XS 1.20;
  
  =head1 DESCRIPTION
  
  C<List::Util::XS> can be used as a dependency to ensure List::Util was
  installed using a C compiler and that the XS version is installed.
  
  During installation C<$List::Util::XS::VERSION> will be set to
  C<undef> if the XS was not compiled.
  
  =head1 SEE ALSO
  
  L<Scalar::Util>, L<List::Util>, L<List::MoreUtils>
  
  =head1 COPYRIGHT
  
  Copyright (c) 2008 Graham Barr <gbarr@pobox.com>. All rights reserved.
  This program is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  =cut
I386-LINUX-THREAD-MULTI_LIST_UTIL_XS

$fatpacked{"i386-linux-thread-multi/Scalar/Util.pm"} = <<'I386-LINUX-THREAD-MULTI_SCALAR_UTIL';
  # Scalar::Util.pm
  #
  # Copyright (c) 1997-2007 Graham Barr <gbarr@pobox.com>. All rights reserved.
  # This program is free software; you can redistribute it and/or
  # modify it under the same terms as Perl itself.
  
  package Scalar::Util;
  
  use strict;
  use vars qw(@ISA @EXPORT_OK $VERSION @EXPORT_FAIL);
  require Exporter;
  require List::Util; # List::Util loads the XS
  
  @ISA       = qw(Exporter);
  @EXPORT_OK = qw(blessed dualvar reftype weaken isweak tainted readonly openhandle refaddr isvstring looks_like_number set_prototype);
  $VERSION    = "1.23";
  $VERSION   = eval $VERSION;
  
  unless (defined &dualvar) {
    # Load Pure Perl version if XS not loaded
    require Scalar::Util::PP;
    Scalar::Util::PP->import;
    push @EXPORT_FAIL, qw(weaken isweak dualvar isvstring set_prototype);
  }
  
  sub export_fail {
    if (grep { /dualvar/ } @EXPORT_FAIL) { # no XS loaded
      my $pat = join("|", @EXPORT_FAIL);
      if (my ($err) = grep { /^($pat)$/ } @_ ) {
        require Carp;
        Carp::croak("$err is only available with the XS version of Scalar::Util");
      }
    }
  
    if (grep { /^(weaken|isweak)$/ } @_ ) {
      require Carp;
      Carp::croak("Weak references are not implemented in the version of perl");
    }
  
    if (grep { /^(isvstring)$/ } @_ ) {
      require Carp;
      Carp::croak("Vstrings are not implemented in the version of perl");
    }
  
    @_;
  }
  
  sub openhandle ($) {
    my $fh = shift;
    my $rt = reftype($fh) || '';
  
    return defined(fileno($fh)) ? $fh : undef
      if $rt eq 'IO';
  
    if (reftype(\$fh) eq 'GLOB') { # handle  openhandle(*DATA)
      $fh = \(my $tmp=$fh);
    }
    elsif ($rt ne 'GLOB') {
      return undef;
    }
  
    (tied(*$fh) or defined(fileno($fh)))
      ? $fh : undef;
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Scalar::Util - A selection of general-utility scalar subroutines
  
  =head1 SYNOPSIS
  
      use Scalar::Util qw(blessed dualvar isweak readonly refaddr reftype tainted
                          weaken isvstring looks_like_number set_prototype);
                          # and other useful utils appearing below
  
  =head1 DESCRIPTION
  
  C<Scalar::Util> contains a selection of subroutines that people have
  expressed would be nice to have in the perl core, but the usage would
  not really be high enough to warrant the use of a keyword, and the size
  so small such that being individual extensions would be wasteful.
  
  By default C<Scalar::Util> does not export any subroutines. The
  subroutines defined are
  
  =over 4
  
  =item blessed EXPR
  
  If EXPR evaluates to a blessed reference the name of the package
  that it is blessed into is returned. Otherwise C<undef> is returned.
  
     $scalar = "foo";
     $class  = blessed $scalar;           # undef
  
     $ref    = [];
     $class  = blessed $ref;              # undef
  
     $obj    = bless [], "Foo";
     $class  = blessed $obj;              # "Foo"
  
  =item dualvar NUM, STRING
  
  Returns a scalar that has the value NUM in a numeric context and the
  value STRING in a string context.
  
      $foo = dualvar 10, "Hello";
      $num = $foo + 2;                    # 12
      $str = $foo . " world";             # Hello world
  
  =item isvstring EXPR
  
  If EXPR is a scalar which was coded as a vstring the result is true.
  
      $vs   = v49.46.48;
      $fmt  = isvstring($vs) ? "%vd" : "%s"; #true
      printf($fmt,$vs);
  
  =item isweak EXPR
  
  If EXPR is a scalar which is a weak reference the result is true.
  
      $ref  = \$foo;
      $weak = isweak($ref);               # false
      weaken($ref);
      $weak = isweak($ref);               # true
  
  B<NOTE>: Copying a weak reference creates a normal, strong, reference.
  
      $copy = $ref;
      $weak = isweak($copy);              # false
  
  =item looks_like_number EXPR
  
  Returns true if perl thinks EXPR is a number. See
  L<perlapi/looks_like_number>.
  
  =item openhandle FH
  
  Returns FH if FH may be used as a filehandle and is open, or FH is a tied
  handle. Otherwise C<undef> is returned.
  
      $fh = openhandle(*STDIN);		# \*STDIN
      $fh = openhandle(\*STDIN);		# \*STDIN
      $fh = openhandle(*NOTOPEN);		# undef
      $fh = openhandle("scalar");		# undef
      
  =item readonly SCALAR
  
  Returns true if SCALAR is readonly.
  
      sub foo { readonly($_[0]) }
  
      $readonly = foo($bar);              # false
      $readonly = foo(0);                 # true
  
  =item refaddr EXPR
  
  If EXPR evaluates to a reference the internal memory address of
  the referenced value is returned. Otherwise C<undef> is returned.
  
      $addr = refaddr "string";           # undef
      $addr = refaddr \$var;              # eg 12345678
      $addr = refaddr [];                 # eg 23456784
  
      $obj  = bless {}, "Foo";
      $addr = refaddr $obj;               # eg 88123488
  
  =item reftype EXPR
  
  If EXPR evaluates to a reference the type of the variable referenced
  is returned. Otherwise C<undef> is returned.
  
      $type = reftype "string";           # undef
      $type = reftype \$var;              # SCALAR
      $type = reftype [];                 # ARRAY
  
      $obj  = bless {}, "Foo";
      $type = reftype $obj;               # HASH
  
  =item set_prototype CODEREF, PROTOTYPE
  
  Sets the prototype of the given function, or deletes it if PROTOTYPE is
  undef. Returns the CODEREF.
  
      set_prototype \&foo, '$$';
  
  =item tainted EXPR
  
  Return true if the result of EXPR is tainted
  
      $taint = tainted("constant");       # false
      $taint = tainted($ENV{PWD});        # true if running under -T
  
  =item weaken REF
  
  REF will be turned into a weak reference. This means that it will not
  hold a reference count on the object it references. Also when the reference
  count on that object reaches zero, REF will be set to undef.
  
  This is useful for keeping copies of references , but you don't want to
  prevent the object being DESTROY-ed at its usual time.
  
      {
        my $var;
        $ref = \$var;
        weaken($ref);                     # Make $ref a weak reference
      }
      # $ref is now undef
  
  Note that if you take a copy of a scalar with a weakened reference,
  the copy will be a strong reference.
  
      my $var;
      my $foo = \$var;
      weaken($foo);                       # Make $foo a weak reference
      my $bar = $foo;                     # $bar is now a strong reference
  
  This may be less obvious in other situations, such as C<grep()>, for instance
  when grepping through a list of weakened references to objects that may have
  been destroyed already:
  
      @object = grep { defined } @object;
  
  This will indeed remove all references to destroyed objects, but the remaining
  references to objects will be strong, causing the remaining objects to never
  be destroyed because there is now always a strong reference to them in the
  @object array.
  
  =back
  
  =head1 DIAGNOSTICS
  
  Module use may give one of the following errors during import.
  
  =over
  
  =item Weak references are not implemented in the version of perl
  
  The version of perl that you are using does not implement weak references, to use
  C<isweak> or C<weaken> you will need to use a newer release of perl.
  
  =item Vstrings are not implemented in the version of perl
  
  The version of perl that you are using does not implement Vstrings, to use
  C<isvstring> you will need to use a newer release of perl.
  
  =item C<NAME> is only available with the XS version of Scalar::Util
  
  C<Scalar::Util> contains both perl and C implementations of many of its functions
  so that those without access to a C compiler may still use it. However some of the functions
  are only available when a C compiler was available to compile the XS version of the extension.
  
  At present that list is: weaken, isweak, dualvar, isvstring, set_prototype
  
  =back
  
  =head1 KNOWN BUGS
  
  There is a bug in perl5.6.0 with UV's that are >= 1<<31. This will
  show up as tests 8 and 9 of dualvar.t failing
  
  =head1 SEE ALSO
  
  L<List::Util>
  
  =head1 COPYRIGHT
  
  Copyright (c) 1997-2007 Graham Barr <gbarr@pobox.com>. All rights reserved.
  This program is free software; you can redistribute it and/or modify it
  under the same terms as Perl itself.
  
  Except weaken and isweak which are
  
  Copyright (c) 1999 Tuomas J. Lukka <lukka@iki.fi>. All rights reserved.
  This program is free software; you can redistribute it and/or modify it
  under the same terms as perl itself.
  
  =cut
I386-LINUX-THREAD-MULTI_SCALAR_UTIL

$fatpacked{"i386-linux-thread-multi/Scalar/Util/PP.pm"} = <<'I386-LINUX-THREAD-MULTI_SCALAR_UTIL_PP';
  # Scalar::Util::PP.pm
  #
  # Copyright (c) 1997-2009 Graham Barr <gbarr@pobox.com>. All rights reserved.
  # This program is free software; you can redistribute it and/or
  # modify it under the same terms as Perl itself.
  #
  # This module is normally only loaded if the XS module is not available
  
  package Scalar::Util::PP;
  
  use strict;
  use warnings;
  use vars qw(@ISA @EXPORT $VERSION $recurse);
  require Exporter;
  use B qw(svref_2object);
  
  @ISA     = qw(Exporter);
  @EXPORT  = qw(blessed reftype tainted readonly refaddr looks_like_number);
  $VERSION = "1.23";
  $VERSION = eval $VERSION;
  
  sub blessed ($) {
    return undef unless length(ref($_[0]));
    my $b = svref_2object($_[0]);
    return undef unless $b->isa('B::PVMG');
    my $s = $b->SvSTASH;
    return $s->isa('B::HV') ? $s->NAME : undef;
  }
  
  sub refaddr($) {
    return undef unless length(ref($_[0]));
  
    my $addr;
    if(defined(my $pkg = blessed($_[0]))) {
      $addr .= bless $_[0], 'Scalar::Util::Fake';
      bless $_[0], $pkg;
    }
    else {
      $addr .= $_[0]
    }
  
    $addr =~ /0x(\w+)/;
    local $^W;
    no warnings 'portable';
    hex($1);
  }
  
  {
    my %tmap = qw(
      B::NULL   SCALAR
  
      B::HV     HASH
      B::AV     ARRAY
      B::CV     CODE
      B::IO     IO
      B::GV     GLOB
      B::REGEXP REGEXP
    );
  
    sub reftype ($) {
      my $r = shift;
  
      return undef unless length(ref($r));
  
      my $t = ref(svref_2object($r));
  
      return
          exists $tmap{$t} ? $tmap{$t}
        : length(ref($$r)) ? 'REF'
        :                    'SCALAR';
    }
  }
  
  sub tainted {
    local($@, $SIG{__DIE__}, $SIG{__WARN__});
    local $^W = 0;
    no warnings;
    eval { kill 0 * $_[0] };
    $@ =~ /^Insecure/;
  }
  
  sub readonly {
    return 0 if tied($_[0]) || (ref(\($_[0])) ne "SCALAR");
  
    local($@, $SIG{__DIE__}, $SIG{__WARN__});
    my $tmp = $_[0];
  
    !eval { $_[0] = $tmp; 1 };
  }
  
  sub looks_like_number {
    local $_ = shift;
  
    # checks from perlfaq4
    return 0 if !defined($_);
    if (ref($_)) {
      require overload;
      return overload::Overloaded($_) ? defined(0 + $_) : 0;
    }
    return 1 if (/^[+-]?[0-9]+$/); # is a +/- integer
    return 1 if (/^([+-]?)(?=[0-9]|\.[0-9])[0-9]*(\.[0-9]*)?([Ee]([+-]?[0-9]+))?$/); # a C float
    return 1 if ($] >= 5.008 and /^(Inf(inity)?|NaN)$/i) or ($] >= 5.006001 and /^Inf$/i);
  
    0;
  }
  
  
  1;
I386-LINUX-THREAD-MULTI_SCALAR_UTIL_PP

$fatpacked{"i386-linux-thread-multi/Sub/Name.pm"} = <<'I386-LINUX-THREAD-MULTI_SUB_NAME';
  package Sub::Name;
  
  =head1 NAME
  
  Sub::Name - (re)name a sub
  
  =head1 SYNOPSIS
  
      use Sub::Name;
  
      subname $name, $subref;
  
      $subref = subname foo => sub { ... };
  
  =head1 DESCRIPTION
  
  This module has only one function, which is also exported by default:
  
  =head2 subname NAME, CODEREF
  
  Assigns a new name to referenced sub.  If package specification is omitted in 
  the name, then the current package is used.  The return value is the sub.
  
  The name is only used for informative routines (caller, Carp, etc).  You won't 
  be able to actually invoke the sub by the given name.  To allow that, you need 
  to do glob-assignment yourself.
  
  Note that for anonymous closures (subs that reference lexicals declared outside 
  the sub itself) you can name each instance of the closure differently, which 
  can be very useful for debugging.
  
  =head1 AUTHOR
  
  Matthijs van Duin <xmath@cpan.org>
  
  Copyright (C) 2004, 2008  Matthijs van Duin.  All rights reserved.
  This program is free software; you can redistribute it and/or modify 
  it under the same terms as Perl itself.
  
  =cut
  
  use 5.006;
  
  use strict;
  use warnings;
  
  our $VERSION = '0.04';
  
  use base 'Exporter';
  use base 'DynaLoader';
  
  our @EXPORT = qw(subname);
  our @EXPORT_OK = @EXPORT;
  
  bootstrap Sub::Name $VERSION;
  
  1;
I386-LINUX-THREAD-MULTI_SUB_NAME

s/^  //mg for values %fatpacked;

unshift @INC, sub {
  if (my $fat = $fatpacked{$_[1]}) {
    open my $fh, '<', \$fat
      or die "FatPacker error loading $_[1] (could be a perl installation issue?)";
    return $fh;
  }
  return
};

} # END OF FATPACK CODE
#!/usr/bin/env perl
# author:        yanglei@snda.com
# last modified: 2011-04-12
# description:   this script collects interesting data then send to some place for scrunity.

use strict;
use warnings;
use File::Path;
use POSIX qw( strftime );
use Getopt::Long;
use IO::Socket;
use File::ReadBackwards;
use Sys::Statistics::Linux::DiskUsage;
use Date::Parse;
use File::Spec;
use Data::Dumper;
use Carp;
use Try::Tiny;
use Ocollector::ServiceMonitor::Memcached;
use Ocollector::AccountServer::StatisticDetails;
use Ocollector::AccountServer::Cache;
use Ocollector::AccountServer::DBComErr;
use Ocollector::AccountServer::AC;
use Ocollector::CloudStat::Wrapper;
use Ocollector::Nginx::SLA;
use Ocollector::Nginx::ErrorLog;
use Ocollector::Nginx::RegionLatency;
use Ocollector::IIS::Error2;
use Ocollector::Tcpbasic::Windows;
use Ocollector::NetAppliance::Cisco::Switch;

# Hacked oneline to remove dependency on version module, which requires a XS file that we can't pack.
our $VERSION = "1.15";
$VERSION = eval $VERSION;

my $O_ERROR = q{};

sub usage {
    my $type = shift;

    if ($type == 1) {
        die <<USAGE;
Usage: ocollector [options] -t type

Try `ocollector --help` or `ocollector -h` for more options.
USAGE
    }

    die <<HELP;
Usage: ocollector [options] -t type

Options:
    -v,--verbose                          Print the full collecting results
    -q,--quiet                            Suppress all output even error messages
    -h,--help                             Print this help
    -o,--to                               Specify the address where metrics send to, default: op.sdo.com
    -p,--port                             Specify the port where metrics got sent to, default: 4242
    -t,--type                             Specify the collecting type, default: tcpbasics

    --apparg                              application specific arguments, you can list them like: --apparg ostype=windows --apparg arch=x86_64

Types:
    Nginx::SLA                            Parse nginx log to calculate Website's SLA

Examples:

    curl -LO http://op.sdo.com/download/ocollector
    chomd +x ocollector

    ./ocollector -t Nginx::SLA --apparg interval=60 --apparg prefer=hostname --apparg cluster=Nanhui
    ./ocollector -t Nginx::SLA --apparg interval=60 --apparg prefer=hostname --apparg cluster=Nanhui --apparg virtual=yes

    ./ocollector -t Nginx::SLA --apparg interval=60 --apparg prefer=hostname --apparg cluster=Nanhui --verbose
    ./ocollector -t Nginx::SLA --apparg interval=60 --apparg prefer=hostname --apparg cluster=Nanhui --quiet

HELP

    return 1;
}

sub send_metrics {
    my ($results, $ocollector_daemon, $ocollector_port, $ocollector_proto) = @_;

    my $rc = 0;

    # send directly through IO::Socket
    my $sock = IO::Socket::INET->new(
        PeerAddr => $ocollector_daemon,
        PeerPort => $ocollector_port,
        Proto    => $ocollector_proto,
    );

    unless ($sock) {
        $O_ERROR = "create ${ocollector_daemon}:$ocollector_port failed";
        return 0;
    }

    print {$sock} $results;
    close $sock;

    return 1;
}

sub log_succeed {
    my $msg = shift;
    printf("%s\t%s\n", strftime("%Y-%m-%d %H:%M:%S", localtime), "$msg");
}

sub log_exception {
    my $function = shift;
    printf("%s\t%s\n", strftime("%Y-%m-%d %H:%M:%S", localtime), "$function() failed: $O_ERROR\n");
}

sub main {
    # options

    my $ocollector_daemon       = 'op.sdo.com';
    my $ocollector_port         = 4242;
    my $ocollector_proto        = 'tcp';
    my $ocollector_version      = q{};
    my $ocollector_type         = q{};
    my $ocollector_verbose      = q{};
    my $ocollector_quiet        = q{};
    my $ocollector_apparg       = q{};
    my $help                    = q{};

    usage(1) if (@ARGV < 1);

    Getopt::Long::Configure("bundling");

    usage(2) unless GetOptions(
        "o|to=s" => \$ocollector_daemon,
        "p|port=i" => \$ocollector_port,
        "t|type=s" => \$ocollector_type,
        "q|quiet" => \$ocollector_quiet,
        "v|verbose" => \$ocollector_verbose,
        "V|version" => \$ocollector_version,
        "h|help" => \$help,
        "apparg=s%" => \$ocollector_apparg,
   );

    if ($ocollector_version) {
        print "ocollector version: $VERSION\n";
        exit 0;
    }

    usage(2) if $help;

    # plugin is a perl class
    my $supported = '(?:\w+::\w+)';

    if ($ocollector_type !~ /^(?:$supported)/ixsm) {
        croak "[$ocollector_type] is not a supported collecting type\n";
    }

    # build params hash for each collector type
    my $params;
    foreach my $arg (keys %{$ocollector_apparg}) {
        $params->{$arg} = $ocollector_apparg->{$arg};
    }

    # create module object and do the job
    my $module = "Ocollector::$ocollector_type";
    my $ot = $module->new($params);

    for (;;) {
        # Only send to tsd if we got a successful parse
        if (my $results = $ot->show_results) {
            if (send_metrics($results, $ocollector_daemon, $ocollector_port)) {
                if ($ocollector_verbose) {
                    log_succeed("send_metrics() succeed:\n$results") unless $ocollector_quiet;
                } else {
                    log_succeed("send_metrics() succeed.") unless $ocollector_quiet;
                }
            } else {
                log_exception('send_metrics') unless $ocollector_quiet;
            }
        } else {
            $O_ERROR = $ot->errormsg;
            log_exception('prepare_metrics') unless $ocollector_quiet;
            $ot->errormsg(q{});
        }

        sleep($ot->interval);
    }
}

main();
